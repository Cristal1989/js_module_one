<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 10</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">HTTP протокол</h3>
      <p>
        Перед тем как пользователь увидит содержимое сайта на экране браузер
        запросит сервер чтобы получить это содержимое. HTML файл, изображения
        стили и шрифты приходят с сервера по HTTP протоколу, набору правил и
        договоренностей используемых при передачи данных в сети
      </p>
      <img src="./images/http-protocol.jpg" alt="" class="img" />
      <p>
        HTTP (hyper text transfer protocol) - протокол передачи гипертекста,
        широко распространенный протокол для передачи веб ресурсов разных типов:
        html, css, JS, изображений, аудио, видео и т.д <br />
        HTTP основывается на структуре клиент-сервер и моделями запрос-ответ,
        которое клиентское приложение инициирует соединени, формирует запрос и
        отправляет его на сервер, после чего сервер обрабатывает этот запрос и
        формирует ответ и передает его обратно клиенту. Связь между ними
        осуществляется посредством ряда HTTP запросов и HTTP ответов
      </p>
      <img src="./images/request-response.jpg" alt="" class="img" />
      <p>Запрос проходит в несколько этапов</p>
      <ul>
        <li>
          DNS запрос - поиск ближайшего DNS сервера чтобы преобразовать адрес
          (например google.com), в ее числе выражения, IP адрес(74.125.87.99)
        </li>
        <li>
          Подключение - установка соединения с сервером по полученному IP адрусу
        </li>
        <li>Передача данных - пересылка пакетов с клиента на сервер</li>
        <li>
          Ожидание ответа - ожидание пока пакеты данных дойдут до сервера, он их
          обработает и ответ вернет обратно
        </li>
        <li>
          Получение данных - пакеты поступили, можно получить из них данные
        </li>
      </ul>
      <p>
        <b>HTTPS протокол (hyper text transfer protocol secure)</b><br />
        Это настройка над протоколом HTTP в который все сообщения между клиентом
        и сервером шифруются с целю повышенной безопасности. Обеспечивает защиту
        от атак, основаных на прослушивании соединения. Данные передаются поверх
        криптографических протоколов - SSL или TLS
      </p>
      <img src="./images/http-https.jpg" alt="" class="img" />
      <p>
        При обмене через обычное HTTP соединение все данные передаются в виде
        текста и могут быть прочитаны всеми, кто получил доступ к соединению
        между клиентом и сервером. Если пользователь совершает покупки онлайн и
        заполняет форму заказа, содержащую информацию о кредитной карте, их
        финансовые данные гораздо легче украсть, если они передаются в виде
        текста. С HTTPS данные будут зашифрованы и хакер не сможет их
        расшифровать т.к для расшифрования необходим доступ к закрытому ключу,
        хранящемуся на сервере <br />
        <b
          >Протокол HTTPS гарантирует что информация о клиенте, например номера
          кредитных карт зашифрованы и не может быть перехвачена в расшифрованом
          виде. Посетители могут убедится что сайт безопасен, посмотрев иконку
          слева от адресной строки, защищенное соединение обозначается иконкой
          замка
        </b>
      </p>
      <h3 class="title">Rest API</h3>
      <p>
        Сервер - это компьютер со спец програмным обеспечением. Бэкэнд - это
        программа, расположенная на сервере, способная обработать входящие HTTP
        запросы и имеющая набор готовых действий на определенный запрос.
      </p>
      <img src="./images/backend.jpg" alt="" class="img" />
      <p>
        <b>API (интерфейс прикладного программирования)</b> - набор четко
        определенных правил, связей между разными програмными компонентами.
        Интерфейс описывает что можно попросить приложение сделать и что будет в
        результате. <br />
        <b> REST (represantaition state transfer)</b> - стиль бэкэнд
        архитектуры, основывается на наборе принципов, описывающих каким образом
        определяется и адресуются сетевые ресурсы <br />
        <b>REST API</b> - бэкэнд построен по принципу REST. Служит прослойкой
        между веб приложений и базой данных. Имеет стандартный интерфейс
        обращения к ресурсам. Работая как веб сайт мы посылаем HTTP запрос
        клиента на сервер, а в ответ вместо HTML страницы получаем данные в JSON
        формате. <br />
        <b>Формат запроса</b> <br />
        REST сервис требует чтобы клиет производил запрос на добавление,
        удаление или изменения данных. Запрос может состоять из след частей
      </p>
      <img src="./images/rest-format.jpg" alt="" class="img" />
      <p>
        <b>HTTP методы.</b> Выделяют несколько основных HTTP методов для работы
        с REST сервисом
      </p>
      <img src="./images/http-method.jpg" alt="" class="img" />
      <p>
        <b>HTTP заголовки</b><br />
        Заголовки содержат служебную информацию относящуюся к контенту запроса.
        Например тип контент, который клиент может обработать в ответе от
        сервера (заголовок accept) или который описывает тип ресурса, который
        клиент отправляет серверу или сервер отправляет клиенту (заголовок
        content-type)
      </p>
      <p class="bg">
        Accept: text/html; <br />
        Content-type: application/JSON;
      </p>
      <p>
        <b> MIME типы</b> - варианты типов контента, используется для указания
        содержимого запроса и ответ, состоят из типа и подтипа, разделенных
        косой чертой "/". К примеру текстовый файл содержащий HTML будет описан
        типом text/html. Если файл содержит css он будет описан как text/css,
        данные в формате JSON будут описаны как application/JSON. Если клиет
        ожидает text/css а получает application/JSON он не сможет распознать и
        обработать контент ответа <br />
        <b>Пути</b><br />
        Запросы должны содержать путь к ресурсу над которым выполняется
        операция. Доступные пути (end поинты, ресурсы) описываются и в
        документации бэкэнда
      </p>
      <p class="bg">
        GET &lt; https://bookstore.com/api/orders &gt; <br />
        Accept: application/JSON
      </p>
      <p>
        Такой путь явно указывает на ресурс даже если вы его никогда раньше не
        видели, потому что он является иерархическим. Мы выполняетм запрос для
        получения коллекции заказа <br />
        Чтобы получить один элемент коллекции его индификатор добавляется к
        ресурсу. Рассмотрим запрос на чтение одного заказа с индификатором 289
      </p>
      <p class="bg">
        GET &lt; https://bookstore.com/api/orders/289 &gt; <br />
        Accept: application/JSON
      </p>
      <p>
        Последня часть пути называется динамический параметр и в документации
        описывается как /ресурс/:параметр. Ресурс не меняется, это путь в целую
        коллекцию, а значение параметра для каждого ее элемента <br />
        <b>Коды ответов</b><br />
        По запросу клиента сервер отправляет ответ, содержащий код состояния
        чтобы информировать клиента о результате операции. Коды деляться на
        группы <br />
        <img src="./images/groups.jpg" alt="" class="img" />
        <b
          >Нет необходимости помнить все коды каждой группы. Достаточно знать
          самые распространенные, остальные можно посмотреть в справочнике HTTP
          кода</b
        >
      </p>
      <img src="./images/codes.jpg" alt="" class="img" />
      <p>
        <b>Запрос-ответ</b><br />
        Предположим что у нас есть приложение которое позволяет просматривать,
        создавать, редактировать и удалять клиентов и заказ небольшого книжного
        магазина, бэкэнд которого размещен на &lt; https://bookstore.com/api
        &gt;. Используя полученные знания запишем псевдо код процесс
        запрос-ответ к бэкэнду. <br />
        Если мы хотим получить данные обо всех клиентах GET запрос будет
        выглядеть следующим образом
      </p>
      <p class="bg">
        GET &lt; https://bookstore.com/api/customers &gt;<br />
        Accept: application/JSON
      </p>
      <p>На что сервер отправит нам ответ</p>
      <p class="bg">
        Status: 200 OK <br />
        Content-type: application/JSON <br />
        Body: JSON данные обо всех клиентах
      </p>
      <p>
        Для получения данных для одного клиента мы указываем его индификатор
        уточняя его запрос
      </p>

      <p class="bg">
        GET &lt; https://bookstore.com/api/customers/289 &gt; <br />
        Accept: application/JSON <br />
      </p>
      <p>На что сервер отправит нам ответ</p>
      <p class="bg">
        Status: 200 OK <br />
        Content-type: application/JSON <br />
        Body: JSON данные о клиенте
      </p>
      <p>Для того чтобы добавить нового клиента выполняем POST запрос</p>
      <p class="bg">
        POST &lt; bookstore.com/api/customers/ &gt; <br />
        Content-type: application/JSON <br />
        Body: {"username": "Vasya", "email": "vasya@gmail.com"}
      </p>
      <p>
        Сервер добавляет уникальный индификатор и возвращает объект как
        результат <br />
        <b
          >Status: 201 CreatedContentType: application/jsonBody: {"id": 170,
          "username": "Vasya", "email": "vasya@gmail.com"}
        </b>
      </p>
      <h3 class="title">Ajax</h3>
      <p>
        <b>AJAX (Asynchronous java script and XML)</b> - метод получения или
        отправки данных с последующим обновлением интерфейса по этим данным, без
        необходимости перезагрузки страницы. Благодаря этому уменьшается время
        отклика и веб страница становится более интерактивной. Этот процесс
        можно разобрать на примере загрузки данных
      </p>
      <ul>
        <li>
          На веб странице происходит событие (страница загружается, нажимается
          кнопка "показать больше", отправляется форма и т.д)
        </li>
        <li>
          На клиенте с помощью JS скрипта реакция на это событие будет
          выполняться фукнция для работы с сервером где создается и отправляется
          гипер HTTP запрос
        </li>
        <li>
          Сервер получает и обрабатывает HTTP запрос отправляя обратно ответные
          данные в формате JSON
        </li>
        <li>
          На клиенте с помощью JS ответ от сервера обрабатывается, считываются
          данные и обновляется интерфейс
        </li>
      </ul>
      <p>
        <b
          >Не смотря на то что в названии технологии находится XML в современном
          интернете его заменил JSON, а название оставили как дань памяти. AJAX
          трактуется как любое общение с сервером без перезагрузки страницы</b
        ><br />
        <b>API interfase fetch</b><br />
        Интерфейс встроенный в браузер доступен на объекте Window, содержащим
        наборы свойств и методов для отправки, получение и обработки ресурсов от
        сервера. Метод fetch() предоставляет современный интерфейс для
        формирования запроса серверу и построен на promise <br />
        <b>fetch(url, options)</b>
      </p>
      <ul>
        <li>
          url - путь к данным на бэкэнде, который необходимо получить, создать
          или изменить, обязательный аргумент
        </li>
        <li>
          options - объект настроек запроса: метод (по умолчанию GET),
          заголовки, тело и т.д. Необязательный аргумент.
        </li>
      </ul>
      <p>
        Создадим запрос к JSONPlaceholder API - публичному REST API для быстрого
        прототипирования, который предоставляет коллекцию ненастоящих
        пользователей /users
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/users') <br />
        .then(response => {<br />
        // Обработка ответа<br />
        })<br />
        .then(data => {<br />
        // Обработка ответа<br />
        })<br />
        .catch(error => {<br />
        // Обработка ответа<br />
        });<br />
      </p>
      <p>
        <b>Обработка ответа</b><br />
        Значение возвращается через promise fetch() - это объект со служебной
        информацией о состоянии ответа сервера. Экземпляр класса response
        содержит разные методы и свойства. В зависимости от типа получаемого
        контента используются различные методы для превращения тела ответа в
        даные
      </p>
      <ul>
        <li><b>json()</b> - парсить данные в JSON формате</li>
        <li>
          <b>text()</b> - парсить данные в простом текстовом формате, например
          .csv(табличные данные)
        </li>
        <li>
          <b>blob()</b> - парсить данные описывающие файл, например изображение,
          аудио или видео
        </li>
      </ul>
      <p>
        В первом методе then() выполняется проверка статуса ответа и
        преобразование данных в правильный формат или явное создание ошибки
        чтобы обработать неудачный HTTP запрос в блоке catch().
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/users') <br />
        .then(response => {<br />
        // Обработка ответа<br />
        if (!response.ok) {<br />
        throw new Error(response.status);<br />
        }<br />
        return response.json();<br />
        })<br />
        .then(data => {<br />
        // Обработка ответа<br />
        })<br />
        .catch(error => {<br />
        // Обработка ответа<br />
        });<br />
      </p>
      <p>
        <b
          >Это необходимо чтобы fetch() правильно среагировал на статус кода 404
          который технически не является ошибкой но для клиента это неуспешный
          результат.
        </b>
      </p>
      <p>
        <b>Вкладка Network</b><br />
        В инструментах разработчика на вкладке Network отображаются все HTTP
        запросы выполняемые на странице. Выбрав фильтр XHR останутся только
        запросы к бэкэнду. После нажатия кнопки в примере через некоторое время
        запрос отобразится в списке. Выбрав его можно посмотреть служебную
        информацию и тело ответа на подвкладках Headers или Preview Response
      </p>
      <img src="./images/network-tab.jpg" alt="" class="img" />
      <p>
        <b>Работа с публичными REST API</b><br />
        Каждый бэкэнд уникален. С другой стороны REST API построен по
        стандартной архитектуре. Это означает что можно понять принцип их
        работы, после чего все что нужно сделать это ознакомиться с
        документацией того бэкэнда, который необходимо использовать. <br />
        Из документации берем url ресурса для запроса информации о коллекции
        ненастоящих пользователей. <br />
        <b>https://jsonplaceholder.typicode.com/users</b> <br />
        Этот путь состоит из следующих частей <br />
        https://jsonplaceholder.typicode.com/users - энд тип, базовый url, точка
        входа в API <br />
        /users - ресурс к которому мы обращаемся <br />
        По щелчку на кнопку fetch users сделаем GET запрос и выведем список
        пользователей по полученным данным.
      </p>
      <button type="button" class="btn">Fetch Users</button>
      <ul class="user-list"></ul>
      <p>
        <b
          >Функция fetchUsers возвращает promise, поэтому к результату ее вызова
          мы добаляем цепочку метода then() и catch()</b
        ><br />
        <b>Первичные ошибки</b><br />
        Разберем распространенные ошибки при работе с асинхронным кодом -
        попытку использовать данные HTTP запроса вне callback метода then().
        Новичок пытается записать результат fetch во внешнюю переменную и
        использовать ее
      </p>
      <p class="bg">
        let globalVariaribles; //undefind <br /><br />

        // Инициализация извлечения данных<br />
        fetch('https://jsonplaceholder.typicode.com/users').then(<br />
        response => response.json().then(users => {<br />
        console.log("Пользователи внутри then callback", users);<br />
        })<br />
        );<br /><br />

        // Запись результата в глобальную переменную <br />
        globalVariaribles = users;<br />
        console.log('globalVariaribles внутри fetch callback',
        globalVariaribles);<br /><br />

        // Здесь нет асинхронных данных<br />
        console.log('globalVariaribles снаружи fetch', globalVariaribles);<br />
      </p>
      <p>
        Вне колюека метода then() данных нет поскольку последний console.log()
        выполнится раньше чем поступит ответ сервера. В настоящее время
        переменная globalVariaribles еще содержит undefind. Выполнившиеся
        значение promise доступно только в колбеке метода then() <br />
        <b>Параметры строки запроса</b><br />
        Параметры запроса позволяют указать бэкэнду дополнительные критерии.
        Например сколько элементов в коллекции мы хотим получить в запросе.
        Возможно необходимо добавить сортировку по свойству объекта, ограничить
        выборку и т.д. Список параметров запроса, их название и возможные
        значения зависят от бэкэнда <br />
        Символ <b>?</b> показывает старт параметров запроса. Каждый параметр это
        пара имя-значение. Символ <b>&</b> используется для указания смыслового
        "и", разделяя параметры в строке запроса.
      </p>
      <p class="bg">
        const url =
        "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name"
      </p>
      <p>
        Такой GET запрос вернет массив из 7 польователей из 10, отсортированых
        по имени в поле name в алфавитном порядке. Подчеркивание _ в именах
        параметров спецефичные для этого бэкэнда, это не стандарт
      </p>
      <p>
        <b>Class URLSearchParams</b><br />
        Параметров может быть много и неудобно составлять из них одну длинную
        строчку как для читабельности так и для дальнейшего его редактирования.
        При составлении строк создается экземпляр класса URLSearchParams и
        инициализируется бэкэндом. Результатом будет специальный объект
        (етератор) с методами которые в строчном преобразовании возвращают
        результ вызова методу toString() свое строчное отображение
      </p>
      <p class="bg">
        const searchParams = new URLSearchParams({ <br />
        _limit: 5,<br />
        _sort: 'name',<br />
        });<br />
        console.log(searchParams.toString());<br /><br />

        const url =
        `https://jsonplaceholder.typicode.com/users?${searchParams}`;<br />
        console.log(url);<br />
      </p>
      <p>
        В строчном виде свойство объекта станут параметрами и их значениями.
        Параметры будут разделены символом &. В случае интерполяции значение в
        шаблонных строках происходит его преобразование в строку поэтому не
        нужно вызывать метод toString() при составлении url. Не забывайте
        указывать начало строки запроса символом "?".
      </p>
      <p>
        <b>HTTP Заголовки</b><br />
        Класс headers позволяет выполнять разные действия в заголовках HTTP
        запроса и ответа. К этим действиям относится извлечение, настройка,
        добавление и удаление заголовков
      </p>
      <p class="bg">
        const headers = new Headers({ <br />
        'content-type': 'application/json',<br />
        'custom-header': 'custom value',<br />
        });<br />
        headers.append('content-type', 'text/bash');<br />
        headers.append('custom-header', 'custom, value');<br /><br />

        console.log(headers.has('content-type')); //true<br />
        console.log(headers.get('content-type')); //application/json,
        text/bash<br />
        console.log(headers.set('content-type', "application/json")); //map
        obj<br />
        console.log(headers.delete('custom-header'));<br />
      </p>
      <p>
        На практике для составления заголовков запроса как правило используется
        просто литерал объекта со свойствами. В таком случае методов не будет
        что чаще всего не требуется.
      </p>
      <p class="bg">
        const headers = { <br />
        'content-type': 'application/json', <br />
        'custom-header': 'custom value', <br />
        }
      </p>
      <p>
        Запрос с использованием заголовков будет смотреться следующим образом
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/users', { <br />
        headers: {<br />
        Accept: 'application/json',<br />
        },<br />
        }).then(response => {<br />
        // Отклик<br />
        });<br />
      </p>
      <p>
        Cовременные браузеры добавляют много заголовков по умолчанию в
        зависимости от операции и тела запроса поэтому нет необходимости явно
        указывать стандартные заголовки.
      </p>
      <h3 class="title">Кросс доменные запросы</h3>
      <p>
        По умолчанию HTTP запрос можно производить только в рамках текущего
        сайта. При попытке запроса на другой домен, порт или протокол, т.е
        выполнить кросс доменный запрос, выдает ошибку. Это сделано из
        соображений безопасности и права доступа настраиваются на бэкэнде. Если
        бэкэнд не поддерживает кросс доменные запросы фронтэнд разработчик
        ничего не сможет с этим поделать в своем коде. <br />
        Эта политика браузера называется CORS и расшифровывается как cross
        original resurse sharing, где origin это и есть домен, порт и протокол.
        Дословный перевод звучит как совместное использование ресурсов между
        разными источниками. <br />
        На каждом запросе браузер сам добавляет заголовок HTTP origin, где
        указывает адрес веб страницы, которая хочет сделать HTTP запрос с веб
        страницы https://mysite.com/about на https://myapi.com/users то
        заголовки будут следущими
      </p>
      <p class="bg">
        GET /users <br />
        Host: myapi.com <br />
        Origin: https://mysite.com
      </p>
      <p>
        Сервер проверяет заголовок origin и если он поддерживает кросс доменные
        запросы добавляет в ответ спец HTTP заголовок access control allow
        origin
      </p>
      <p class="bg">
        <br />
        // Private API <br />
        Access-Control-Allow-Origin: https://mysite.com <br />
        // Pablic API <br />
        Access-Control-Allow-Origin: * <br />
      </p>
      <p>
        Значением этого заголовка будет разрешен источник origin, в нашем случае
        это должен быть один сайт mysite, если бэкэнд частный или *, если бэкэнд
        публичный - позволяет делать запросы кому угодно.
      </p>
      <img src="./images/cors.jpg" alt="" class="img" />
      <p>
        Т.е браузер это определенный посредник между JS кодом и бэкэндом. Он
        добавляет каждому запросу заголовок origin с правильный значением и
        проверяет наличие заголовка Access-Control-Allow-Origin в ответе. Если
        заголовок есть и его значение подходит выполняется исходный запрос и
        скрипт js получит его результат, в противном случае будет ошибка CORS.
      </p>
      <p>
        <b>Пагинация</b><br />
        База данных может хранить коллекции, содержащие сотни миллионов записей,
        поэтому возвращать всю коллекцию на каждый GET запрос слишком
        ресурсозатратно. Размер тела ответа будет слишком велик и время запроса
        затянется на десятки секунд. Чем больше данных в ответе от бэкэнда тем
        дольше она передается сетью. <br />
        К тому же необходимо думать о пользователях, вряд ли им нужны все
        1000000 запросов записи сразу. Обработка столь большого кол-ва данных в
        ответе и отображении интерфейса требует огромных ресурсов устройства на
        котором просматривается веб страница. По статистике пользователи находят
        интересующию их информацию на первых страницах. <br />
        Допустим наш бэкэнд myapi.com хранит очень большую коллекцию постов
        resurs/posts, которые изобразим 12ю элементами на иллюстрации.
      </p>
      <img src="./images/no-pagination.jpg" alt="" class="img" />
      <p>
        На каждый get запрос бэкэнда прийдется вернуть всю коллекцию и мы
        столкнемся с проблемами описаными ранее. Для их решения существует
        пагинация за которым на первый и каждый последующий get запрос
        возвращается не вся коллекция а определенная ее часть. Пагинация
        реализуется на бэкэнде и используется на фронтэнде с помощью специальных
        параметров запроса. <br />
        <b>Колличество элементов ответа</b><br />
        Первый параметр определяет кол-во элементов в ответе от бэкэнда. Пусть в
        нашем случае он называется per_page. Стандарт именования пагинации
        отсутствует, поэтому их имена зависят от бэкэнд разработчика.
      </p>
      <img src="./images/per-page-param.jpg" alt="" class="img" />
      <p>
        В таком запросе бэкэнда вернет не всю коллекцию из 12 элементов, а
        только первые ее 4. Если передать отрицательное значение или значение
        большее кол-ва элементов в коллекции то бэкэнд может ответить по разному
        - проигнорировать ил вернуть ошибку 400 (BAD REQUEST) в зависимости от
        его реализации. <br />
        Публичный JSON Placeholder API так же поддерживает пагинацию. <br />
        https://github.com/typicode/json-server#paginate <br />
        Кол-во ответных элементов контролируется параметром _limit. Всего
        коллекция/пост насчитывает 100 элеметов. Изменим значение параметра
        _limit в примере и исследует ответ бэкэнда в интерфейсе.
      </p>
      <div>
        <button type="button" class="btn1">Fetch posts</button>
        <ul class="posts"></ul>
      </div>
      <p class="bg">
        const fetchPostsBtn = document.querySelector('.btn1'); <br />
        const postLimit = document.querySelector('.posts');<br /><br />

        fetchPostsBtn.addEventListener('click', async () => {<br />
        try {<br />
        const posts = await fetchPosts();<br />
        renderPosts(posts);<br />
        } catch (error) {<br />
        console.log(error);<br />
        }<br />
        });<br /><br />

        async function fetchPosts() {<br />
        const response = await axios.get(<br />
        'https://jsonplaceholder.typicode.com/posts?_limit=10'<br />
        );<br />
        return response.data;<br />
        }<br /><br />

        function renderPosts(posts) {<br />
        const markUp = posts<br />
        .map(({ id, title, body, userId }) => {<br />
        return ` <br />
        &lt;li&gt;<br />
        &lt;h2 class=&quot;post-title&quot;&gt;${title.slice(0,
        30)}&lt;/h2&gt;<br />
        &lt;p&gt;&lt;b&gt;Post ID&lt;/b&gt;: ${id}&lt;/p&gt;<br />
        &lt;p&gt;&lt;b&gt;Author ID&lt;/b&gt;: ${userId}&lt;/p&gt;<br />
        &lt;p&gt;${body}&lt;/p&gt;<br />
        &lt;/li&gt;<br />
        `; }) <br />.join(''); <br />postLimit.innerHTML = markUp; } <br />
        &lt;script
        src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        <b>Номер группы элементов</b><br />
        Указав желаемое кол-во ответных элементов мы всегда получим одинаковый
        результат - первые per-page элементов коллекции. Так называемую первую
        группу или страницу. Второй параметр пагинации контролирует смещение
        внутри коллекции например группы элементов которые мы хотим получить.
        Если бэкэнд реализует пагинацию то значение этого параметра по умолчанию
        еденица - первая группа или страница элементов
      </p>
      <img src="./images/page-param.jpg" alt="" class="img" />
      <p>
        <b>Параметры страниц</b><br />
        Изменяя значения параметров page мы уточняем бэкэнду которую следующую
        группу мы хотим получить пока в коллекции не закончатся элементы. Если
        указать отрицательное значение или более групп в коллекции - ответ
        бэкэнда будет зависеть от его реализации.
      </p>
      <div>
        <button type="button" class="btn btn2">Fetch posts</button>
        <ul class="posts2"></ul>
      </div>
      <p class="bg">
        const fetchPostsBtn2 = document.querySelector('.btn2'); <br />
        const postLimit2 = document.querySelector('.posts2');<br /><br />

        fetchPostsBtn2.addEventListener('click', async () => {<br />
        try {<br />
        const posts = await fetchPosts2();<br />
        renderPosts2(posts);<br />
        } catch (error) {<br />
        console.log(error);<br />
        }<br />
        });<br /><br />

        async function fetchPosts2() {<br />
        const params = new URLSearchParams({<br />
        _limit: 5,<br />
        _page: 3,<br />
        });<br />
        const response = await axios.get(<br />
        `https://jsonplaceholder.typicode.com/posts?${params}`<br />
        );<br />
        return response.data;<br />
        }<br /><br />

        function renderPosts2(posts) {<br />
        const markUp = posts<br />
        .map(({ id, title, body, userId }) => {<br />
        return `&lt;li&gt;<br />
        &lt;h2 class=&quot;post-title&quot;&gt;${title.slice(0,
        30)}&lt;/h2&gt;<br />
        &lt;p&gt;&lt;b&gt;Post ID&lt;/b&gt;: ${id}&lt;/p&gt;<br />
        &lt;p&gt;&lt;b&gt;Author ID&lt;/b&gt;: ${userId}&lt;/p&gt;<br />
        &lt;p&gt;${body}&lt;/p&gt;<br />
        &lt;/li&gt;`;<br />
        })
        <br />
        .join('');<br />
        postLimit2.innerHTML = markUp;<br />
        }<br />
      </p>
      <p>
        Чтобы знать когда кончатся элементы в коллекции и вывести это сообщение
        пользователю бэкэнд в каждом ответе возвразает не только массив
        элементов но и мета данные о доступном кол-ве групп (страниц), зависищем
        от значения параметра per_page или просто общее кол-во в коллекции. В
        таком случае вычесление кол-ва групп ложится на плечи фронтэнд
        разработчика, JSONPlaceholder Api не реализует этот фукнционал. <br />
        <b> Прием "загрузить еще"</b><br />
        Чтобы динамически изменить номер группы по каждому след запросу
        достаточно объявить еще одну глобальную переменную, назовем ее page и
        установим начальное значение 1 - первая группа элементов. После каждого
        успешного запроса в колбеке метода then() будем увеличавать значение
        page на 1. Составляя параметры запроса, используем ее значение.
      </p>
      <div>
        <ul class="posts3"></ul>
        <button type="button" class="btn btn3">Fetch posts</button>
      </div>
      <p class="bg">
        const fetchPostsBtn3 = document.querySelector('.btn3'); <br />
        const postLimit3 = document.querySelector('.posts3');<br />
        let page = 1;<br />
        let perPage = 10;<br />

        fetchPostsBtn3.addEventListener('click', async () => {<br />
        try {<br />
        const posts = await fetchPosts3();<br />
        renderPosts3(posts);<br />
        page += 1;<br />
        if (page > 1) {<br />
        fetchPostsBtn3.textContent = 'Fetch More Posts';<br />
        }<br />
        } catch (error) {<br />
        console.log(error);<br />
        }<br />
        });<br /><br />

        async function fetchPosts3() {<br />
        const params = new URLSearchParams({<br />
        _limit: perPage,<br />
        _page: page,<br />
        });<br />
        const response = await axios.get(<br />
        `https://jsonplaceholder.typicode.com/posts?${params}`<br />
        );<br />
        return response.data;<br />
        }<br />
      </p>
      <p>
        После загрузки первой группы элементов текст кнопки изменится <br />
        Мы добавили проверку конца коллекции на фронтэнде потому что
        JSONPlaceholder API не реализует этот функционал в бэкэнде. В нашем
        случае достаточно поделить общее кол-во элементов в коллекции на кол-во
        элементов в одной группе. Когда бэкэнд возвращает не кол-во доступных
        страниц а общее кол-во элементов доступных в коллекции.
      </p>
      <h3 class="title">CRUD</h3>
      <p>Для взамодействия с ресурсами бэкэнда используется четыре операции:</p>
      <ul>
        <li><b>Создание (create)</b></li>
        <li><b>Чтение (read)</b></li>
        <li><b>Обновление (update)</b></li>
        <li><b>Удаление (delete)</b></li>
        Для каждого из них определен стандартный HTTP метод
      </ul>
      <p>
        <b>Описание метода</b><br />
        POST операция create - создать новый ресурс. <br />
        GET операция read - получить набор ресурсов или один ресурс по
        индификатору <br />
        PUT и PATCH операция update - обновить ресурс по индификатору. <br />
        DELETE операция delete - удалить ресурс по индификатору
      </p>
      <p>
        <b>Чтение</b><br />
        HTTP метод GET используется для получения существующих данных. <br />
        Метод fetch() должен отпралять на сервер get запрос без тела. Бэкэнд
        после получения запроса обрабатывает его и в ответе вернет необходимый
        ресурс. <br />
        Получим массив всех постов. С этой целью обращаемся к ресурсу /posts
        описаному в документации бэкэнду. Метод fetch() по умолчанию делает get
        запрос, поэтому необязательно переопределять опции запроса.
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/posts') <br />
        .then(response => response.json())<br />
        .then(posts => console.log(posts))<br />
        .catch(error => console.log(error));<br />
      </p>
      <p>
        Получим 1 пост по индификатору (id), добавив его к ресурсу
        /posts/:postid. Последняя часть этого пути называется динамическим
        параметром и в документации описывается как /resurse/:params. Ресурс не
        меняется, это путь в целую коллекцию, а значение параметра меняется для
        каждого его элемента.
      </p>
      <p class="bg">
        const postId = 1; <br /><br />

        fetch(`https://jsonplaceholder.typicode.com/posts/${postId}`)<br />
        .then(response => response.json())<br />
        .then(posts => console.log(posts))<br />
        .catch(error => console.log(error));<br />
      </p>
      <p>
        <b>CREATE</b><br />
        Метод post() используется для добавления нового ресурса. Метод fetch()
        должен отправлять пост запрос на сервер в теле которого будет объект с
        полями after и body, индификатор будет автоматически создан базой
        данных. Результатом запроса будет объект добавленный в базу данных
      </p>
      <p class="bg">
        const postToAdd = { <br />
        author: "Athor Name",<br />
        body: "Create is awesome"<br />
        };<br />
        const options = {<br />
        method: "POST",<br />
        body: JSON.stringify(postToAdd),<br />
        headers: {"contentType": "application/json"}<br />
        }<br />
        fetch('https://jsonplaceholder.typicode.com/posts', options)<br />
        .then(response => response.json())<br />
        .then(posts => console.log(posts))<br />
        .catch(error => console.log(error));<br />
      </p>
      <p>
        Делаем запрос на создание поста обращаясь к ресурсу /posts но в
        настройках метод fetch() меняем HTTP метод на post. Таким образом бэкэнд
        уже знает что нужно не прочесть уже существующий, а создать новый ресурс
        в этой коллекции <br />
        Тело запроса должно быть строчкой т.к протокол HTTP передает все как
        текст. При передачи сложных типов данных их необходимо перевести в
        строку методом JSON.stringify(). Укажем заголовок "content type"
        уточняющий для бэкэнд тип передаваемых данных
      </p>
      <p class="bg">
        { <br />
        "id": 1,<br />
        "author": "Author Name",<br />
        "content": "Text Content" <br />};
      </p>
      <p>
        <b>UPDATE</b>
        Метод PATCH и PUT используется для обновления существующих данных. Какой
        метод использовать будет написано в документации бэкэнда. Метод fetch()
        должен отправлять на сервер запрос в котором необходимо в теле объекта
        указать поля для изменений. Путь указывает в какой коллекции и какой
        элемент мы хотим обновить. Бэкэнд после получения запроса обрабатывает
        его и в ответе вернет обновленный ресурс
      </p>
      <p class="bg">
        const postToUpdate = { <br />
        id: 1,<br />
        body: "Text content",<br />
        }<br />
        const options = {<br />
        method: 'PATCH',<br />
        body: JSON.stringify(postToUpdate),<br />
        headers: { "contentType": 'application/json' },<br />
        }<br />
        fetch(`https://jsonplaceholder.typicode.com/posts/${postToUpdate.id}`,
        options)<br />
        .then(response => response.json())<br />
        .then(post => console.log(post))<br />
        .catch(error => console.log("ERROR" + error));<br />
        //<br />
        {<br />
        userId: 1,<br />
        id: 1,<br />
        title: 'sunt aut facere repellat provident occaecati excepturi optio
        reprehenderit',<br />
        body: 'quia et suscipit\n' +<br />
        'suscipit recusandae consequuntur expedita et cum\n' +<br />
        'reprehenderit molestiae ut ut quas totam\n' +<br />
        'nostrum rerum est autem sunt rem eveniet architecto'<br />
        }<br />
      </p>
      <p>
        Метод PATCH заменяет в существующем ресурсе значение передаваемые через
        запросы свойств. Метод PUT полностью заменяет ресурс. <br />
        <b>DELETE</b><br />
        Метод DELETE используется для удаления существующих данных. Метод
        fetch() должен отправлять на сервер delete запрос без тела. Путь
        указывает в какой коллекции и какой элемент мы хотим удалить. Бэкэнд
        после получения запроса обрабатывает его, удалит ресурс из коллекции и в
        ответ вернет статус результат.
      </p>
      <p class="bg">
        const postIdToDelete = 1; <br />
        fetch(`https://jsonplaceholder.typicode.com/posts/${postIdToDelete}`,
        {method: "DELETE"})<br />
        .then(()=> console.log("Post Deleted"))<br />
        .catch(error => console.log("ERROR: ", error));<br />
      </p>
      <h3 class="title">Асинхронные функции</h3>
      <p>
        Работа с бэкэндом может быть запутана. После одной асинхронной операции
        необходимо сделать еще один запрос на сервер на оснавании полученных
        данных, и так несколько раз. К примеру на странице профиля пользователь
        хочет посмотреть список друзей. Первое что необходимо сделать -
        подтвердить его права доступа к этой странице на бэкэнде. Для этого
        нужно запустить myapi.com/me. Если бэкэнд позволит доступ, в ответ мы
        получим уникальный токен доступа к защищенным ресурсам
      </p>
      <p class="bg">
        const fetchFriends = () => { <br />
        return fetch('myapi.com/me').then(token => {<br />
        console.log(token);<br />
        })<br />
        }<br />
      </p>
      <p>
        Затем необходимо сделать запрос профиля пользователя с
        myapi.com/profile, но профиль не полный, он содержит только критическо
        важную инфу: индификатор пользователя без списка друзей
      </p>
      <p class="bg">
        const fetchFriends = () => { <br />
        return fetch('myapi.com/me').then(token => {<br />
        return fetch(`myapi.com/profile?token=${token}`).then(user => {<br />
        console.log(user.id);<br />
        })<br />
        })<br />
        }<br />
      </p>
      <p>
        И только после этого можно запросить список друзей <br />
        myapi.com/users/:userid/friends
      </p>
      <p class="bg">
        const fetchFriends = () => { <br />
        return fetch('myapi.com/me').then(token => {<br />
        return fetch(`myapi.com/profile?token=${token}`).then(user => {<br />
        return fetch(`myapi.com/users/${user.id}/friends`)<br />
        })<br />
        })<br />
        }<br />
        fetchFriends().then(friends => {<br />
        console.log(friends);<br />
        }).catch(error => console.error(error))<br />
      </p>
      <p>
        Не самый удобный способ для чтения кода хотя операции сомнительно
        простые. Поскольку мы передаем функции обработчики метода then()
        образовывая елковидную вложенность <br />
        Асинхронные функции помогают избавится от колбэков и вложенных
        конструкций. В то же время они отлично работают вместе с методом then()
        и catch() потому что гарантировано возвращают промис.
      </p>
      <p class="bg">
        const fetchFriends = async => { <br />
        const token = await fetch('myapi.com/me');<br />
        const user = await fetch(`myapi.com/profile?token=${token}`);<br />
        const friends = await fetch(`myapi.com/users/${user.id}/friends`);<br />
        return friends;<br />
        }<br /><br />

        fetchFriends()<br />
        .then(friends => console.log(friends))<br />
        .catch(error => console.error(error));<br />
      </p>
      <p>
        <b>Синтаксис async await</b><br />
        <b>Асинхронная функция async await</b> - удобный способ написания
        асинхронного кода. В основе синтаксиса async await лежат promise,
        поэтому он не блокирует основной поток выполнения программы. <br />
        Для объявления асинхронной стрелочной функции перед списком параметров
        добавляем ключевое слово async. А внутри нее можно использовать оператор
        await и справа от него поставить нечто что вернет нам promise. Метод
        response.json() так же возвращает promise поэтому ставим await
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        const response = await
        fetch('https://jsonplaceholder.typicode.com/users');<br />
        const users = await response.json();<br />
        return users;<br />
        };<br /><br />

        fetchUsers().then(users => console.log(users));<br />
      </p>
      <p>
        Когда инторпритатор вт=стречает await он приостанавля=ивает выполнение
        этой функции (не только скрипта) и ждет пока не выполнится promise
        справа от await. Как только promise выполнится выполнение функции
        востанавливается и на строке ниже нам доступен результат асинхронной
        операции
      </p>
      <ul>
        <li>
          Оператор await - можно использовать только в теле асинхронной функции
          async
        </li>
        <li>
          Оператор await приостанавливает функцию пока promise не выполнится
          (fulfilled & reject)
        </li>
        <li>
          Если promise успешный (fulfilled) оператор await вернет его значение
        </li>
        <li>Если promise отклонен (reject) оператор await выбросит ошибку</li>
        <li>
          Асинхронная функция всегда возвращает promise поэтому любое
          возвращаемое значение будет его значением
        </li>
        <li>
          Если не указать возвращаемое значение возвратится promise со значением
          undefind
        </li>
      </ul>
      <p>
        Любая функция может быть асинхронной будь то метод объекта, класса,
        колбэк, объявление или инлайн функция. Все они могут использовать
        оператор await и вернут promise, потому что будут асинхронными
        функциями.
      </p>
      <p class="bg">
        // Function declaration <br />
        async function foo() {<br />
        // Тело функции<br />
        }<br /><br />

        // Function expression<br />
        const foo = async function () {<br />
        // Тело функции<br />
        }<br /><br />

        // Array function<br />
        const foo = async () => {<br />
        // Тело функции<br />
        }<br /><br />

        // Метод объекта<br />
        const user = {<br />
        async foo() {<br />
        // Тело функции<br />
        }<br />
        }<br /><br />

        // Метод класса<br />
        class User{<br />
        async foo() {<br />
        // Тело функции<br />
        }<br />
        }<br />
      </p>
      <p>
        Обработчик ошибок <br />
        Если результат асинхронной функции (promise) не используется во внешнем
        коде, ошибки обрабатываются в теле функции try/catch. Значение параметра
        error в блоке catch это ошибка, котору сгенерирует await если promise
        будет отклонен
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        try {<br />
        const response = await
        fetch('https://jsonplaceholder.typicode.com/users');<br />
        const users = await response.json();<br />
        console.log(users);<br />
        } catch (error) {<br />
        console.log(error.message);<br />
        }<br />
        };<br /><br />

        fetchUsers();<br />
      </p>
      <p>
        Если результат асинхронной функции (promise) используется во внешнем
        коде (глобально) т.е вне других асинхронных функций, ошибки
        обрабатываются колбэком метода catch. Значение параметра error в методе
        catch это ошибка, которую сгенерирует await если promise будет отклонен.
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        const response = await
        fetch('https://jsonplaceholder.typicode.com/users');<br />
        const users = await response.json();<br />
        return users;<br />
        }<br /><br />

        fetchUsers().then(users => console.log(users)).catch(error =>
        console.log(error));<br />
      </p>
      <p>
        Так работать не будет - await можно использовать только в теле
        асинхронной функции
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        const response = await
        fetch('https://jsonplaceholder.typicode.com/users');<br />
        const users = await response.json();<br />
        return users;<br />
        };<br /><br />

        const users = await fetchUsers();
      </p>
      <p>
        Если результат асинхронной функции используется в другой асинхронной
        функции то ошибки обрабатываются в конструкции try/catch, значение
        параметра error в блоке catch это ошибка, которую сгенерирует await если
        promise будет отклонен
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        const response = await
        fetch('https://jsonplaceholder.typicode.com/users');<br />
        const users = await response.json();<br />
        return users;<br />
        };<br /><br />

        const asyncFoo = async () => {<br />
        try {<br />
        const users = await fetchUsers();<br />
        console.log(users);<br />
        } catch (error) {<br />
        console.log(error.message);<br />
        }<br />
        }<br /><br />

        asyncFoo();<br />
      </p>
      <p>
        <b>Параллельные запросы</b><br />
        Если одновременно необходимо сделать несколько запросов то использовать
        синтаксис async/await нужно очень осторожно. В след примере будет три
        последовательных запроса, т.к выполнение асинхронной функции
        приостанавливается, когда инторпритатор встречает await. Кроме того парс
        результатов запросов так же будет последовательным что займет больше
        времени
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        const baseUrl = 'https://jsonplaceholder.typicode.com';<br />
        const firstResponse = await fetch(`${baseUrl}/users/1`);<br />
        const secondResponse = await fetch(`${baseUrl}/users/2`);<br />
        const thirdResponse = await fetch(`${baseUrl}/users/3`);<br /><br />

        const firstUser = await firstResponse.json();<br />
        const secondUser = await secondResponse.json();<br />
        const thirdUser = await thirdResponse.json();<br /><br />

        console.log(firstUser, secondUser, thirdUser);<br />
        };<br /><br />

        fetchUsers();
      </p>
      <p>
        В нашем случае они полностю независимые, поэтому нужно запустить их
        параллельно. Для этого создается масси в promises после чего
        используется метод Promise.all() для ожидания их выполнения. Массив
        промисов создается методом map(), filter() в зависимости от задачи
      </p>
      <p class="bg">
        const fetchUsers = async () => { <br />
        const baseUrl = 'https://jsonplaceholder.typicode.com';<br />
        const userIds = [1, 2, 3];
        <br /><br />
        // Создаем массив promise<br />
        const arrayOfPromoses = userIds.map(async userId => {<br />
        const response = await fetch(`${baseUrl}/users/${userId}`);<br />
        return response.json();<br />
        })<br /><br />

        // Запускаем все promises параллельно и ждем их завершения<br />
        const users = await Promise.all(arrayOfPromoses);<br />
        console.log(users);<br />
        }<br /><br />

        fetchUsers();
      </p>
      <div>
        <button type="button" class="btn5 btn">Fetch users</button>
        <ul class="user-list5"></ul>
      </div>
    </section>
    <!-- <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script> -->
    <!-- <script src="./js/moduleTen.js"></script> -->
    <script src="./js/fetchUsers.js"></script>
  </body>
</html>

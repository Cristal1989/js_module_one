<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 10</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">HTTP протокол</h3>
      <p>
        Перед тем как пользователь увидит содержимое сайта на экране браузер
        запросит сервер чтобы получить это содержимое. HTML файл, изображения
        стили и шрифты приходят с сервера по HTTP протоколу, набору правил и
        договоренностей используемых при передачи данных в сети
      </p>
      <img src="./images/http-protocol.jpg" alt="" class="img" />
      <p>
        HTTP (hyper text transfer protocol) - протокол передачи гипертекста,
        широко распространенный протокол для передачи веб ресурсов разных типов:
        html, css, JS, изображений, аудио, видео и т.д <br />
        HTTP основывается на структуре клиент-сервер и моделями запрос-ответ,
        которое клиентское приложение инициирует соединени, формирует запрос и
        отправляет его на сервер, после чего сервер обрабатывает этот запрос и
        формирует ответ и передает его обратно клиенту. Связь между ними
        осуществляется посредством ряда HTTP запросов и HTTP ответов
      </p>
      <img src="./images/request-response.jpg" alt="" class="img" />
      <p>Запрос проходит в несколько этапов</p>
      <ul>
        <li>
          DNS запрос - поиск ближайшего DNS сервера чтобы преобразовать адрес
          (например google.com), в ее числе выражения, IP адрес(74.125.87.99)
        </li>
        <li>
          Подключение - установка соединения с сервером по полученному IP адрусу
        </li>
        <li>Передача данных - пересылка пакетов с клиента на сервер</li>
        <li>
          Ожидание ответа - ожидание пока пакеты данных дойдут до сервера, он их
          обработает и ответ вернет обратно
        </li>
        <li>
          Получение данных - пакеты поступили, можно получить из них данные
        </li>
      </ul>
      <p>
        <b>HTTPS протокол (hyper text transfer protocol secure)</b><br />
        Это настройка над протоколом HTTP в который все сообщения между клиентом
        и сервером шифруются с целю повышенной безопасности. Обеспечивает защиту
        от атак, основаных на прослушивании соединения. Данные передаются поверх
        криптографических протоколов - SSL или TLS
      </p>
      <img src="./images/http-https.jpg" alt="" class="img" />
      <p>
        При обмене через обычное HTTP соединение все данные передаются в виде
        текста и могут быть прочитаны всеми, кто получил доступ к соединению
        между клиентом и сервером. Если пользователь совершает покупки онлайн и
        заполняет форму заказа, содержащую информацию о кредитной карте, их
        финансовые данные гораздо легче украсть, если они передаются в виде
        текста. С HTTPS данные будут зашифрованы и хакер не сможет их
        расшифровать т.к для расшифрования необходим доступ к закрытому ключу,
        хранящемуся на сервере <br />
        <b
          >Протокол HTTPS гарантирует что информация о клиенте, например номера
          кредитных карт зашифрованы и не может быть перехвачена в расшифрованом
          виде. Посетители могут убедится что сайт безопасен, посмотрев иконку
          слева от адресной строки, защищенное соединение обозначается иконкой
          замка
        </b>
      </p>
      <h3 class="title">Rest API</h3>
      <p>
        Сервер - это компьютер со спец програмным обеспечением. Бэкэнд - это
        программа, расположенная на сервере, способная обработать входящие HTTP
        запросы и имеющая набор готовых действий на определенный запрос.
      </p>
      <img src="./images/backend.jpg" alt="" class="img" />
      <p>
        <b>API (интерфейс прикладного программирования)</b> - набор четко
        определенных правил, связей между разными програмными компонентами.
        Интерфейс описывает что можно попросить приложение сделать и что будет в
        результате. <br />
        <b> REST (represantaition state transfer)</b> - стиль бэкэнд
        архитектуры, основывается на наборе принципов, описывающих каким образом
        определяется и адресуются сетевые ресурсы <br />
        <b>REST API</b> - бэкэнд построен по принципу REST. Служит прослойкой
        между веб приложений и базой данных. Имеет стандартный интерфейс
        обращения к ресурсам. Работая как веб сайт мы посылаем HTTP запрос
        клиента на сервер, а в ответ вместо HTML страницы получаем данные в JSON
        формате. <br />
        <b>Формат запроса</b> <br />
        REST сервис требует чтобы клиет производил запрос на добавление,
        удаление или изменения данных. Запрос может состоять из след частей
      </p>
      <img src="./images/rest-format.jpg" alt="" class="img" />
      <p>
        <b>HTTP методы.</b> Выделяют несколько основных HTTP методов для работы
        с REST сервисом
      </p>
      <img src="./images/http-method.jpg" alt="" class="img" />
      <p>
        <b>HTTP заголовки</b><br />
        Заголовки содержат служебную информацию относящуюся к контенту запроса.
        Например тип контент, который клиент может обработать в ответе от
        сервера (заголовок accept) или который описывает тип ресурса, который
        клиент отправляет серверу или сервер отправляет клиенту (заголовок
        content-type)
      </p>
      <p class="bg">
        Accept: text/html; <br />
        Content-type: application/JSON;
      </p>
      <p>
        <b> MIME типы</b> - варианты типов контента, используется для указания
        содержимого запроса и ответ, состоят из типа и подтипа, разделенных
        косой чертой "/". К примеру текстовый файл содержащий HTML будет описан
        типом text/html. Если файл содержит css он будет описан как text/css,
        данные в формате JSON будут описаны как application/JSON. Если клиет
        ожидает text/css а получает application/JSON он не сможет распознать и
        обработать контент ответа <br />
        <b>Пути</b><br />
        Запросы должны содержать путь к ресурсу над которым выполняется
        операция. Доступные пути (end поинты, ресурсы) описываются и в
        документации бэкэнда
      </p>
      <p class="bg">
        GET &lt; https://bookstore.com/api/orders &gt; <br />
        Accept: application/JSON
      </p>
      <p>
        Такой путь явно указывает на ресурс даже если вы его никогда раньше не
        видели, потому что он является иерархическим. Мы выполняетм запрос для
        получения коллекции заказа <br />
        Чтобы получить один элемент коллекции его индификатор добавляется к
        ресурсу. Рассмотрим запрос на чтение одного заказа с индификатором 289
      </p>
      <p class="bg">
        GET &lt; https://bookstore.com/api/orders/289 &gt; <br />
        Accept: application/JSON
      </p>
      <p>
        Последня часть пути называется динамический параметр и в документации
        описывается как /ресурс/:параметр. Ресурс не меняется, это путь в целую
        коллекцию, а значение параметра для каждого ее элемента <br />
        <b>Коды ответов</b><br />
        По запросу клиента сервер отправляет ответ, содержащий код состояния
        чтобы информировать клиента о результате операции. Коды деляться на
        группы <br />
        <img src="./images/groups.jpg" alt="" class="img" />
        <b
          >Нет необходимости помнить все коды каждой группы. Достаточно знать
          самые распространенные, остальные можно посмотреть в справочнике HTTP
          кода</b
        >
      </p>
      <img src="./images/codes.jpg" alt="" class="img" />
      <p>
        <b>Запрос-ответ</b><br />
        Предположим что у нас есть приложение которое позволяет просматривать,
        создавать, редактировать и удалять клиентов и заказ небольшого книжного
        магазина, бэкэнд которого размещен на &lt; https://bookstore.com/api
        &gt;. Используя полученные знания запишем псевдо код процесс
        запрос-ответ к бэкэнду. <br />
        Если мы хотим получить данные обо всех клиентах GET запрос будет
        выглядеть следующим образом
      </p>
      <p class="bg">
        GET &lt; https://bookstore.com/api/customers &gt;<br />
        Accept: application/JSON
      </p>
      <p>На что сервер отправит нам ответ</p>
      <p class="bg">
        Status: 200 OK <br />
        Content-type: application/JSON <br />
        Body: JSON данные обо всех клиентах
      </p>
      <p>
        Для получения данных для одного клиента мы указываем его индификатор
        уточняя его запрос
      </p>

      <p class="bg">
        GET &lt; https://bookstore.com/api/customers/289 &gt; <br />
        Accept: application/JSON <br />
      </p>
      <p>На что сервер отправит нам ответ</p>
      <p class="bg">
        Status: 200 OK <br />
        Content-type: application/JSON <br />
        Body: JSON данные о клиенте
      </p>
      <p>Для того чтобы добавить нового клиента выполняем POST запрос</p>
      <p class="bg">
        POST &lt; bookstore.com/api/customers/ &gt; <br />
        Content-type: application/JSON <br />
        Body: {"username": "Vasya", "email": "vasya@gmail.com"}
      </p>
      <p>
        Сервер добавляет уникальный индификатор и возвращает объект как
        результат <br />
        <b
          >Status: 201 CreatedContentType: application/jsonBody: {"id": 170,
          "username": "Vasya", "email": "vasya@gmail.com"}
        </b>
      </p>
      <h3 class="title">Ajax</h3>
      <p>
        <b>AJAX (Asynchronous java script and XML)</b> - метод получения или
        отправки данных с последующим обновлением интерфейса по этим данным, без
        необходимости перезагрузки страницы. Благодаря этому уменьшается время
        отклика и веб страница становится более интерактивной. Этот процесс
        можно разобрать на примере загрузки данных
      </p>
      <ul>
        <li>
          На веб странице происходит событие (страница загружается, нажимается
          кнопка "показать больше", отправляется форма и т.д)
        </li>
        <li>
          На клиенте с помощью JS скрипта реакция на это событие будет
          выполняться фукнция для работы с сервером где создается и отправляется
          гипер HTTP запрос
        </li>
        <li>
          Сервер получает и обрабатывает HTTP запрос отправляя обратно ответные
          данные в формате JSON
        </li>
        <li>
          На клиенте с помощью JS ответ от сервера обрабатывается, считываются
          данные и обновляется интерфейс
        </li>
      </ul>
      <p>
        <b
          >Не смотря на то что в названии технологии находится XML в современном
          интернете его заменил JSON, а название оставили как дань памяти. AJAX
          трактуется как любое общение с сервером без перезагрузки страницы</b
        ><br />
        <b>API interfase fetch</b><br />
        Интерфейс встроенный в браузер доступен на объекте Window, содержащим
        наборы свойств и методов для отправки, получение и обработки ресурсов от
        сервера. Метод fetch() предоставляет современный интерфейс для
        формирования запроса серверу и построен на promise <br />
        <b>fetch(url, options)</b>
      </p>
      <ul>
        <li>
          url - путь к данным на бэкэнде, который необходимо получить, создать
          или изменить, обязательный аргумент
        </li>
        <li>
          options - объект настроек запроса: метод (по умолчанию GET),
          заголовки, тело и т.д. Необязательный аргумент.
        </li>
      </ul>
      <p>
        Создадим запрос к JSONPlaceholder API - публичному REST API для быстрого
        прототипирования, который предоставляет коллекцию ненастоящих
        пользователей /users
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/users') <br />
        .then(response => {<br />
        // Обработка ответа<br />
        })<br />
        .then(data => {<br />
        // Обработка ответа<br />
        })<br />
        .catch(error => {<br />
        // Обработка ответа<br />
        });<br />
      </p>
      <p>
        <b>Обработка ответа</b><br />
        Значение возвращается через promise fetch() - это объект со служебной
        информацией о состоянии ответа сервера. Экземпляр класса response
        содержит разные методы и свойства. В зависимости от типа получаемого
        контента используются различные методы для превращения тела ответа в
        даные
      </p>
      <ul>
        <li><b>json()</b> - парсить данные в JSON формате</li>
        <li>
          <b>text()</b> - парсить данные в простом текстовом формате, например
          .csv(табличные данные)
        </li>
        <li>
          <b>blob()</b> - парсить данные описывающие файл, например изображение,
          аудио или видео
        </li>
      </ul>
      <p>
        В первом методе then() выполняется проверка статуса ответа и
        преобразование данных в правильный формат или явное создание ошибки
        чтобы обработать неудачный HTTP запрос в блоке catch().
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/users') <br />
        .then(response => {<br />
        // Обработка ответа<br />
        if (!response.ok) {<br />
        throw new Error(response.status);<br />
        }<br />
        return response.json();<br />
        })<br />
        .then(data => {<br />
        // Обработка ответа<br />
        })<br />
        .catch(error => {<br />
        // Обработка ответа<br />
        });<br />
      </p>
      <p>
        <b
          >Это необходимо чтобы fetch() правильно среагировал на статус кода 404
          который технически не является ошибкой но для клиента это неуспешный
          результат.
        </b>
      </p>
      <p>
        <b>Вкладка Network</b><br />
        В инструментах разработчика на вкладке Network отображаются все HTTP
        запросы выполняемые на странице. Выбрав фильтр XHR останутся только
        запросы к бэкэнду. После нажатия кнопки в примере через некоторое время
        запрос отобразится в списке. Выбрав его можно посмотреть служебную
        информацию и тело ответа на подвкладках Headers или Preview Response
      </p>
      <img src="./images/network-tab.jpg" alt="" class="img" />
      <p>
        <b>Работа с публичными REST API</b><br />
        Каждый бэкэнд уникален. С другой стороны REST API построен по
        стандартной архитектуре. Это означает что можно понять принцип их
        работы, после чего все что нужно сделать это ознакомиться с
        документацией того бэкэнда, который необходимо использовать. <br />
        Из документации берем url ресурса для запроса информации о коллекции
        ненастоящих пользователей. <br />
        <b>https://jsonplaceholder.typicode.com/users</b> <br />
        Этот путь состоит из следующих частей <br />
        https://jsonplaceholder.typicode.com/users - энд тип, базовый url, точка
        входа в API <br />
        /users - ресурс к которому мы обращаемся <br />
        По щелчку на кнопку fetch users сделаем GET запрос и выведем список
        пользователей по полученным данным.
      </p>
      <button type="button" class="btn">Fetch Users</button>
      <ul class="user-list"></ul>
      <p>
        <b
          >Функция fetchUsers возвращает promise, поэтому к результату ее вызова
          мы добаляем цепочку метода then() и catch()</b
        ><br />
        <b>Первичные ошибки</b><br />
        Разберем распространенные ошибки при работе с асинхронным кодом -
        попытку использовать данные HTTP запроса вне callback метода then().
        Новичок пытается записать результат fetch во внешнюю переменную и
        использовать ее
      </p>
      <p class="bg">
        let globalVariaribles; //undefind <br /><br />

        // Инициализация извлечения данных<br />
        fetch('https://jsonplaceholder.typicode.com/users').then(<br />
        response => response.json().then(users => {<br />
        console.log("Пользователи внутри then callback", users);<br />
        })<br />
        );<br /><br />

        // Запись результата в глобальную переменную <br />
        globalVariaribles = users;<br />
        console.log('globalVariaribles внутри fetch callback',
        globalVariaribles);<br /><br />

        // Здесь нет асинхронных данных<br />
        console.log('globalVariaribles снаружи fetch', globalVariaribles);<br />
      </p>
      <p>
        Вне колюека метода then() данных нет поскольку последний console.log()
        выполнится раньше чем поступит ответ сервера. В настоящее время
        переменная globalVariaribles еще содержит undefind. Выполнившиеся
        значение promise доступно только в колбеке метода then() <br />
        <b>Параметры строки запроса</b><br />
        Параметры запроса позволяют указать бэкэнду дополнительные критерии.
        Например сколько элементов в коллекции мы хотим получить в запросе.
        Возможно необходимо добавить сортировку по свойству объекта, ограничить
        выборку и т.д. Список параметров запроса, их название и возможные
        значения зависят от бэкэнда <br />
        Символ <b>?</b> показывает старт параметров запроса. Каждый параметр это
        пара имя-значение. Символ <b>&</b> используется для указания смыслового
        "и", разделяя параметры в строке запроса.
      </p>
      <p class="bg">
        const url =
        "https://jsonplaceholder.typicode.com/users?_limit=7&_sort=name"
      </p>
      <p>
        Такой GET запрос вернет массив из 7 польователей из 10, отсортированых
        по имени в поле name в алфавитном порядке. Подчеркивание _ в именах
        параметров спецефичные для этого бэкэнда, это не стандарт
      </p>
      <p>
        <b>Class URLSearchParams</b><br />
        Параметров может быть много и неудобно составлять из них одну длинную
        строчку как для читабельности так и для дальнейшего его редактирования.
        При составлении строк создается экземпляр класса URLSearchParams и
        инициализируется бэкэндом. Результатом будет специальный объект
        (етератор) с методами которые в строчном преобразовании возвращают
        результ вызова методу toString() свое строчное отображение
      </p>
      <p class="bg">
        const searchParams = new URLSearchParams({ <br />
        _limit: 5,<br />
        _sort: 'name',<br />
        });<br />
        console.log(searchParams.toString());<br /><br />

        const url =
        `https://jsonplaceholder.typicode.com/users?${searchParams}`;<br />
        console.log(url);<br />
      </p>
      <p>
        В строчном виде свойство объекта станут параметрами и их значениями.
        Параметры будут разделены символом &. В случае интерполяции значение в
        шаблонных строках происходит его преобразование в строку поэтому не
        нужно вызывать метод toString() при составлении url. Не забывайте
        указывать начало строки запроса символом "?".
      </p>
      <p>
        <b>HTTP Заголовки</b><br />
        Класс headers позволяет выполнять разные действия в заголовках HTTP
        запроса и ответа. К этим действиям относится извлечение, настройка,
        добавление и удаление заголовков
      </p>
      <p class="bg">
        const headers = new Headers({ <br />
        'content-type': 'application/json',<br />
        'custom-header': 'custom value',<br />
        });<br />
        headers.append('content-type', 'text/bash');<br />
        headers.append('custom-header', 'custom, value');<br /><br />

        console.log(headers.has('content-type')); //true<br />
        console.log(headers.get('content-type')); //application/json,
        text/bash<br />
        console.log(headers.set('content-type', "application/json")); //map
        obj<br />
        console.log(headers.delete('custom-header'));<br />
      </p>
      <p>
        На практике для составления заголовков запроса как правило используется
        просто литерал объекта со свойствами. В таком случае методов не будет
        что чаще всего не требуется.
      </p>
      <p class="bg">
        const headers = { <br />
        'content-type': 'application/json', <br />
        'custom-header': 'custom value', <br />
        }
      </p>
      <p>
        Запрос с использованием заголовков будет смотреться следующим образом
      </p>
      <p class="bg">
        fetch('https://jsonplaceholder.typicode.com/users', { <br />
        headers: {<br />
        Accept: 'application/json',<br />
        },<br />
        }).then(response => {<br />
        // Отклик<br />
        });<br />
      </p>
      <p>
        Cовременные браузеры добавляют много заголовков по умолчанию в
        зависимости от операции и тела запроса поэтому нет необходимости явно
        указывать стандартные заголовки.
      </p>
      <h3 class="title">Кросс доменные запросы</h3>
      <p>
        По умолчанию HTTP запрос можно производить только в рамках текущего
        сайта. При попытке запроса на другой домен, порт или протокол, т.е
        выполнить кросс доменный запрос, выдает ошибку. Это сделано из
        соображений безопасности и права доступа настраиваются на бэкэнде. Если
        бэкэнд не поддерживает кросс доменные запросы фронтэнд разработчик
        ничего не сможет с этим поделать в своем коде. <br />
        Эта политика браузера называется CORS и расшифровывается как cross
        original resurse sharing, где origin это и есть домен, порт и протокол.
        Дословный перевод звучит как совместное использование ресурсов между
        разными источниками. <br />
        На каждом запросе браузер сам добавляет заголовок HTTP origin, где
        указывает адрес веб страницы, которая хочет сделать HTTP запрос с веб
        страницы https://mysite.com/about на https://myapi.com/users то
        заголовки будут следущими
      </p>
      <p class="bg">
        GET /users <br />
        Host: myapi.com <br />
        Origin: https://mysite.com
      </p>
      <p>
        Сервер проверяет заголовок origin и если он поддерживает кросс доменные
        запросы добавляет в ответ спец HTTP заголовок access control allow
        origin
      </p>
      <p class="bg">
        <br />
        // Private API <br />
        Access-Control-Allow-Origin: https://mysite.com <br />
        // Pablic API <br />
        Access-Control-Allow-Origin: * <br />
      </p>
      <p>
        Значением этого заголовка будет разрешен источник origin, в нашем случае
        это должен быть один сайт mysite, если бэкэнд частный или *, если бэкэнд
        публичный - позволяет делать запросы кому угодно.
      </p>
      <img src="./images/cors.jpg" alt="" class="img" />
      <p>
        Т.е браузер это определенный посредник между JS кодом и бэкэндом. Он
        добавляет каждому запросу заголовок origin с правильный значением и
        проверяет наличие заголовка Access-Control-Allow-Origin в ответе. Если
        заголовок есть и его значение подходит выполняется исходный запрос и
        скрипт js получит его результат, в противном случае будет ошибка CORS.
      </p>
      <p>
        <b>Пагинация</b><br />
        База данных может хранить коллекции, содержащие сотни миллионов записей,
        поэтому возвращать всю коллекцию на каждый GET запрос слишком
        ресурсозатратно. Размер тела ответа будет слишком велик и время запроса
        затянется на десятки секунд. Чем больше данных в ответе от бэкэнда тем
        дольше она передается сетью. <br />
        К тому же необходимо думать о пользователях, вряд ли им нужны все
        1000000 запросов записи сразу. Обработка столь большого кол-ва данных в
        ответе и отображении интерфейса требует огромных ресурсов устройства на
        котором просматривается веб страница. По статистике пользователи находят
        интересующию их информацию на первых страницах. <br />
        Допустим наш бэкэнд myapi.com хранит очень большую коллекцию постов
        resurs/posts, которые изобразим 12ю элементами на иллюстрации.
      </p>
      <img src="./images/no-pagination.jpg" alt="" class="img" />
      <p>
        На каждый get запрос бэкэнда прийдется вернуть всю коллекцию и мы
        столкнемся с проблемами описаными ранее. Для их решения существует
        пагинация за которым на первый и каждый последующий get запрос
        возвращается не вся коллекция а определенная ее часть. Пагинация
        реализуется на бэкэнде и используется на фронтэнде с помощью специальных
        параметров запроса. <br />
        <b>Колличество элементов ответа</b><br />
        Первый параметр определяет кол-во элементов в ответе от бэкэнда. Пусть в
        нашем случае он называется per_page. Стандарт именования пагинации
        отсутствует, поэтому их имена зависят от бэкэнд разработчика.
      </p>
      <img src="./images/per-page-param.jpg" alt="" class="img" />
      <p>
        В таком запросе бэкэнда вернет не всю коллекцию из 12 элементов, а
        только первые ее 4. Если передать отрицательное значение или значение
        большее кол-ва элементов в коллекции то бэкэнд может ответить по разному
        - проигнорировать ил вернуть ошибку 400 (BAD REQUEST) в зависимости от
        его реализации. <br />
        Публичный JSON Placeholder API так же поддерживает пагинацию. <br />
        https://github.com/typicode/json-server#paginate <br />
        Кол-во ответных элементов контролируется параметром _limit. Всего
        коллекция/пост насчитывает 100 элеметов. Изменим значение параметра
        _limit в примере и исследует ответ бэкэнда в интерфейсе.
      </p>
      <div>
        <button type="button" class="btn1">Fetch posts</button>
        <ul class="posts"></ul>
      </div>
      <p class="bg">
        const fetchPostsBtn = document.querySelector('.btn1'); <br />
        const postLimit = document.querySelector('.posts');<br /><br />

        fetchPostsBtn.addEventListener('click', async () => {<br />
        try {<br />
        const posts = await fetchPosts();<br />
        renderPosts(posts);<br />
        } catch (error) {<br />
        console.log(error);<br />
        }<br />
        });<br /><br />

        async function fetchPosts() {<br />
        const response = await axios.get(<br />
        'https://jsonplaceholder.typicode.com/posts?_limit=10'<br />
        );<br />
        return response.data;<br />
        }<br /><br />

        function renderPosts(posts) {<br />
        const markUp = posts<br />
        .map(({ id, title, body, userId }) => {<br />
        return ` <br />
        &lt;li&gt;<br />
        &lt;h2 class=&quot;post-title&quot;&gt;${title.slice(0,
        30)}&lt;/h2&gt;<br />
        &lt;p&gt;&lt;b&gt;Post ID&lt;/b&gt;: ${id}&lt;/p&gt;<br />
        &lt;p&gt;&lt;b&gt;Author ID&lt;/b&gt;: ${userId}&lt;/p&gt;<br />
        &lt;p&gt;${body}&lt;/p&gt;<br />
        &lt;/li&gt;<br />
        `; }) <br />.join(''); <br />postLimit.innerHTML = markUp; } <br />
        &lt;script
        src=&quot;https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        <b>Номер группы элементов</b><br />
        Указав желаемое кол-во ответных элементов мы всегда получим одинаковый
        результат - первые per-page элементов коллекции. Так называемую первую
        группу или страницу. Второй параметр пагинации контролирует смещение
        внутри коллекции например группы элементов которые мы хотим получить.
        Если бэкэнд реализует пагинацию то значение этого параметра по умолчанию
        еденица - первая группа или страница элементов
      </p>
      <img src="./images/page-param.jpg" alt="" class="img" />
      <p>
        <b>Параметры страниц</b><br />
        Изменяя значения параметров page мы уточняем бэкэнду которую следующую
        группу мы хотим получить пока в коллекции не закончатся элементы. Если
        указать отрицательное значение или более групп в коллекции - ответ
        бэкэнда будет зависеть от его реализации.
      </p>
      <div>
        <button type="button" class="btn btn2">Fetch posts</button>
        <ul class="posts2"></ul>
      </div>
      <p class="bg">
        const fetchPostsBtn2 = document.querySelector('.btn2'); <br />
        const postLimit2 = document.querySelector('.posts2');<br /><br />

        fetchPostsBtn2.addEventListener('click', async () => {<br />
        try {<br />
        const posts = await fetchPosts2();<br />
        renderPosts2(posts);<br />
        } catch (error) {<br />
        console.log(error);<br />
        }<br />
        });<br /><br />

        async function fetchPosts2() {<br />
        const params = new URLSearchParams({<br />
        _limit: 5,<br />
        _page: 3,<br />
        });<br />
        const response = await axios.get(<br />
        `https://jsonplaceholder.typicode.com/posts?${params}`<br />
        );<br />
        return response.data;<br />
        }<br /><br />

        function renderPosts2(posts) {<br />
        const markUp = posts<br />
        .map(({ id, title, body, userId }) => {<br />
        return `&lt;li&gt;<br />
        &lt;h2 class=&quot;post-title&quot;&gt;${title.slice(0,
        30)}&lt;/h2&gt;<br />
        &lt;p&gt;&lt;b&gt;Post ID&lt;/b&gt;: ${id}&lt;/p&gt;<br />
        &lt;p&gt;&lt;b&gt;Author ID&lt;/b&gt;: ${userId}&lt;/p&gt;<br />
        &lt;p&gt;${body}&lt;/p&gt;<br />
        &lt;/li&gt;`;<br />
        })
        <br />
        .join('');<br />
        postLimit2.innerHTML = markUp;<br />
        }<br />
      </p>
      <p>
        Чтобы знать когда кончатся элементы в коллекции и вывести это сообщение
        пользователю бэкэнд в каждом ответе возвразает не только массив
        элементов но и мета данные о доступном кол-ве групп (страниц), зависищем
        от значения параметра per_page или просто общее кол-во в коллекции. В
        таком случае вычесление кол-ва групп ложится на плечи фронтэнд
        разработчика, JSONPlaceholder Api не реализует этот фукнционал. <br />
        <b> Прием "загрузить еще"</b><br />
        Чтобы динамически изменить номер группы по каждому след запросу
        достаточно объявить еще одну глобальную переменную, назовем ее page и
        установим начальное значение 1 - первая группа элементов. После каждого
        успешного запроса в колбеке метода then() будем увеличавать значение
        page на 1. Составляя параметры запроса, используем ее значение.
      </p>
      <div>
        <ul class="posts3"></ul>
        <button type="button" class="btn btn3">Fetch posts</button>
      </div>
      <p class="bg">
        const fetchPostsBtn3 = document.querySelector('.btn3'); <br />
        const postLimit3 = document.querySelector('.posts3');<br />
        let page = 1;<br />
        let perPage = 10;<br />

        fetchPostsBtn3.addEventListener('click', async () => {<br />
        try {<br />
        const posts = await fetchPosts3();<br />
        renderPosts3(posts);<br />
        page += 1;<br />
        if (page > 1) {<br />
        fetchPostsBtn3.textContent = 'Fetch More Posts';<br />
        }<br />
        } catch (error) {<br />
        console.log(error);<br />
        }<br />
        });<br /><br />

        async function fetchPosts3() {<br />
        const params = new URLSearchParams({<br />
        _limit: perPage,<br />
        _page: page,<br />
        });<br />
        const response = await axios.get(<br />
        `https://jsonplaceholder.typicode.com/posts?${params}`<br />
        );<br />
        return response.data;<br />
        }<br />
      </p>
      <p>
        После загрузки первой группы элементов текст кнопки изменится <br />
        Мы добавили проверку конца коллекции на фронтэнде потому что
        JSONPlaceholder API не реализует этот функционал в бэкэнде. В нашем
        случае достаточно поделить общее кол-во элементов в коллекции на кол-во
        элементов в одной группе. Когда бэкэнд возвращает не кол-во доступных
        страниц а общее кол-во элементов доступных в коллекции.
      </p>
    </section>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script src="./js/moduleTen.js"></script>
  </body>
</html>

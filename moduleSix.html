<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 6</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Объектная модель документа</h3>
      <p>
        При работе с браузерам доступный функционал состоит из нескольких
        модулей, поскольку JS не имеет интрументов для рауботы с браузером.
      </p>
      <ul>
        <li><b>JS включает в себя</b></li>
        <li>1. ECMAScript</li>
        <li>2. DOM</li>
        <li>3. BOM</li>
      </ul>
      <p>
        Объектная модель документа (DOM - document object module) - независимый
        от языка интерфейс для работы с HTML. Содержит набор свойств и методов,
        позволяющий искать, создавать и удалять элементы, реагировать на
        действия пользователя и многое другое. Т.е соединять страницу с языком
        программирования. <br />
        DOM - это отображение HTML документа, древовидная структура, в которой
        каждый узел это JS объект со свойствами и методами, составляющие часть
        HTML документа. Каждый элемент в документе, весь документ в целом,
        заголовок, ссылка - это часть DOM, поэтому все они могут быть изменены
        из JS кода. <br />
        Объектная модель браузера (BOM - browser object module) - независимый от
        языка интерфейс для работы с вкладкой браузера. Содержит набор свйоств и
        методов, позволяющих получить доступ непосредственно к текущей вкладке и
        ряду функций браузера. Содержит объект работы истории навигации,
        метоположения и многое другое. <br />
        <b>HTML документ и DOM</b><br />
        Согласно DOM модели каждый тег образует отдельный элемент - узел, каждый
        фрагмент текста - тектовый элемент. HTML документ это иерархическое
        древо, которое у каждого элемента (кроме корневого) есть только один
        родительский элемент, т.е элемент, внутри которого он располагается. Это
        дерево появляется за счет вложенной структуры тегов и текстовых частей.
      </p>
      <img src="./images/DOMtree.jpg" alt="" class="img" />
      <p>
        Чтобы отобразить HTML документ браузер сначала превращает его в
        понимаемый формат DOM. Движение браузера имеет спец фрагмент кода
        HTML-Parser, который используется для преобразования HTML в DOM. <br />
        В HTML вложенность определяет отношение родитель-ребенок между
        элементами. В DOM объекты соеденены в древовидных структурах данных
        фиксируя эти взаимодействия. <br />
        Браузер строит DOM постепенно, как только поступают первые фрагменты
        кода, он начинает парсить HTML, добавляя узлы в древовидную структуру.
      </p>
      <img src="./images/parser1.jpg" alt="" class="img" />
      <p>
        После того, как DOM древо построено в нем можно найти элемент с помощью
        JS и выполнить с ним определенные действия, поскольку каждый элемент
        имеет интерфейс с множеством свойств и методов.
      </p>
      <img src="./images/parser2.jpg" alt="" class="img" />
      <p>
        <b>DOM дерево</b><br />
        Визуализируем дерево HTML документа используя сервис генератора DOM
        дерева
      </p>
      <p class="bg">
        &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Document
        title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Page
        title&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link
        1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link
        2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;
      </p>
      <img src="./images/live-dom-tree.jpg" alt="" class="img" />
      <p>
        В этом дереве выделены два типа узлов <br />
        Узлы - элементы (element node) образуются тегами, обычным образом одни
        элементы вложены в лругие. Структура дерева образована только за счет
        них <br />
        Текстовые узлы (text node) образуются текстом внутри элемента. Текстовый
        узел содержит только строчку текста и не может иметь дочерних элементов,
        т.е он всегда на самом низком уровне иерархии. Пробелы и перенос строк
        это тоже тектовый узел. <br />
        Из этого правила есть исключения - пробелы к head игнорируются, а любое
        содержимое после body не создает элемент, браузер переносит его в конец
        body
      </p>
      <h3 class="title">Навигация по DOM</h3>
      <p>
        DOM представляет собой широкий спектр для работы с элементом и его
        содержимым, но для этого нужно сначала получить ссылку на него. Доступ к
        DOM начинается с объекта document, из него можно добраться до любых
        элементов <br />
        document - это часть глобального объекта window, который доступен в
        скрипте, когда он выполняется в браузере. Так же как alert, сonsole.log,
        prompt и многое другое. <br />
        Элемент DOM дерева имеет иерархическое отношение друг к другу. Для
        описания отношения используется термин предок(ancestor),
        отпрыск(descedant), отец(parent), ребенок(child) и сосед(sibling).
      </p>
      <p>
        Самый высокий элемент называется корневым - root node, каждый элемент
        кроме корневого имеет только одного родителя
      </p>
      <ul>
        <li>У элемента может быть сколько угодно детей</li>
        <li>Соседи - это элементы с общим родительским элементом</li>
        <li>
          Дочерние элементы (дети), которые находятся непосредственно внутри
          текущего (первая вложенность)
        </li>
        <li>
          Потомки - все элементы, которые находятся в текущем месте с их детьми,
          детьми их детей и т.д
        </li>
      </ul>
      <img src="./images/dom-traversal.jpg" alt="" class="img" />
      <p>Для навигации по этой иерархии элементы имеют след свйоство</p>
      <ul>
        <li>elem.parentNode - выбирает родительский элемент</li>
        <li>
          elem.childNode - псевдо массив, сохраняет все дочерние элементы,
          включая текстовые
        </li>
        <li>
          elem.children - псевдо массив сохраняющий только узлы дочерних
          элементов, т.е только те, что отвечают тегам
        </li>
        <li>
          elem.firstChild - выберет первый дочерний элемент в середине elem,
          включительно тектовые узлы
        </li>
        <li>
          elem.firstElementChild - выберет первый дочерний узел-элемент в
          середине elem
        </li>
        <li>
          elem.lastChild - выберет последний дочерний элемент в середине elem,
          включительно тектовые узлы
        </li>
        <li>
          elem.lastElementChild - выберет последний дочерний узел-элемент в
          середине elem
        </li>
        <li>
          elem.previousSibling - выберет элемент слева от elem (его предыдущего
          соседа)
        </li>
        <li>
          elem.previousElementSibling - выберет узел-элемент слева от elem (его
          предыдущего соседа)
        </li>
        <li>
          elem.nextSibling - выберет элемент справа от elem (его след соседа)
        </li>
        <li>
          elem.nextElementSibling - выберет узел-элемент справа от elem (его
          след соседа)
        </li>
      </ul>
      <p>
        DOM коллекции такие как child nodes и children - псевдо массивы (node
        list), у них нет большинства методов массива
      </p>
      <div class="dom">
        <ul id="menu" class="menu">
          <li class="menu__item">Home</li>
          <li class="menu__item">About</li>
          <li class="menu__item">Gallery</li>
          <li>Blog</li>
        </ul>
      </div>
      <h3 class="title">Поиск элементов</h3>
      <p>
        Итак мы уже знаем что такое DOM element - это объект со свойствами и
        методами. Пришло время быстро находить элемент по произвольным css
        селекторам. Группа методов elem.querySelector* - это современны стандарт
        посика элемнтов. Они позволяют найти элемент или группу элементов css
        селекторов любой сложности <br />
        <b>element.querySelector("selector")</b><br />
        Используется, если необходимо найти только один, чаще всего уникальный
        элемент. Он возвращает первый найденый внутри элемент - element, который
        соответствует css селектору selector. Если ничего не найдено вернет
        null. <br />
        <b>element.querySelectorAll("selector")</b><br />
        Используется если необходимо найти коллекцию элементов, т.е получить
        массив ссылок на элементы с одним и тем же селектором, например все
        элементы классом menu__item. возвращает псевдомассив всех элементов
        внутри element, соответствующих css селекторов selector. Если ничего не
        найдено вернет пустой массив.
      </p>
      <h3 class="title">Свойства и атрибуты</h3>
      <p>
        В период постройки DOM некоторые стандартные HTML атрибуты становятся
        свойствами элемента.
      </p>
      <ul>
        <li>
          <b>value</b> - содержит текущее текстовое содержимое элементов формы
        </li>
        <li><b>checked</b> - сохраняет состояние чекбокса или радиокнопки</li>
        <li>
          <b>name</b> - сохраняет значение, указанное в HTML атрибуте name
        </li>
        <li><b>src</b> - путь к сохранению тега img</li>
      </ul>
      <p class="bg">
        <img
          src="https://picsum.photos/id/9/320/240"
          alt="laptop"
          class="image"
          width="300"
        />
      </p>
      <h3 class="title">Свойство textContent</h3>
      <p>
        elem.textContent возвращает текстовое содержимое внутри элемента.
        Доступен для чтения и записи. Не важно что textContent данные всегда
        будут записаны в виде текста
      </p>
      <article class="article">
        <h4 class="article__title">Lorem, ipsum dolor.</h4>
        <p class="article__text">
          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Neque
          incidunt cupiditate accusamus expedita veniam nemo ut qui fuga cumque
          id.
        </p>
      </article>
      <h3 class="title">Свойство classList</h3>
      <p>
        Свойство classList хранит объект с методами для работы с классами
        элементов
      </p>
      <ul>
        <li>
          elem.classList.contains(class) return true or false. В наличии от
          класса в элементе
        </li>
        <li>
          elem.classList.add(class) - добавляет класс к списку классов элементов
        </li>
        <li>
          elem.classList.remove(class) - удаляет класс из списка классов
          элементов
        </li>
        <li>
          elem.classList.toggle(class) - если отсутствует класс, то добавляет
          его, а если присутствует то удаляет
        </li>
        <li>
          elem.classList.replace(oldClass, newClass) - заменяет существующий
          класс(oldClass) на указаный (newClass)
        </li>
      </ul>
      <p class="bg">
        <a href="#" class="link is-active">Random link</a>
      </p>
      <h3 class="title">Свойство style</h3>
      <p>
        Использется для чтения и изменения онлайн стилей. Возвразает объект
        CSSStyleDeclaration, содержащий список всех свойств определенных только
        в встроенных стилях элемента, а не во всех css. Во время записи свойство
        записывается camelCase, т.е background-color превращается в
        elem.style.backgroundColor
      </p>
      <p class="bg">
        const button = document.querySelector(".btn"); <br />
        button.style.backgroundColor = "blue";<br />
        button.style.fontSize = "24px";<br />
        button.style.textAlign = "center";<br />
      </p>
      <h3 class="title">Атрибуты</h3>
      <p>
        DOM элементам соответствуют HTML теги, которые содержат текстовые
        атрибуты. Доступ к атрибутам устанавливается с помощью стандартных
        методов. Эти методы работают со свойствами, которые находятся в HTML
      </p>
      <ul>
        <li>
          elem.hasAttribute(name) - проверяет наличие атрибута, возвращает true
          or false
        </li>
        <li>
          elem.getAttribute(name) - получает значение атрибута и возвращает его
        </li>
        <li>elem.setAttribute(name, value) - устанавливает атрибут</li>
        <li>elem.removeAttribute(name) - удаляет атрибут</li>
        <li>
          elem.attributes - свойство возвращающее в объект все атрибуты элемента
        </li>
      </ul>
      <p class="bg">
        <img
          src="https://picsum.photos/id/9/320/240"
          alt="laptop"
          class="img1"
          width="300"
        />
        const img1 = document.querySelector('.img1'); <br />
        console.log(img1.attributes);// {0:class,1:src,alt,length:1 }<br />
        console.log(img1.hasAttribute("src"));// true<br />
        console.log(img1.getAttribute("alt"));// "laptop"<br />
        img1.setAttribute("alt", "tel")<br />
        console.log(img1.getAttribute('alt'));// "tel"<br />
      </p>
      <h3 class="title">Data атрибуты</h3>
      <p>
        Позволяет добавить к тегу произвольный атрибут и получить его значение в
        JS. Это возможность используется для упрощения написания кода, например
        для привязки данных и индификатора к уникальному индификатору, для
        указания типа действия кнопки и т.д
      </p>
      <p class="bg">
        <button type="button" data-active="save">Save</button>
        <button type="button" data-active="close">Close</button>
      </p>
      <p>
        Для получения значения data атрибута используется свойство dataset,
        после которого стоит имя атрибута. Т.е data - откидывается, а другая
        часть имени записывается как имя свойства объекта
      </p>
      <p class="bg">
        const saveBtn = document.querySelector('button[data-action="save"]');
        <br />
        console.log(seveBtn.dataset.action);//save<br /><br />

        const closeBtn =
        document.querySelector('button[data-action="close"]');<br />
        console.log(closeBtn.dataset.action);//close<br />
      </p>
      <div class="editor">
        Lorem ipsum, dolor sit amet consectetur adipisicing elit. Magni nam iste
        iure totam quidem rem nesciunt non illo! Obcaecati quaerat aut mollitia
        a assumenda quisquam voluptatibus numquam accusantium debitis
        perferendis!
        <div class="actions">
          <button class="btn" type="button" data-action="save">
            Save Text
          </button>
          <button class="btn" type="button" data-action="close">
            Close editor
          </button>
        </div>
      </div>
      <h3 class="title">Создание и удаление элементов</h3>
      <p>
        DOM api позволяет нне только выбирать и изменять существующие, но и
        удалять а так же создавать новые элементы, после чего добавлять их в
        документ
      </p>
      <p class="bg">document.createElement(name_tag)</p>
      <p>
        Создает элемент с именем tag_name и возвращает ссылку на него как
        результат своего исполнения. Tag_name это строка, указывающая тип
        создаваемого элемента. Элемент создается в памяти, у DOM его еще нет.
      </p>
      <p class="bg">
        const title = document.createElement('h1'); <br />
        heading.textContent = 'This is title';<br /><br />

        const image2 = document.createElement('img');<br />
        image2.src = 'https://placeimg.com/640/480/nature';<br />
        image2.alt = 'nature';
      </p>
      <h3>Добавление</h3>
      <p>
        Чтобы созданный элемент отображался на странице его необходимо добавить
        к существующему элементу DOM. Предположим что добавляем к определенному
        элементу element, для этого существуют методы
      </p>
      <ul>
        <li>
          <b>element.append(elem1, elem2, ...)</b> - добавляет один или
          несколько элементов после всех детей элемета element
        </li>
        <li>
          <b>element.prepend(elem1, elem2, ...)</b> - добавляет элемент перед
          всеми детьми элемента element
        </li>
        <li>
          <b>element.after(elem1, elem2, ...)</b> - добавляет один или несколько
          элементов после элемента element
        </li>
        <li>
          <b>element.before(elem1, elem2, ...)</b> - добавляет один или
          несколько элементов перед элементом element
        </li>
      </ul>
      <p>
        Во всех этих el это элементы или строки в любом сочетании и колличестве.
        Строки добавляются как текстовые узлы.
      </p>
      <div class="user">
        <h1>User names</h1>
        <ul class="usernames">
          <li class="username__item">Petya</li>
        </ul>
      </div>
      <p class="bg">
        const list = document.querySelector('.usernames'); <br />
        const listItem = document.createElement('li');<br /><br />

        listItem.textContent = 'Vasya';<br />
        list.append(listItem);<br /><br />

        const firstItem = document.createElement('li');<br />
        firstItem.textContent = 'Polya';<br />
        list.prepend(firstItem);<br /><br />

        const user = document.querySelector('.user');<br /><br />

        const allList = document.querySelector('.username__item');<br />
        allList.style.border = '1px dashed red';<br />
      </p>
      <h3 class="title">Удаление</h3>
      <p class="bg">element.remove()</p>
      <p>
        Для того, чтобы удалить элемент используем метод remove(), он вызывается
        на элемент elem, который нужно удалить
      </p>
      <article class="article1">
        <h2 class="title1">Article title</h2>
        <p class="text1">Lorem ipsum dolor sit amet.</p>
        <a href="#" class="link">Read more</a>
      </article>
      <p class="bg">
        const text1 = document.querySelector('.text1'); <br />
        text1.remove();
      </p>
      <h3 class="title">Оптимизация работы с DOM</h3>
      <p>
        Современные браузеры пытаются оптимизировать процесс воспроизведения
        страницы без вмешательства разработчика, однако изменение DOM дерева это
        дорогостоющая операция, поэтому необходимо минимизировать количество
        обращений к DOM. <br />
        <b>repaint</b> происходит когда изменения коснулись стилей, влияющих на
        внешний вид элементов, но не на геометрию, например opacity,
        background-color, visability, outline. Браузер повторно создает элемент
        с учетом нового стиля. Так же проверяется видимость других элементов,
        один или более могут оказаться скрытыми под изменившем внешний элемент.
        <br />
        <b>reflow</b> происходит когда изменения влияют на содержимое, структуру
        документа, положение элемента. Происходит перерасчет позиционирования и
        размеров что приводит к повторному созданию части или всего документа.
        Изменение размера одного родителького контейнера влияет на всех его
        детей и предков. Оказывает значительно большее влияние на
        производительность чем repaint. Все вышеперечисленные операции блокирует
        браузер. Страница не может выполнять никаких других операций во время
        когда происходит reflow или repaint
      </p>
      <ul>
        Причины
        <li>
          Манипуляция с DOM(сложение, удаление, изменение, перестановка
          элементов)
        </li>
        <li>Изменение содержимого, в частности текста в полях форм</li>
        <li>Расчет или изменение css свойств</li>
        <li>Добавление или удаление таблиц стилей</li>
        <li>Манипуляция с атрибутами класса</li>
        <li>Манипуляция с окном браузера (изменение размера, прокрутка)</li>
        <li>Активация псевдоклассов, например ::hover</li>
      </ul>
      <h3 class="title">Свойство innerHTML</h3>
      <p>
        Еще один способ создать DOM элемент и поместить в дерево. Это позволит
        использовать строки с тегами и позволит браузеру проделать всю тяжелую
        работу. У такого подхода есть свои плюсы и минусы. <br />
        <b>Чтение</b> <br />
        Свойство innerHTML сохраняет содержимое HTML включая теги в виде строк.
        Возвращаемое значение это всегда валидный HTML код.
      </p>
      <article class="article2">
        <h2 class="title2">Article title</h2>
        <p class="text2">
          Lorem ipsum dolor sit amet consectetur
          <strong>adipisicing</strong> elit. Aliquid inventore optio dignissimos
          iusto dolor minus eum illo ratione nihil aliquam.
        </p>
        <a href="#" class="link2">Read more</a>
      </article>
      <p class="bg">
        const article2 = document.querySelector('.article2'); <br />
        console.log(article2.innerHTML);<br />
        const title2 = document.querySelector('.article2', '.title2');<br />
        console.log(title2.innerHTML);<br />
        const text2 = document.querySelector('.article2', '.text2');<br />
        console.log(text2.innerHTML);<br />
        const link2 = document.querySelector('.article2', '.link2');<br />
        console.log(link2.innerHTML);<br />
      </p>
      <p>
        <b>Изменение</b><br />
        Свойство innerHTML доступно и для чтения и для записи. Если записать в
        нее строку с HTML тегами то браузер во время парсинга строчки превратят
        их в валидные элементы и DOm добавит их в DOM дерево
      </p>
      <p class="bg">title2.innerHTML = 'This is <b>new</b> title';</p>
      <p>
        При таком подходе, в отличии от document.createElement() мы не получаем
        ссылку на зозданый DOM элемент. Это первый шаг на пути к шаблонизации
        создания большого колличества однотипной разметки и разными данными по
        заранее определенному шаблону, например как списки товаров интернет
        магазина <br />
        Однотипная (шаблонная) разметка создается из массива данных. Прием
        заключается в переборе этого масиива и составления одной строки с HTML
        тегами, которую затем записываем в innerHTML.
      </p>
      <div>
        <h2>Languages</h2>
        <ul class="list3"></ul>
      </div>
      <p class="bg">
        const languages = ['HTML', 'CSS', 'React', 'Node', 'JS', 'Vue']; <br />
        const list3 = document.querySelector('.list3');<br />
        const markUp = languages<br />
        .map(language => ` &lt;li
        class=&quot;list__item3&quot;&gt;${language}&lt;/li&gt; `)<br />
        .join('');<br />
        list3.innerHTML = markUp;<br />
      </p>
      <p>
        <b>Добавление</b><br />
        Изменение elem в innerHTML полностью удалит и повторно создаст все
        потомки элемента elem. Если элемент по началу не был пуст, то возникнут
        доп затраты на сереализацию существующей разметки (перезапись)
      </p>
      <p class="bg">
        const newText = `&lt; p class=&quot;new__text&quot;&gt;Lorem ipsum dolor
        sit amet consectetur adipisicing elit. Aspernatur est beatae facilis rem
        id commodi sequi ad! Obcaecati, nulla iusto?&lt;/&gt;&lt; a
        class=&quot;new__link&quot; href=&quot;#&quot;&gt;Read moreeeee&lt;
        /a&gt;`; <br />
        article2.innerHTML += newText;
      </p>
      <p>
        <b>Метод insertAdjacentHTML()</b><br />
        Это современный метод для добавления строки с HTML тегами перед, после
        или в середину элементов. Решает проблему innerHTML с повторной
        сериализацией содержимого элемента во время добавления разметки к уже
        существующей
      </p>
      <p class="bg">elem.insertAdjacentHTML(position, string);</p>
      <p>
        Аргумент position это строка, позиция нашего элемента, принимает одно из
        4 значений
      </p>
      <ul>
        <li>beforebegin - перед elem</li>
        <li>afterbegin - в середине elem</li>
        <li>beforeend - в середине elem после всех детей</li>
        <li>afterend - после elem</li>
      </ul>
      <div>
        <ul class="list4">
          <li class="list__item4">HTML</li>
          <li class="list__item4">CSS</li>
          <li class="list__item4">JS</li>
        </ul>
      </div>
      <p class="bg">
        const list4 = document.querySelector('.list4'); <br />
        const newLanguages = ['React', 'Node', 'Vue'];<br />
        const markUp2 = newLanguages<br />
        .map(language =&gt; `&lt;li
        class=&quot;list__item4&quot;&gt;${language}&lt;/li&gt;`)<br />
        .join('');<br />
        list4.insertAdjacentHTML('beforeend', markUp2);<br />
        list4.insertAdjacentHTML('beforebegin',
        '&lt;h2&gt;Languages&lt;/h2&gt;');
      </p>
      <h3 class="title">Подключение скриптов</h3>
      <p>
        Загрузка и исполнение скрипта обозначена в теге script без каких-либо
        атрибутов, блокирует обработку HTML документа и построение DOM. Это
        проблема.
      </p>
      <p class="bg">
        &lt;script src=&quot;path-to-script.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        Когда анализатор втречает такой тег обработка HTML документа
        приостанавливается и начинается загрузка файла скрипта, которая
        определена в атрибуте src. После загрузки скрипта выполняется, и только
        потом восстанавливается обработка HTML. Это называется блокирующий
        скрипт <br />
        <b>Атрибуты defer и async</b> <br />
        Были введены чтобы разработчикам была возможность контролировать способ
        загрузки скриптов и когда именно их выполнять <br />
        <b>Атрибут defer</b>
      </p>
      <p class="bg">
        &lt;script defer src=&quot;path-to-script.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        Указывает браузеру загрузку файла скрипта в фоновом режиме параллельно с
        обработкой HTML документа и построению DOM. Скрипт будет выполнятся
        только после того как HTML документ был обработан, а DOM построен. Такие
        скрипты не блокируют построение DOM дерева, гарантировано выполняются в
        таком порядке, в каком указано в HTML документе
      </p>
      <img src="./images/defer.jpg" alt="" class="img" />
      <p><b>Атрибут async</b><br /></p>
      <p class="bg">
        &lt;script async src=&quot;path-to-script.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        Загрузка скрипта с атрибутом async не блокирует построение DOM, но он
        выполняется сразу после загрузки. Это означает что такой скрипт может
        заблокировать построение DOM и выполнятся в произвольном порядке.
      </p>
      <img src="./images/async.jpg" alt="" class="img" />
      <h3 class="title">События</h3>
      <p>
        События - это сигнал браузера о том, что на странице браузера что то
        произошло. События используются для реакции на действия пользователя и
        выполнение кода связаного с определенными событиями. Существует
        множество видов событий: мышь клавиатуры, элементы форм, загрузки
        изображений, буфер обмена, изменение стадий css анимаций или перехода,
        изменение размеров окна и многое другое. <br />
        Одно действие может вызывать несколько событий. К примеру клик вызывает
        сначала mousedown а затем mouseup и click. В тех случаях когда одно
        действие генерирует несколько событий их порядок фиксирован
        mousedown->mouseup->click. Для того чтобы элемент реагировал на действие
        пользователя, ему необходимо добавить слушателя (обработчика событий).
        Т.е функция, которая будет вызвана, как только событие произошло. <br />
        <b>Метод addEventListener()</b><br />
        Добавляет слушателя событий на элемент
      </p>
      <p class="bg">element.addEventListener(event, handler, options)</p>
      <ul>
        <li>event - имя события, строка, например click</li>
        <li>
          handler - callback функция, которая будет вызвана при наступлении
          события
        </li>
        <li>
          options - необязательный объект параметров с расширеными настройками
        </li>
      </ul>
      <p class="bg">
        const button = document.querySelector('.my__button'); <br />
        button.addEventListener('click', () => console.log('Hello world'));
      </p>
      <p>
        Для callback желательно использовать отдельную функцию и передавать на
        нее ссылку. Именуемая функция увеличивает читабельность кода
      </p>
      <p class="bg">
        const handelClick = () => console.log("Hello World"); <br />
        button.addEventListener("click", handelClick);
      </p>
      <p>
        На одном элементе может находится любое колличество обработчиков
        событий, даже событий одного типа. Callbacks будут вызываться в порядке
        регистрации в коде
      </p>
      <div>
        <button class="btn" id="single">Single click</button>
        <button class="btn" id="multiple">Multiple click</button>
      </div>
      <p class="bg">
        const singleBtn = document.querySelector('#single'); <br />
        const handleClick = () => console.log('Single click');<br />
        singleBtn.addEventListener('click', handleClick);<br /><br />

        const multipleBtn = document.querySelector('#multiple');<br />
        const firstCallback = () => console.log('First callback');<br />
        const secondCallback = () => console.log('Second callback');<br />
        const thirdCallback = () => console.log('Third callback');<br />
        multipleBtn.addEventListener('click', firstCallback);<br />
        multipleBtn.addEventListener('click', secondCallback);<br />
        multipleBtn.addEventListener('click', thirdCallback);<br />
      </p>
      <p>
        <b>Метод removeEventListener()</b><br />
        Удаляет событие слушателя с элемента. Аргументы аналогичные
        addEventListener()
      </p>
      <p class="bg">element.removeEventListener(event, handler, options)</p>
      <p>
        Для удаления нужно передать ссылку именну на ту callback функцию,
        которая была назначена на addEventListener(). В таком случае для
        callback используют отдельную функцию и передают ее по ссылке
      </p>
      <div>
        <button class="btn add-js">Add</button>
        <button class="btn remove-js">Remove</button>
        <button class="btn target-js">Click</button>
      </div>
      <p class="bg">
        const addListenerBtn = document.querySelector('.add-js'); <br />
        const removeListenerBtn = document.querySelector('.remove-js');<br />
        const btn1 = document.querySelector('.target-js');<br /><br />

        const handleClick1 = () => console.log('Event callback on click');<br /><br />

        addListenerBtn.addEventListener('click', () => {<br />
        btn1.addEventListener('click', handleClick1);<br />
        console.log('Click event listener added to btn');<br />
        });<br />
        removeListenerBtn.addEventListener('click', () => {<br />
        btn1.removeEventListener('click', handleClick1);<br />
        console.log('Click event listener remove from btn');<br />
        });<br />
      </p>
      <p>
        <b>Ключевое слово this</b><br />
        Если callback будет использовать функцию this, по умолчанию контекст
        внутри нее будет ссылаться на DOm элемент, на котором висит слушатель
      </p>
      <p class="bg">
        const mango = { <br />
        username: 'Mango',<br />
        showUserName() {<br />
        console.log(this);<br />
        console.log(`Мое имя пользователя: ${this.username}`);<br />
        },<br />
        };<br />
        const btn2 = document.querySelector('.btn2');<br />
        mango.showUserName();<br />
        // Плохой пример. this будет ссылаться на btn2 если использовать
        showUserName() в качестве callback<br />
        // btn2.addEventListener("click", mango.showUserName());<br /><br />

        btn2.addEventListener('click', mango.showUserName.bind(mango));<br />
      </p>
      <p>
        <b>Объект событий</b><br />
        Чтобы обработать событие недостаточно знать о том, что это клик и
        нажатие клавиш, могут потребоваться детали. К примеру текущее значение
        тесктового поля, элемент, на котором произошло событие, встроенные
        методы и другое. Каждое событие это объект, содержащий информацию о
        деталях события и автоматически передается первым аргументам в
        обработчик события. Все события происходят из базового класса Event
      </p>
      <p class="bg">
        const handleClick3 = event => console.log(event); <br />
        button.addEventListener("click", handleClick3);
      </p>
      <p>
        Параметр event это и есть объект события, который автоматически
        передается первым аргументом при вызове callback функции. Мы можем
        называть его как угодно, но как правило его объявляют как: e, evt,
        event. <br />
        Некоторые свойства объекта событий
      </p>
      <ul>
        <li>event.type - тип события</li>
        <li>
          event.currentTarget - элемент, на котором выполняется обработчик
          событий
        </li>
      </ul>
      <div>
        <button class="btn btn3" type="button">Click</button>
      </div>
      <p class="bg">
        const button3 = document.querySelector('.btn3'); <br />
        const handleClick4 = e => {<br />
        console.log('Event', e);<br />
        console.log('Event type', e.type);<br />
        console.log('Event current target', e.currentTarget);<br />
        };<br />
        button3.addEventListener('click', handleClick4);<br />
      </p>
      <p>
        <b>Действия браузера по умолчанию</b><br />
        Некоторые события вызывают действия браузера встроенные по умолчанию в
        качестве реакции на определенный тип события. Например клик на ссылку
        инициирует переход на новый адрес, указаный в href, а отправка формы
        перезагружает страницу. Чаще это поведение нежелательно и его необходимо
        отменить. Для отмены действий браузера по умолчанию у объекта событий
        есть стандартный метод <b>preventDefault()</b>
      </p>
      <form class="register__form" autocomplete="off">
        <input type="text" name="username" placeholder="Username" />
        <input type="password" name="password" placeholder="Password" />
        <button class="btn" type="submit">Register</button>
      </form>
      <p class="information">
        const form = document.querySelector('.register__form'); <br />
        form.addEventListener('submit', e => { <br />
        e.preventDefault(); <br /><br />

        const {<br />
        elements: { username, password },<br />
        } = e.currentTarget;<br />
        console.log(username.value, password.value);<br />
        });<br />
      </p>
      <h3 class="title">События клавиатуры</h3>
      <p>
        Существует 2 главных действия клавиатуры keydown и keyup. В отличае от
        других событий клавиатуры обрабатывается на документе, а не на
        конкретном элементе. Объект событий клавиатуры произошел от базового
        класса KeybordEvent
      </p>
      <p class="bg">
        document.addEventListener('keydown', e => console.log('Keydown', e));
        <br />
        document.addEventListener('keyup', e => console.log('Keyup', e));
      </p>
      <p>
        Нажимая клавишу происходит keydown, после чего когда отпускаешь клавишу
        происходит keyup. На практике в основном обрабатывается событие keydown,
        посколько оно происходит быстрее keyup и пользователь раньше видит
        результат нажатия. События keydown и keyup срабатывают при нажатии любой
        клавиши, включая служебные ( Ctrl, Shift, Alt, Escape и т.п.).
      </p>
      <p class="information">
        Раньше было еще 1 событие клавиатуры - keypress. Большинство постов на
        форумах и блогах может еще использовать его, но будьте осторожны - оно
        устарело и поддержка может прекратиться в любой момент.
      </p>
      <p>
        <b>Свойство key и code</b><br />
        Свойство key возвращает символ, сгенерированый нажатием клавиш учитывая
        состояние клавиш модификаторов, например shift и текущий язык <br />
        Свойство code возвращает код физической клавиши на клавиатуре и не
        зависит от языка
      </p>
      <p class="bg">
        document.addEventListener("keydown", e => { <br />
        console.log("Key", e.key);<br />
        console.log("Code", e.code);<br />
        })
      </p>
      <p>
        Наведите фокус в окно примера щелкнув мышью по нему, отслеживание
        события клавиатуры находится на элементе document. Напечатайте что
        нибудь и посмотрите результат
      </p>
      <div>
        <button class="btn clear" type="button">Clear</button>
        <div class="log__list"></div>
      </div>
      <p class="bg">
        const clearLogBtn = document.querySelector('.clear'); <br />
        const logList = document.querySelector('.log__list');<br />
        let keyPressCounter = 1;<br /><br />

        console.log(clearLogBtn);<br /><br />

        document.addEventListener('keydown', logMessage);<br />
        document.addEventListener('keyup', logMessage);<br /><br />

        clearLogBtn.addEventListener('click', reset);<br /><br />

        function logMessage({ type, key, code }) {<br />
        const markUp = `&lt;div
        class=&quot;log__item&quot;&gt;${keyPressCounter}<br />
        &lt;ul&gt;<br />
        &lt;li&gt;Event: ${type}&lt;/li&gt;<br />
        &lt;li&gt;Key: ${key}&lt;/li&gt;<br />
        &lt;li&gt;Code: ${code}&lt;/li&gt;<br />
        &lt;/ul&gt;<br />
        &lt;/div&gt;`;<br />
        logList.insertAdjacentHTML('afterbegin', markUp);<br />
        if (type === 'keyup') {<br />
        incrementKeyPressCounter();<br />
        }<br />
        }<br /><br />

        function reset() {<br />
        keyPressCounter = 1;<br />
        logList.innerHTML = '';<br />
        }<br /><br />

        function incrementKeyPressCounter() {<br />
        keyPressCounter += 1;<br />
        }<br />
      </p>
      <p>
        <b>Клавиши модификаторы</b><br />
        Для обработки клавиш комбинаций например ctrl+s или любой другой на
        объекте событий имеется свойство ctrlKey, shiftKey, altKey, metaKey,
        сохраняющаяя булевое значение, сигнализирущее о том, была ли зажата
        клавиша модификатор
      </p>
      <p class="bg">
        document.addEventListener("keydown", e => { <br />
        e.preventDefault();<br />
        if ((e.ctrlKey || e.metaKey) && e.code === "KeyS") {<br />
        console.log("Ctrl+S or Command+S");<br />
        }<br />
        });
      </p>
      <p>
        Некоторые комбинации клавиш могут конфликтовать поведением образователя
        по умолчанию например ctrl+d. Необходимо стараться проэктировать систему
        комбинации страницы чтобы она не пересекалась со встроеной в браузере.
        Но в последнем случае поведение по умолчанию можно отменить вызвав
        способ eventPreventDefault()
      </p>
      <h3 class="title">События элементов форм</h3>
      <p>
        <b>События submit</b><br />
        Отправка формы происходит во время щелчка по кнопке с атрибутом
        type="submit" или нажатию клавиши enter нахлдясь в любом ее текстовом
        поле. События submit можно применить для валидации формы перед
        отправкой, поскольку на объекте события существует много полезных
        свойств, связаных с элементами формы. Submit формы перезагружает
        страницу, поэтому не забывайте отменять действие по умолчанию методом
        preventDefault.
      </p>
      <form class="form1" autocomplete="off">
        <input type="text" name="login" placeholder="Login" />
        <input type="password" name="password" placeholder="Password" />
        <button class="btn btn4" type="submit">Register</button>
      </form>
      <p class="bg">
        const registerForm = document.querySelector('.form1'); <br />
        registerForm.addEventListener('submit', handleSubmit);<br /><br />

        function handleSubmit(e) {<br />
        e.preventDefault();<br />
        const form = e.target;<br />
        const login = form.elements.login.value;<br />
        const password = form.elements.password.value;<br />
        if (login === '' || password === '') {<br />
        return console.log('Заполните все поля');<br />
        }<br />
        console.log(`Login: ${login}, password: ${password}`);<br />
        form.reset();<br />
        }<br />
      </p>
      <p>
        <b
          >Свойство elements DOM элемента формы содерэит объект с сылкой на все
          элементы имеющий атрибут name. Поэтому в примере мы получаем значение
          полей login.value и password.value</b
        >
      </p>
      <h3 class="title">Событие change</h3>
      <p>
        Происходит после смены элемента формы для тектовых полей или text-aria
        событие произойдет не на каждом вводе символа а после потери фокуса, что
        не всегда удобно. Например пока вы набираете что-либо в текстовом поле
        событие отсутствует, но как только фокус пропал произойдет событие
        change. Для других элементов напрример select, check box или радиокнопок
        событие change срабатывает сразу при выборе значения.
      </p>
      <div>
        <p>Выбранный текст: <span class="text__span">none</span></p>
        <p>Выбранный значение: <span class="text__value">none</span></p>
        <p>
          <select class="roll__name">
            <option value="philadelphia">Philadilphia</option>
            <option value="kalifornia">Kalifornia</option>
            <option value="red-dragon">Red dragon</option>
          </select>
        </p>
      </div>
      <p class="bg">
        const select = document.querySelector('.roll__name'); <br />
        const textSpan = document.querySelector('.text__span');<br />
        const textValue = document.querySelector('.text__value');<br />
        select.addEventListener('change', setOutput);<br /><br />

        function setOutput(e) {<br />
        const selectOptionsValue = e.currentTarget.value;<br />
        const selectOptionsIndex = e.currentTarget.selectedIndex;<br />
        const selectOptionsText =
        e.currentTarget.options[selectOptionsIndex].text;<br /><br />

        textSpan.textContent = selectOptionsText;<br />
        textValue.textContent = selectOptionsValue;<br />
        }
      </p>
      <p class="information">
        Обрати внимание на полезное свойство при работе с элементом select в
        свойтвах value, selectedIndex, options
      </p>
      <h3 class="title">Событие input</h3>
      <p>
        Происходит только на текстовых полях и text-aria и создается каждый раз
        при изменении значения элемента, не дожидаясь потере фокуса. На практике
        input это самое главное событие при работе с текстовыми полями форм.
      </p>
      <input type="text" class="text__input" />
      <p>Значение текстового поля: <span class="output"></span></p>
      <p class="bg">
        const textInput = document.querySelector('.text__input'); <br />
        const output = document.querySelector('.output');<br /><br />

        textInput.addEventListener(<br />
        'input',<br />
        e => (output.textContent = e.currentTarget.value)<br />
        );
      </p>
      <h3 class="title">Событие focus и blur</h3>
      <p>
        Элемент получает фокус во емя щелчка мыши или клавишей tab. Момент
        получения и потери фокуса очень важен, получая фокус мы можем загрузить
        данные для автозаполнения, начать отслеживать изменения и т.д. При
        потере фокуса проверить введенные данные. Во время фокусировки элемента
        происходит событие focus, а когда фокус исчезает, например пользователь
        кликает в другую область экрана, происходит событие blur. Активировать
        или отменить фокус можно программой вызвав в коде для элемента
        одноименные методы focus() и blur()
      </p>
      <div>
        <button class="btn" type="button" data-action="set">Focus</button>
        <button class="btn" type="button" data-action="remove">
          Remove focus
        </button>
        <input type="text" class="text__input1" />
      </div>
      <p class="bg">
        const textInput = document.querySelector('.text__input1'); <br />
        const setFocusBtn = document.querySelector('[data-action="set"]');<br />
        const removeFocusBtn =
        document.querySelector('[data-action="remove"]');<br /><br />

        setFocusBtn.addEventListener('click', () => {<br />
        textInput.focus();<br />
        });<br />
        removeFocusBtn.addEventListener('click', () => {<br />
        textInput.blur();<br />
        });<br />
        textInput.addEventListener('focus', () => {<br />
        textInput.value = 'Этот текст в фокусе';<br />
        });<br />
        textInput.addEventListener('blur', () => {<br />
        textInput.value = '';<br />
        });<br />
      </p>
      <p>
        Фокус может быть только на одном элементе страницы за еденицу времени и
        текущий элемент, на котором находится фокус доступен как
        document.activeElement
      </p>
      <p class="information">
        Многие элементы не могут получить фокусировку, к примеру если кликнуть
        по div то фокусировка на нем не произойдет, потому что это не
        интерактивный элемент
      </p>
    </section>
    <script src="./js/moduleSix.js"></script>
    <script src="./js/DOM.js"></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 6</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Объектная модель документа</h3>
      <p>
        При работе с браузерам доступный функционал состоит из нескольких
        модулей, поскольку JS не имеет интрументов для рауботы с браузером.
      </p>
      <ul>
        <li><b>JS включает в себя</b></li>
        <li>1. ECMAScript</li>
        <li>2. DOM</li>
        <li>3. BOM</li>
      </ul>
      <p>
        Объектная модель документа (DOM - document object module) - независимый
        от языка интерфейс для работы с HTML. Содержит набор свойств и методов,
        позволяющий искать, создавать и удалять элементы, реагировать на
        действия пользователя и многое другое. Т.е соединять страницу с языком
        программирования. <br />
        DOM - это отображение HTML документа, древовидная структура, в которой
        каждый узел это JS объект со свойствами и методами, составляющие часть
        HTML документа. Каждый элемент в документе, весь документ в целом,
        заголовок, ссылка - это часть DOM, поэтому все они могут быть изменены
        из JS кода. <br />
        Объектная модель браузера (BOM - browser object module) - независимый от
        языка интерфейс для работы с вкладкой браузера. Содержит набор свйоств и
        методов, позволяющих получить доступ непосредственно к текущей вкладке и
        ряду функций браузера. Содержит объект работы истории навигации,
        метоположения и многое другое. <br />
        <b>HTML документ и DOM</b><br />
        Согласно DOM модели каждый тег образует отдельный элемент - узел, каждый
        фрагмент текста - тектовый элемент. HTML документ это иерархическое
        древо, которое у каждого элемента (кроме корневого) есть только один
        родительский элемент, т.е элемент, внутри которого он располагается. Это
        дерево появляется за счет вложенной структуры тегов и текстовых частей.
      </p>
      <img src="./images/DOMtree.jpg" alt="" class="img" />
      <p>
        Чтобы отобразить HTML документ браузер сначала превращает его в
        понимаемый формат DOM. Движение браузера имеет спец фрагмент кода
        HTML-Parser, который используется для преобразования HTML в DOM. <br />
        В HTML вложенность определяет отношение родитель-ребенок между
        элементами. В DOM объекты соеденены в древовидных структурах данных
        фиксируя эти взаимодействия. <br />
        Браузер строит DOM постепенно, как только поступают первые фрагменты
        кода, он начинает парсить HTML, добавляя узлы в древовидную структуру.
      </p>
      <img src="./images/parser1.jpg" alt="" class="img" />
      <p>
        После того, как DOM древо построено в нем можно найти элемент с помощью
        JS и выполнить с ним определенные действия, поскольку каждый элемент
        имеет интерфейс с множеством свойств и методов.
      </p>
      <img src="./images/parser2.jpg" alt="" class="img" />
      <p>
        <b>DOM дерево</b><br />
        Визуализируем дерево HTML документа используя сервис генератора DOM
        дерева
      </p>
      <p class="bg">
        &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Document
        title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Page
        title&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link
        1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Link
        2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt;
      </p>
      <img src="./images/live-dom-tree.jpg" alt="" class="img" />
      <p>
        В этом дереве выделены два типа узлов <br />
        Узлы - элементы (element node) образуются тегами, обычным образом одни
        элементы вложены в лругие. Структура дерева образована только за счет
        них <br />
        Текстовые узлы (text node) образуются текстом внутри элемента. Текстовый
        узел содержит только строчку текста и не может иметь дочерних элементов,
        т.е он всегда на самом низком уровне иерархии. Пробелы и перенос строк
        это тоже тектовый узел. <br />
        Из этого правила есть исключения - пробелы к head игнорируются, а любое
        содержимое после body не создает элемент, браузер переносит его в конец
        body
      </p>
      <h3 class="title">Навигация по DOM</h3>
      <p>
        DOM представляет собой широкий спектр для работы с элементом и его
        содержимым, но для этого нужно сначала получить ссылку на него. Доступ к
        DOM начинается с объекта document, из него можно добраться до любых
        элементов <br />
        document - это часть глобального объекта window, который доступен в
        скрипте, когда он выполняется в браузере. Так же как alert, сonsole.log,
        prompt и многое другое. <br />
        Элемент DOM дерева имеет иерархическое отношение друг к другу. Для
        описания отношения используется термин предок(ancestor),
        отпрыск(descedant), отец(parent), ребенок(child) и сосед(sibling).
      </p>
      <p>
        Самый высокий элемент называется корневым - root node, каждый элемент
        кроме корневого имеет только одного родителя
      </p>
      <ul>
        <li>У элемента может быть сколько угодно детей</li>
        <li>Соседи - это элементы с общим родительским элементом</li>
        <li>
          Дочерние элементы (дети), которые находятся непосредственно внутри
          текущего (первая вложенность)
        </li>
        <li>
          Потомки - все элементы, которые находятся в текущем месте с их детьми,
          детьми их детей и т.д
        </li>
      </ul>
      <img src="./images/dom-traversal.jpg" alt="" class="img" />
      <p>Для навигации по этой иерархии элементы имеют след свйоство</p>
      <ul>
        <li>elem.parentNode - выбирает родительский элемент</li>
        <li>
          elem.childNode - псевдо массив, сохраняет все дочерние элементы,
          включая текстовые
        </li>
        <li>
          elem.children - псевдо массив сохраняющий только узлы дочерних
          элементов, т.е только те, что отвечают тегам
        </li>
        <li>
          elem.firstChild - выберет первый дочерний элемент в середине elem,
          включительно тектовые узлы
        </li>
        <li>
          elem.firstElementChild - выберет первый дочерний узел-элемент в
          середине elem
        </li>
        <li>
          elem.lastChild - выберет последний дочерний элемент в середине elem,
          включительно тектовые узлы
        </li>
        <li>
          elem.lastElementChild - выберет последний дочерний узел-элемент в
          середине elem
        </li>
        <li>
          elem.previousSibling - выберет элемент слева от elem (его предыдущего
          соседа)
        </li>
        <li>
          elem.previousElementSibling - выберет узел-элемент слева от elem (его
          предыдущего соседа)
        </li>
        <li>
          elem.nextSibling - выберет элемент справа от elem (его след соседа)
        </li>
        <li>
          elem.nextElementSibling - выберет узел-элемент справа от elem (его
          след соседа)
        </li>
      </ul>
      <p>
        DOM коллекции такие как child nodes и children - псевдо массивы (node
        list), у них нет большинства методов массива
      </p>
      <div class="dom">
        <ul id="menu" class="menu">
          <li class="menu__item">Home</li>
          <li class="menu__item">About</li>
          <li class="menu__item">Gallery</li>
          <li>Blog</li>
        </ul>
      </div>
      <h3 class="title">Поиск элементов</h3>
      <p>
        Итак мы уже знаем что такое DOM element - это объект со свойствами и
        методами. Пришло время быстро находить элемент по произвольным css
        селекторам. Группа методов elem.querySelector* - это современны стандарт
        посика элемнтов. Они позволяют найти элемент или группу элементов css
        селекторов любой сложности <br />
        <b>element.querySelector("selector")</b><br />
        Используется, если необходимо найти только один, чаще всего уникальный
        элемент. Он возвращает первый найденый внутри элемент - element, который
        соответствует css селектору selector. Если ничего не найдено вернет
        null. <br />
        <b>element.querySelectorAll("selector")</b><br />
        Используется если необходимо найти коллекцию элементов, т.е получить
        массив ссылок на элементы с одним и тем же селектором, например все
        элементы классом menu__item. возвращает псевдомассив всех элементов
        внутри element, соответствующих css селекторов selector. Если ничего не
        найдено вернет пустой массив.
      </p>
      <h3 class="title">Свойства и атрибуты</h3>
      <p>
        В период постройки DOM некоторые стандартные HTML атрибуты становятся
        свойствами элемента.
      </p>
      <ul>
        <li>
          <b>value</b> - содержит текущее текстовое содержимое элементов формы
        </li>
        <li><b>checked</b> - сохраняет состояние чекбокса или радиокнопки</li>
        <li>
          <b>name</b> - сохраняет значение, указанное в HTML атрибуте name
        </li>
        <li><b>src</b> - путь к сохранению тега img</li>
      </ul>
      <p class="bg">
        <img
          src="https://picsum.photos/id/9/320/240"
          alt="laptop"
          class="image"
          width="300"
        />
      </p>
      <h3 class="title">Свойство textContent</h3>
      <p>
        elem.textContent возвращает текстовое содержимое внутри элемента.
        Доступен для чтения и записи. Не важно что textContent данные всегда
        будут записаны в виде текста
      </p>
      <article class="article">
        <h4 class="article__title">Lorem, ipsum dolor.</h4>
        <p class="article__text">
          Lorem ipsum dolor sit amet, consectetur adipisicing elit. Neque
          incidunt cupiditate accusamus expedita veniam nemo ut qui fuga cumque
          id.
        </p>
      </article>
      <h3 class="title">Свойство classList</h3>
      <p>
        Свойство classList хранит объект с методами для работы с классами
        элементов
      </p>
      <ul>
        <li>
          elem.classList.contains(class) return true or false. В наличии от
          класса в элементе
        </li>
        <li>
          elem.classList.add(class) - добавляет класс к списку классов элементов
        </li>
        <li>
          elem.classList.remove(class) - удаляет класс из списка классов
          элементов
        </li>
        <li>
          elem.classList.toggle(class) - если отсутствует класс, то добавляет
          его, а если присутствует то удаляет
        </li>
        <li>
          elem.classList.replace(oldClass, newClass) - заменяет существующий
          класс(oldClass) на указаный (newClass)
        </li>
      </ul>
      <p class="bg">
        <a href="#" class="link is-active">Random link</a>
      </p>
      <h3 class="title">Свойство style</h3>
      <p>
        Использется для чтения и изменения онлайн стилей. Возвразает объект
        CSSStyleDeclaration, содержащий список всех свойств определенных только
        в встроенных стилях элемента, а не во всех css. Во время записи свойство
        записывается camelCase, т.е background-color превращается в
        elem.style.backgroundColor
      </p>
      <p class="bg">
        const button = document.querySelector(".btn"); <br />
        button.style.backgroundColor = "blue";<br />
        button.style.fontSize = "24px";<br />
        button.style.textAlign = "center";<br />
      </p>
      <h3 class="title">Атрибуты</h3>
      <p>
        DOM элементам соответствуют HTML теги, которые содержат текстовые
        атрибуты. Доступ к атрибутам устанавливается с помощью стандартных
        методов. Эти методы работают со свойствами, которые находятся в HTML
      </p>
      <ul>
        <li>
          elem.hasAttribute(name) - проверяет наличие атрибута, возвращает true
          or false
        </li>
        <li>
          elem.getAttribute(name) - получает значение атрибута и возвращает его
        </li>
        <li>elem.setAttribute(name, value) - устанавливает атрибут</li>
        <li>elem.removeAttribute(name) - удаляет атрибут</li>
        <li>
          elem.attributes - свойство возвращающее в объект все атрибуты элемента
        </li>
      </ul>
      <p class="bg">
        <img
          src="https://picsum.photos/id/9/320/240"
          alt="laptop"
          class="img1"
          width="300"
        />
        const img1 = document.querySelector('.img1'); <br />
        console.log(img1.attributes);// {0:class,1:src,alt,length:1 }<br />
        console.log(img1.hasAttribute("src"));// true<br />
        console.log(img1.getAttribute("alt"));// "laptop"<br />
        img1.setAttribute("alt", "tel")<br />
        console.log(img1.getAttribute('alt'));// "tel"<br />
      </p>
      <h3 class="title">Data атрибуты</h3>
      <p>
        Позволяет добавить к тегу произвольный атрибут и получить его значение в
        JS. Это возможность используется для упрощения написания кода, например
        для привязки данных и индификатора к уникальному индификатору, для
        указания типа действия кнопки и т.д
      </p>
      <p class="bg">
        <button type="button" data-active="save">Save</button>
        <button type="button" data-active="close">Close</button>
      </p>
      <p>
        Для получения значения data атрибута используется свойство dataset,
        после которого стоит имя атрибута. Т.е data - откидывается, а другая
        часть имени записывается как имя свойства объекта
      </p>
      <p class="bg">
        const saveBtn = document.querySelector('button[data-action="save"]');
        <br />
        console.log(seveBtn.dataset.action);//save<br /><br />

        const closeBtn =
        document.querySelector('button[data-action="close"]');<br />
        console.log(closeBtn.dataset.action);//close<br />
      </p>
      <div class="editor">
        Lorem ipsum, dolor sit amet consectetur adipisicing elit. Magni nam iste
        iure totam quidem rem nesciunt non illo! Obcaecati quaerat aut mollitia
        a assumenda quisquam voluptatibus numquam accusantium debitis
        perferendis!
        <div class="actions">
          <button class="btn" type="button" data-action="save">
            Save Text
          </button>
          <button class="btn" type="button" data-action="close">
            Close editor
          </button>
        </div>
      </div>
      <h3 class="title">Создание и удаление элементов</h3>
      <p>
        DOM api позволяет нне только выбирать и изменять существующие, но и
        удалять а так же создавать новые элементы, после чего добавлять их в
        документ
      </p>
      <p class="bg">document.createElement(name_tag)</p>
      <p>
        Создает элемент с именем tag_name и возвращает ссылку на него как
        результат своего исполнения. Tag_name это строка, указывающая тип
        создаваемого элемента. Элемент создается в памяти, у DOM его еще нет.
      </p>
      <p class="bg">
        const title = document.createElement('h1'); <br />
        heading.textContent = 'This is title';<br /><br />

        const image2 = document.createElement('img');<br />
        image2.src = 'https://placeimg.com/640/480/nature';<br />
        image2.alt = 'nature';
      </p>
      <h3>Добавление</h3>
      <p>
        Чтобы созданный элемент отображался на странице его необходимо добавить
        к существующему элементу DOM. Предположим что добавляем к определенному
        элементу element, для этого существуют методы
      </p>
      <ul>
        <li>
          <b>element.append(elem1, elem2, ...)</b> - добавляет один или
          несколько элементов после всех детей элемета element
        </li>
        <li>
          <b>element.prepend(elem1, elem2, ...)</b> - добавляет элемент перед
          всеми детьми элемента element
        </li>
        <li>
          <b>element.after(elem1, elem2, ...)</b> - добавляет один или несколько
          элементов после элемента element
        </li>
        <li>
          <b>element.before(elem1, elem2, ...)</b> - добавляет один или
          несколько элементов перед элементом element
        </li>
      </ul>
      <p>
        Во всех этих el это элементы или строки в любом сочетании и колличестве.
        Строки добавляются как текстовые узлы.
      </p>
      <div class="user">
        <h1>User names</h1>
        <ul class="usernames">
          <li class="username__item">Petya</li>
        </ul>
      </div>
      <p class="bg">
        const list = document.querySelector('.usernames'); <br />
        const listItem = document.createElement('li');<br /><br />

        listItem.textContent = 'Vasya';<br />
        list.append(listItem);<br /><br />

        const firstItem = document.createElement('li');<br />
        firstItem.textContent = 'Polya';<br />
        list.prepend(firstItem);<br /><br />

        const user = document.querySelector('.user');<br /><br />

        const allList = document.querySelector('.username__item');<br />
        allList.style.border = '1px dashed red';<br />
      </p>
      <h3 class="title">Удаление</h3>
      <p class="bg">element.remove()</p>
      <p>
        Для того, чтобы удалить элемент используем метод remove(), он вызывается
        на элемент elem, который нужно удалить
      </p>
      <article class="article1">
        <h2 class="title1">Article title</h2>
        <p class="text1">Lorem ipsum dolor sit amet.</p>
        <a href="#" class="link">Read more</a>
      </article>
      <p class="bg">
        const text1 = document.querySelector('.text1'); <br />
        text1.remove();
      </p>
      <h3 class="title">Оптимизация работы с DOM</h3>
      <p>
        Современные браузеры пытаются оптимизировать процесс воспроизведения
        страницы без вмешательства разработчика, однако изменение DOM дерева это
        дорогостоющая операция, поэтому необходимо минимизировать количество
        обращений к DOM. <br />
        <b>repaint</b> происходит когда изменения коснулись стилей, влияющих на
        внешний вид элементов, но не на геометрию, например opacity,
        background-color, visability, outline. Браузер повторно создает элемент
        с учетом нового стиля. Так же проверяется видимость других элементов,
        один или более могут оказаться скрытыми под изменившем внешний элемент.
        <br />
        <b>reflow</b> происходит когда изменения влияют на содержимое, структуру
        документа, положение элемента. Происходит перерасчет позиционирования и
        размеров что приводит к повторному созданию части или всего документа.
        Изменение размера одного родителького контейнера влияет на всех его
        детей и предков. Оказывает значительно большее влияние на
        производительность чем repaint. Все вышеперечисленные операции блокирует
        браузер. Страница не может выполнять никаких других операций во время
        когда происходит reflow или repaint
      </p>
      <ul>
        Причины
        <li>
          Манипуляция с DOM(сложение, удаление, изменение, перестановка
          элементов)
        </li>
        <li>Изменение содержимого, в частности текста в полях форм</li>
        <li>Расчет или изменение css свойств</li>
        <li>Добавление или удаление таблиц стилей</li>
        <li>Манипуляция с атрибутами класса</li>
        <li>Манипуляция с окном браузера (изменение размера, прокрутка)</li>
        <li>Активация псевдоклассов, например ::hover</li>
      </ul>
      <h3 class="title">Свойство innerHTML</h3>
      <p>
        Еще один способ создать DOM элемент и поместить в дерево. Это позволит
        использовать строки с тегами и позволит браузеру проделать всю тяжелую
        работу. У такого подхода есть свои плюсы и минусы. <br />
        <b>Чтение</b> <br />
        Свойство innerHTML сохраняет содержимое HTML включая теги в виде строк.
        Возвращаемое значение это всегда валидный HTML код.
      </p>
      <article class="article2">
        <h2 class="title2">Article title</h2>
        <p class="text2">
          Lorem ipsum dolor sit amet consectetur
          <strong>adipisicing</strong> elit. Aliquid inventore optio dignissimos
          iusto dolor minus eum illo ratione nihil aliquam.
        </p>
        <a href="#" class="link2">Read more</a>
      </article>
      <p class="bg">
        const article2 = document.querySelector('.article2'); <br />
        console.log(article2.innerHTML);<br />
        const title2 = document.querySelector('.article2', '.title2');<br />
        console.log(title2.innerHTML);<br />
        const text2 = document.querySelector('.article2', '.text2');<br />
        console.log(text2.innerHTML);<br />
        const link2 = document.querySelector('.article2', '.link2');<br />
        console.log(link2.innerHTML);<br />
      </p>
      <p>
        <b>Изменение</b><br />
        Свойство innerHTML доступно и для чтения и для записи. Если записать в
        нее строку с HTML тегами то браузер во время парсинга строчки превратят
        их в валидные элементы и DOm добавит их в DOM дерево
      </p>
      <p class="bg">title2.innerHTML = 'This is <b>new</b> title';</p>
      <p>
        При таком подходе, в отличии от document.createElement() мы не получаем
        ссылку на зозданый DOM элемент. Это первый шаг на пути к шаблонизации
        создания большого колличества однотипной разметки и разными данными по
        заранее определенному шаблону, например как списки товаров интернет
        магазина <br />
        Однотипная (шаблонная) разметка создается из массива данных. Прием
        заключается в переборе этого масиива и составления одной строки с HTML
        тегами, которую затем записываем в innerHTML.
      </p>
      <div>
        <h2>Languages</h2>
        <ul class="list3"></ul>
      </div>
      <p class="bg">
        const languages = ['HTML', 'CSS', 'React', 'Node', 'JS', 'Vue']; <br />
        const list3 = document.querySelector('.list3');<br />
        const markUp = languages<br />
        .map(language => ` &lt;li
        class=&quot;list__item3&quot;&gt;${language}&lt;/li&gt; `)<br />
        .join('');<br />
        list3.innerHTML = markUp;<br />
      </p>
      <p>
        <b>Добавление</b><br />
        Изменение elem в innerHTML полностью удалит и повторно создаст все
        потомки элемента elem. Если элемент по началу не был пуст, то возникнут
        доп затраты на сереализацию существующей разметки (перезапись)
      </p>
      <p class="bg">
        const newText = `&lt; p class=&quot;new__text&quot;&gt;Lorem ipsum dolor
        sit amet consectetur adipisicing elit. Aspernatur est beatae facilis rem
        id commodi sequi ad! Obcaecati, nulla iusto?&lt;/&gt;&lt; a
        class=&quot;new__link&quot; href=&quot;#&quot;&gt;Read moreeeee&lt;
        /a&gt;`; <br />
        article2.innerHTML += newText;
      </p>
      <p>
        <b>Метод insertAdjacentHTML()</b><br />
        Это современный метод для добавления строки с HTML тегами перед, после
        или в середину элементов. Решает проблему innerHTML с повторной
        сериализацией содержимого элемента во время добавления разметки к уже
        существующей
      </p>
      <p class="bg">elem.insertAdjacentHTML(position, string);</p>
      <p>
        Аргумент position это строка, позиция нашего элемента, принимает одно из
        4 значений
      </p>
      <ul>
        <li>beforebegin - перед elem</li>
        <li>afterbegin - в середине elem</li>
        <li>beforeend - в середине elem после всех детей</li>
        <li>afterend - после elem</li>
      </ul>
      <div>
        <ul class="list4">
          <li class="list__item4">HTML</li>
          <li class="list__item4">CSS</li>
          <li class="list__item4">JS</li>
        </ul>
      </div>
      <p class="bg">
        const list4 = document.querySelector('.list4'); <br />
        const newLanguages = ['React', 'Node', 'Vue'];<br />
        const markUp2 = newLanguages<br />
        .map(language =&gt; `&lt;li
        class=&quot;list__item4&quot;&gt;${language}&lt;/li&gt;`)<br />
        .join('');<br />
        list4.insertAdjacentHTML('beforeend', markUp2);<br />
        list4.insertAdjacentHTML('beforebegin',
        '&lt;h2&gt;Languages&lt;/h2&gt;');
      </p>
      <h3 class="title">Подключение скриптов</h3>
      <p>
        Загрузка и исполнение скрипта обозначена в теге script без каких-либо
        атрибутов, блокирует обработку HTML документа и построение DOM. Это
        проблема.
      </p>
      <p class="bg">
        &lt;script src=&quot;path-to-script.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        Когда анализатор втречает такой тег обработка HTML документа
        приостанавливается и начинается загрузка файла скрипта, которая
        определена в атрибуте src. После загрузки скрипта выполняется, и только
        потом восстанавливается обработка HTML. Это называется блокирующий
        скрипт <br />
        <b>Атрибуты defer и async</b> <br />
        Были введены чтобы разработчикам была возможность контролировать способ
        загрузки скриптов и когда именно их выполнять <br />
        <b>Атрибут defer</b>
      </p>
      <p class="bg">
        &lt;script defer src=&quot;path-to-script.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        Указывает браузеру загрузку файла скрипта в фоновом режиме параллельно с
        обработкой HTML документа и построению DOM. Скрипт будет выполнятся
        только после того как HTML документ был обработан, а DOM построен. Такие
        скрипты не блокируют построение DOM дерева, гарантировано выполняются в
        таком порядке, в каком указано в HTML документе
      </p>
      <img src="./images/defer.jpg" alt="" class="img" />
      <p><b>Атрибут async</b><br /></p>
      <p class="bg">
        &lt;script async src=&quot;path-to-script.js&quot;&gt;&lt;/script&gt;
      </p>
      <p>
        Загрузка скрипта с атрибутом async не блокирует построение DOM, но он
        выполняется сразу после загрузки. Это означает что такой скрипт может
        заблокировать построение DOM и выполнятся в произвольном порядке.
      </p>
      <img src="./images/async.jpg" alt="" class="img" />
    </section>
    <script src="./js/moduleSix.js"></script>
    <script src="./js/DOM.js"></script>
  </body>
</html>

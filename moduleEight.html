<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 8</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Node js</h3>
      <p>
        Легкая и эффективная среда выполнения JS. Позволяет писать
        высокопроизводительные серверные приложения и инструменты. Построена на
        JS движке V8 и написана на С++. <br />
        Сначала Node js создавалась как серверная среда обитания для приложений,
        но разработчики начали использовать ее для создания инструментов,
        помогающих автоматизировать выполнение локальных задач. В результате
        новая экосистема инструментов возникшая вокруг Node js привела к
        трансформации процесса front end разработок. <br />
        После установки в терминале будет доступна команда node. Чтобы убедиться
        что установка прошла успешно, проверьте версию, запустив команду node
        --version.
      </p>
      <p class="information">
        <b>Команда терминала</b><br />
        pwd (путь) - указывает путь к текущей папки <br />
        ls (list) - детальная информация содержимого в папках с указанием пути.
        ls -l, ls -la <br />
        clear - очистка терминала <br />
        Навигация - cd (change directory) - ".." - выход на один уровень вверх
        "на два уровня вверх ../../" <br />
      </p>
      <h3 class="title">JS вне браузера</h3>
      <p>
        Node js позволяет выполнять js код вне браузера. При открытии любого
        терминала выполнив команду node запустится REPL (read eval print loop) -
        интерактивная среда выполнения js кода. <br />Пакетный менеджер NPM
        <br />
        Чтобы использовать все разнообразие инструментов или пакетов node js нам
        необходимо возможность устанавливать и управлять ими. Для этого создан
        NPM (node package manager). Он устанавливает нужные пакеты и
        обеспечивает удобный интерфейс для работы с ними.
      </p>
      <ul>
        NPM состоит из трех основных компонентов
        <li>
          Сайт npmjs.com - используется для поиска и ознакомления с
          документацией пакетов
        </li>
        <li>
          Интерфейс комендной строки CLI - запускается из терминала и
          предоставляет набор команд для работы с реестром и пакетами, позволяет
          создавать скрипты для запуска в терминале
        </li>
        <li>
          Реестр пакетов - крупная, общедоступная база данных инструментов
          разработчиков
        </li>
      </ul>
      <p>
        Пакет (package) - небольшая js библиотека, решающая специфическую
        задачу. Пакеты пишут сами разработчики и делается с сообществом. Такой
        подход упрощает работу. <br />
      </p>
      <ul>
        Команды NPM. Пречислим основные команды и рассмотрим их.
        <li>
          npm init - инициализирует npm в проэкте и создает файл package.json
        </li>
        <li>
          npm install - устанавливает все зависимости перечисленные в
          package.json
        </li>
        <li>
          npm list --depth=0 - выводит в терминале список локально установленных
          пакетов с номерами их версий без зависимости
        </li>
        <li>
          npm install [package-name] - устанавливает пакет локально в папку
          node_moduls
        </li>
        <li>
          npm uninstall [package-name] - удаляет пакет, установленный локально и
          обновляет package.json
        </li>
        <li>
          npm start и npm test - запускает скрипт старт или тест, расположенный
          в package.json
        </li>
        <li>
          npm run [custom-script] - запускает кастомный скрипт, расположенный в
          package.json
        </li>
        <li>
          npm outdated - используется для поиска обновлений, обнаружит
          совместимые версии програмно и выведет список доступных обновлений
        </li>
        <li>
          npm update - обновит все пакеты до максимально разрешенной версии
        </li>
      </ul>
      <h3 class="title">Инциализация проэкта</h3>
      <p>
        Каждый проэкт начинается с создания файлов package.json. Он отслеживает
        зависимости, содержит служебную информацию, позволяет писать npm скрипты
        и служит инструкцией при создании нового проэкта на основе уже готовых
        настроек. Файл package.json можно создать npm командой init -
        инициализация проэкта в этой папке. Вам будет предложено ввести название
        проэкта, версию, описание и т.д. Можно нажать просто enter пока не будет
        создан package.json и размещен в папке проэкта. Чтобы не нажимать enter
        пропуская пустые поля использется команда init --yes. Флаг это
        дополнительная настройка для команды. <br />
        <b>npm init --yes</b> <br />
        У каждого флажка есть псевдоним, его сокращенная запись. Псевдоним флага
        --yes --y, поэтому команды npm init --yes и npm init --y делают одно и
        тоже <br />
        Будет создан package.json со значениями по умолчанию. Чтобы установить
        эти значения выполните в терминале следующие команды
      </p>
      <p class="information">
        npm config set init.author.name "name" <br />
        npm config set init.author.email "email"
      </p>
      <p>
        Файл package.json можно изменить вручную или выполнить npm init еще раз.
        Если открыть package.json он будет примерно выглядет как обычный объект.
        Это всего лишь мета данные о проэкте
      </p>
      <h3 class="title">NPM скрипты</h3>
      <p>
        Скрипты позволяют запускать для использования установленные пакеты.
        Используя npm скрипты можно создавать целые системы сборок проэктов.
        Автоматизирует запуск index.js. Для этого в файле package.json добавим
        скрипт запуска старт.
      </p>
      <p class="bg">
        { <br />
        "scripts": {<br />
        "start": "node test.js"<br />
        }<br />
        }<br />
      </p>
      <p>Теперь мы можем его запускать через команду npm start</p>
      <h3 class="title">Установка пакетов</h3>
      <p>
        Один из предоставляемых возможностей npm - установка пакетов, которые
        извлекаются из реестра и распаковываются в папку node_moduls в корне
        проэкта. После создания файла package.json можно добавлять зависимости в
        проэкт <br />
        Зависимостью называют npm пакет используемый в разработке. Это
        всевозможные утилиты и библиотеки. Установим библиотеку validator js для
        валидации строк, например ввод пользователя в поля форм
      </p>
      <p class="bg">npm install validator</p>
      <p>
        Npm загрузил валидатор и пометил его в node_moduls, в котором будут
        находится все внешние зависимости <br />
        package-lock.json это журнал снимков дерева в зависимости от проэкта. Он
        гарантирует что команда разработчиков использует одинаковые версии
        зависимости. Npm автоматически обновляет его при добавлении, удалении и
        обновлении пакетов. <br />
        В package.json появляется новая зависимость в поле dependencies. Это
        означает что валидатор версия 13.0.0 была установлена как зависимость и
        готова к работе. Пакеты постоянно обновляются и версия может отличаться,
        для этого и нужны поля замисимости
      </p>
      <p class="bg">
        "dependencies": { <br />
        "validator": "^13.12.0"<br />
        }<br />
      </p>
      <p>
        Чтобы получить интерфейс пакетов в node js коде необходимо вызвать
        функцию require("module name") передавая аргументом имя модуля без
        определения пути. Это называется абсолютный импорт. Путь не требуется,
        поскольку по умолчанию поиск модуля будет происходить в папке
        node_moduls. Результатом своего выполнения функции вернет интерфейс
        модуля с методами или просто функцию, зависит от пакета.
      </p>
      <p class="bg">
        const validator = require('validator'); <br />
        const validatorEmail = email => {<br />
        return validator.isEmail(email);<br />
        };<br />
        console.log('Это почта валидна? :', validatorEmail('mail@mail.com'));
        //Это почта валидна? : true<br />
        console.log('Это почта валидна? :', validatorEmail('mail.com'));//Это
        почта валидна? : false<br />
      </p>
      <h3 class="title">Удаление пакетов</h3>
      <p>
        Предположим что версия валидатора вызывает проблемы с совместимостью. Мы
        можем удалить этот пакет и поставить более старую версию
      </p>
      <p class="bg">
        //validator 13.0.0 <br />
        npm uninstall validator <br />
        // Устанавливаем более старую версию
        <br />
        npm install validator@11.0.0
      </p>
      <p>
        Установка пакетов определенной версии используется в коммерческих
        проэктах для того чтобы гарантировать работу кодовой базы и возможность
        долгосрочной поддержки.
      </p>
      <h3 class="title">Типы зависимостей</h3>
      <p>
        Зависимости проэкта. Некоторые будут использованы в финальном продукте.
        Другие необходимы только на стадии разработки, а есть и такие котрые
        необходимо использовать независтмо от проэкта, именно для этого команды
        npm install и npm uninstall имеют три флага ---
      </p>
      <ul>
        <li>
          -save - указывает что прибавляется зависимость, которая войдет в
          финальный продукт. Пакет будет установлен локально в папку node_moduls
          и будет добавлена запись в поле dependencies в package.json
        </li>
        <li>
          -save-dev - указывает что прибавляется зависимость разработки, пакет
          будет установлен локально в папку node_moduls и будет добавлена запись
          в поле devDependencies в package.json
        </li>
        <li>
          -global - указывает что добавляется глобальная зависимость, т.е для
          любого проэкта. Проэкт будет устанослен глобально в систему
        </li>
        <li>
          <b
            >Если не указывать флаг будет использован --save по умолчанию.
            Удаляя пакет необходимо указывать правильный флаг, так же как для
            установки. Не устанавливайте пакеты глобально если работаете с
            другими разработчиками</b
          >
        </li>
      </ul>
      <h3 class="title">Управление версиями пакетов</h3>
      <p>
        Пакеты имеют соответствующий номер версии
        <b>(на сайте npm в описании пакета вкладка version)</b>
      </p>
      <ul>
        <li>
          npm outdated - используется для поиска обновлений, обнаружит
          совместимые версии программы
        </li>
        <li>
          npm update - обновляет все пакеты до максимально разрешенной версии
        </li>
        <li>npm update [имя пакета] - обновляет указанный пакет</li>
      </ul>
      <h3 class="title">Управление кешем</h3>
      <p>
        После установки пакета npm сохраняется его копия в кеше, поэтому при
        след установке вам не нужно снова загружать его из интернета. Кеш
        хранится в папке .npm вашего домашнегшо каталога. <br />
        Эта папка с течением времени засоряется старыми пакетами, ее желательно
        чистить хотя бы 2 раза в год. Кеширование полезно т.к оно ускоряет
        процесс установки уже использованых пакетов. <br />
        <b>npm cache clean</b>
      </p>
      <h3 class="title">Модульность кода</h3>
      <p>
        Концеепция модулей как метод организации кода была давно. С увеличением
        проэкта и кодовой базы ее пытаются разбить на файлы, в каждом из котором
        описывается отдельный функционал. Модульный код помогает в организации
        обслуживания, тестирования и самое главное управление зависимостями.
        Важнейшее приимущество модулей - это поддержка, пространство имен и
        повторное использование <br />
        <b>Поддержка</b> - хорошо разработанный модуль максимально уменьшит
        зависимость от других частей кода, это позволит расширить функционал
        приложений не опасаясь нарушить его работу в целом. Обновление одного
        модуля гораздо проще если один модуль самодостаточен <br />
        <b>Пространство имен</b> - переменные, не входящие в область видимости
        функций являются глобальными. В результате как правило происходит
        загрязнение пространства имен где полностью не связаный код разделяет
        глобальные переменные. Модули позволяют избежать загрязнение
        пространства имен, создавая отдельную область видимости для переменных
        <br />
        <b>Повторное использование</b>. Все разработчики копировали готовый код
        в новые проэкты изменяя его под специфику проэкта. Это очевидно огромная
        трата времени. Гораздо лучше когда есть модуль, который можно
        использовать снова и снова без необходимости знать что либо об его
        окружении, в котором он используется. <br />
        <b>Сборка модулей</b> <br />
        <b>Собирание модулей</b> - это процесс конкатинации группы модулей и их
        зависимостей в один или группу файлов. <br />
        Обычно код делят на папки и файлы. К тому же нужно подключать внешние
        библиотеки. В результате этого каждый файл нужно добавить в основной
        HTML файл теге script, который затем загружается браузером <br />
        Наличие отдельных тегов script для каждого файла означает что браузер
        будет загружать каждый файл отдельно, что отрицательно сказывается на
        скорости загрузки страницы. Чтобы устранить эту проблему файл
        объеденяется в один или несколько файлов с целью уменьшить кол-во
        запросов. Но остается неувязка управления зависимостей между модулями.
        <br />
        Если используется система модулей такие как CommonJS и ESM необходимо
        использовать инструмент для преобразования правильно упорядоченный и
        доступный для браузера код. Именно здесь наченает действовать webpack и
        другие бандлеры. <br />
        <b>Модули ECMAScript(EMS)</b> до недавнего времени небыло встроенной
        модульной системы. EMS имеет компактный декларативный синтаксис и
        возможность асинхронной загрузки. ES модуль это фрагмент js кода, котрый
        используется много раз и экпортирует определенные объекты, делая их
        доступными для других модулей. <br />
        Каждый js файл хранит код в уникальном контесте модуля и импортирует в
        необходимую ему зависимости и экспортирует все, что другие модули должны
        импортировать. Операция экпорта и импорта реализуется конструктором
        import и export. Есть два очевидных приимущества этих концепций -
        предотвращение загрязнения глобального пространства имен и явное
        указание зависимостей <br />
        Новая систама модулей отличается от СommonJS - прежде всего это
        стандарт, а значит со временем будет полностью поддерживаться браузером
        нативно без доп инструментов. Однако сейчас браузерная поддержка
        неполная, поэтому ESM используется вместе с инструментами сборки модулей
        такими как webpack, parcel и другими<br />
        <b
          >ESM разработаны на основе статического анализа, это означает что при
          импорте модулей модуль обрабатывается во время компиляции, т.е до
          запуска скрипта, это позволяет удалять экспорт не используемый другими
          модулями прежде чем запускать скрипт, что может привести к
          значительной экономии веса js файла снизив нагрузку на браузер. Это
          называется Tree shaking и выполняется бандлерами автоматически при
          сборке js кода.</b
        ><br />
        <b>Named export</b>. Модуль может экспортировать несколько сущностей,
        которые отличаются своими именами и называются "именуемыми экспортами".
        Чтобы имортировать их в другой модуль необходимо знать имена
        импортируемых сущностей которые мы хотим импортировать <br />
        Первый способ - это использование ключевого слова export перед всеми
        сущностями, которые необходимо экспортировать. Они будут добавлены как
        свойство экпортированых объектов. При импорте мы деструктуризируем
        свойство импортируемого объекта. <br />
      </p>
      <p class="bg">
        const fn = Math.fn; <br />
        export const square = x => x * x;<br />
        export const diag = (x, y) => fn(square(x) + square(y));<br /><br />
        import { square, diag } from './js';<br />
        console.log(square(10));<br />
        console.log(diag(15, 20));<br />
      </p>
      <p>
        Второй способ это явно указать объект со свойствами для экспорта. <br />
      </p>

      <p class="bg">
        const fn = Math.fn; <br />
        const square = x => x * x;<br />
        const diag = (x, y) => fn(square(x) + square(y));<br /><br />

        export { square, diag };<br />
      </p>
    </section>
    <script src="./js/moduleEight.js"></script>
    <script src="./js/test.js"></script>
  </body>
</html>

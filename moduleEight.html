<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 8</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Node js</h3>
      <p>
        Легкая и эффективная среда выполнения JS. Позволяет писать
        высокопроизводительные серверные приложения и инструменты. Построена на
        JS движке V8 и написана на С++. <br />
        Сначала Node js создавалась как серверная среда обитания для приложений,
        но разработчики начали использовать ее для создания инструментов,
        помогающих автоматизировать выполнение локальных задач. В результате
        новая экосистема инструментов возникшая вокруг Node js привела к
        трансформации процесса front end разработок. <br />
        После установки в терминале будет доступна команда node. Чтобы убедиться
        что установка прошла успешно, проверьте версию, запустив команду node
        --version.
      </p>
      <p class="information">
        <b>Команда терминала</b><br />
        pwd (путь) - указывает путь к текущей папки <br />
        ls (list) - детальная информация содержимого в папках с указанием пути.
        ls -l, ls -la <br />
        clear - очистка терминала <br />
        Навигация - cd (change directory) - ".." - выход на один уровень вверх
        "на два уровня вверх ../../" <br />
      </p>
      <h3 class="title">JS вне браузера</h3>
      <p>
        Node js позволяет выполнять js код вне браузера. При открытии любого
        терминала выполнив команду node запустится REPL (read eval print loop) -
        интерактивная среда выполнения js кода. <br />Пакетный менеджер NPM
        <br />
        Чтобы использовать все разнообразие инструментов или пакетов node js нам
        необходимо возможность устанавливать и управлять ими. Для этого создан
        NPM (node package manager). Он устанавливает нужные пакеты и
        обеспечивает удобный интерфейс для работы с ними.
      </p>
      <ul>
        NPM состоит из трех основных компонентов
        <li>
          Сайт npmjs.com - используется для поиска и ознакомления с
          документацией пакетов
        </li>
        <li>
          Интерфейс комендной строки CLI - запускается из терминала и
          предоставляет набор команд для работы с реестром и пакетами, позволяет
          создавать скрипты для запуска в терминале
        </li>
        <li>
          Реестр пакетов - крупная, общедоступная база данных инструментов
          разработчиков
        </li>
      </ul>
      <p>
        Пакет (package) - небольшая js библиотека, решающая специфическую
        задачу. Пакеты пишут сами разработчики и делается с сообществом. Такой
        подход упрощает работу. <br />
      </p>
      <ul>
        Команды NPM. Пречислим основные команды и рассмотрим их.
        <li>
          npm init - инициализирует npm в проэкте и создает файл package.json
        </li>
        <li>
          npm install - устанавливает все зависимости перечисленные в
          package.json
        </li>
        <li>
          npm list --depth=0 - выводит в терминале список локально установленных
          пакетов с номерами их версий без зависимости
        </li>
        <li>
          npm install [package-name] - устанавливает пакет локально в папку
          node_moduls
        </li>
        <li>
          npm uninstall [package-name] - удаляет пакет, установленный локально и
          обновляет package.json
        </li>
        <li>
          npm start и npm test - запускает скрипт старт или тест, расположенный
          в package.json
        </li>
        <li>
          npm run [custom-script] - запускает кастомный скрипт, расположенный в
          package.json
        </li>
        <li>
          npm outdated - используется для поиска обновлений, обнаружит
          совместимые версии програмно и выведет список доступных обновлений
        </li>
        <li>
          npm update - обновит все пакеты до максимально разрешенной версии
        </li>
      </ul>
      <h3 class="title">Инциализация проэкта</h3>
      <p>
        Каждый проэкт начинается с создания файлов package.json. Он отслеживает
        зависимости, содержит служебную информацию, позволяет писать npm скрипты
        и служит инструкцией при создании нового проэкта на основе уже готовых
        настроек. Файл package.json можно создать npm командой init -
        инициализация проэкта в этой папке. Вам будет предложено ввести название
        проэкта, версию, описание и т.д. Можно нажать просто enter пока не будет
        создан package.json и размещен в папке проэкта. Чтобы не нажимать enter
        пропуская пустые поля использется команда init --yes. Флаг это
        дополнительная настройка для команды. <br />
        <b>npm init --yes</b> <br />
        У каждого флажка есть псевдоним, его сокращенная запись. Псевдоним флага
        --yes --y, поэтому команды npm init --yes и npm init --y делают одно и
        тоже <br />
        Будет создан package.json со значениями по умолчанию. Чтобы установить
        эти значения выполните в терминале следующие команды
      </p>
      <p class="information">
        npm config set init.author.name "name" <br />
        npm config set init.author.email "email"
      </p>
      <p>
        Файл package.json можно изменить вручную или выполнить npm init еще раз.
        Если открыть package.json он будет примерно выглядет как обычный объект.
        Это всего лишь мета данные о проэкте
      </p>
      <h3 class="title">NPM скрипты</h3>
      <p>
        Скрипты позволяют запускать для использования установленные пакеты.
        Используя npm скрипты можно создавать целые системы сборок проэктов.
        Автоматизирует запуск index.js. Для этого в файле package.json добавим
        скрипт запуска старт.
      </p>
      <p class="bg">
        { <br />
        "scripts": {<br />
        "start": "node test.js"<br />
        }<br />
        }<br />
      </p>
      <p>Теперь мы можем его запускать через команду npm start</p>
      <h3 class="title">Установка пакетов</h3>
      <p>
        Один из предоставляемых возможностей npm - установка пакетов, которые
        извлекаются из реестра и распаковываются в папку node_moduls в корне
        проэкта. После создания файла package.json можно добавлять зависимости в
        проэкт <br />
        Зависимостью называют npm пакет используемый в разработке. Это
        всевозможные утилиты и библиотеки. Установим библиотеку validator js для
        валидации строк, например ввод пользователя в поля форм
      </p>
      <p class="bg">npm install validator</p>
      <p>
        Npm загрузил валидатор и пометил его в node_moduls, в котором будут
        находится все внешние зависимости <br />
        package-lock.json это журнал снимков дерева в зависимости от проэкта. Он
        гарантирует что команда разработчиков использует одинаковые версии
        зависимости. Npm автоматически обновляет его при добавлении, удалении и
        обновлении пакетов. <br />
        В package.json появляется новая зависимость в поле dependencies. Это
        означает что валидатор версия 13.0.0 была установлена как зависимость и
        готова к работе. Пакеты постоянно обновляются и версия может отличаться,
        для этого и нужны поля замисимости
      </p>
      <p class="bg">
        "dependencies": { <br />
        "validator": "^13.12.0"<br />
        }<br />
      </p>
      <p>
        Чтобы получить интерфейс пакетов в node js коде необходимо вызвать
        функцию require("module name") передавая аргументом имя модуля без
        определения пути. Это называется абсолютный импорт. Путь не требуется,
        поскольку по умолчанию поиск модуля будет происходить в папке
        node_moduls. Результатом своего выполнения функции вернет интерфейс
        модуля с методами или просто функцию, зависит от пакета.
      </p>
      <p class="bg">
        const validator = require('validator'); <br />
        const validatorEmail = email => {<br />
        return validator.isEmail(email);<br />
        };<br />
        console.log('Это почта валидна? :', validatorEmail('mail@mail.com'));
        //Это почта валидна? : true<br />
        console.log('Это почта валидна? :', validatorEmail('mail.com'));//Это
        почта валидна? : false<br />
      </p>
      <h3 class="title">Удаление пакетов</h3>
      <p>
        Предположим что версия валидатора вызывает проблемы с совместимостью. Мы
        можем удалить этот пакет и поставить более старую версию
      </p>
      <p class="bg">
        //validator 13.0.0 <br />
        npm uninstall validator <br />
        // Устанавливаем более старую версию
        <br />
        npm install validator@11.0.0
      </p>
      <p>
        Установка пакетов определенной версии используется в коммерческих
        проэктах для того чтобы гарантировать работу кодовой базы и возможность
        долгосрочной поддержки.
      </p>
      <h3 class="title">Типы зависимостей</h3>
      <p>
        Зависимости проэкта. Некоторые будут использованы в финальном продукте.
        Другие необходимы только на стадии разработки, а есть и такие котрые
        необходимо использовать независтмо от проэкта, именно для этого команды
        npm install и npm uninstall имеют три флага ---
      </p>
      <ul>
        <li>
          -save - указывает что прибавляется зависимость, которая войдет в
          финальный продукт. Пакет будет установлен локально в папку node_moduls
          и будет добавлена запись в поле dependencies в package.json
        </li>
        <li>
          -save-dev - указывает что прибавляется зависимость разработки, пакет
          будет установлен локально в папку node_moduls и будет добавлена запись
          в поле devDependencies в package.json
        </li>
        <li>
          -global - указывает что добавляется глобальная зависимость, т.е для
          любого проэкта. Проэкт будет устанослен глобально в систему
        </li>
        <li>
          <b
            >Если не указывать флаг будет использован --save по умолчанию.
            Удаляя пакет необходимо указывать правильный флаг, так же как для
            установки. Не устанавливайте пакеты глобально если работаете с
            другими разработчиками</b
          >
        </li>
      </ul>
      <h3 class="title">Управление версиями пакетов</h3>
      <p>
        Пакеты имеют соответствующий номер версии
        <b>(на сайте npm в описании пакета вкладка version)</b>
      </p>
      <ul>
        <li>
          npm outdated - используется для поиска обновлений, обнаружит
          совместимые версии программы
        </li>
        <li>
          npm update - обновляет все пакеты до максимально разрешенной версии
        </li>
        <li>npm update [имя пакета] - обновляет указанный пакет</li>
      </ul>
      <h3 class="title">Управление кешем</h3>
      <p>
        После установки пакета npm сохраняется его копия в кеше, поэтому при
        след установке вам не нужно снова загружать его из интернета. Кеш
        хранится в папке .npm вашего домашнегшо каталога. <br />
        Эта папка с течением времени засоряется старыми пакетами, ее желательно
        чистить хотя бы 2 раза в год. Кеширование полезно т.к оно ускоряет
        процесс установки уже использованых пакетов. <br />
        <b>npm cache clean</b>
      </p>
      <h3 class="title">Модульность кода</h3>
      <p>
        Концеепция модулей как метод организации кода была давно. С увеличением
        проэкта и кодовой базы ее пытаются разбить на файлы, в каждом из котором
        описывается отдельный функционал. Модульный код помогает в организации
        обслуживания, тестирования и самое главное управление зависимостями.
        Важнейшее приимущество модулей - это поддержка, пространство имен и
        повторное использование <br />
        <b>Поддержка</b> - хорошо разработанный модуль максимально уменьшит
        зависимость от других частей кода, это позволит расширить функционал
        приложений не опасаясь нарушить его работу в целом. Обновление одного
        модуля гораздо проще если один модуль самодостаточен <br />
        <b>Пространство имен</b> - переменные, не входящие в область видимости
        функций являются глобальными. В результате как правило происходит
        загрязнение пространства имен где полностью не связаный код разделяет
        глобальные переменные. Модули позволяют избежать загрязнение
        пространства имен, создавая отдельную область видимости для переменных
        <br />
        <b>Повторное использование</b>. Все разработчики копировали готовый код
        в новые проэкты изменяя его под специфику проэкта. Это очевидно огромная
        трата времени. Гораздо лучше когда есть модуль, который можно
        использовать снова и снова без необходимости знать что либо об его
        окружении, в котором он используется. <br />
        <b>Сборка модулей</b> <br />
        <b>Собирание модулей</b> - это процесс конкатинации группы модулей и их
        зависимостей в один или группу файлов. <br />
        Обычно код делят на папки и файлы. К тому же нужно подключать внешние
        библиотеки. В результате этого каждый файл нужно добавить в основной
        HTML файл теге script, который затем загружается браузером <br />
        Наличие отдельных тегов script для каждого файла означает что браузер
        будет загружать каждый файл отдельно, что отрицательно сказывается на
        скорости загрузки страницы. Чтобы устранить эту проблему файл
        объеденяется в один или несколько файлов с целью уменьшить кол-во
        запросов. Но остается неувязка управления зависимостей между модулями.
        <br />
        Если используется система модулей такие как CommonJS и ESM необходимо
        использовать инструмент для преобразования правильно упорядоченный и
        доступный для браузера код. Именно здесь наченает действовать webpack и
        другие бандлеры. <br />
        <b>Модули ECMAScript(EMS)</b> до недавнего времени небыло встроенной
        модульной системы. EMS имеет компактный декларативный синтаксис и
        возможность асинхронной загрузки. ES модуль это фрагмент js кода, котрый
        используется много раз и экпортирует определенные объекты, делая их
        доступными для других модулей. <br />
        Каждый js файл хранит код в уникальном контесте модуля и импортирует в
        необходимую ему зависимости и экспортирует все, что другие модули должны
        импортировать. Операция экпорта и импорта реализуется конструктором
        import и export. Есть два очевидных приимущества этих концепций -
        предотвращение загрязнения глобального пространства имен и явное
        указание зависимостей <br />
        Новая систама модулей отличается от СommonJS - прежде всего это
        стандарт, а значит со временем будет полностью поддерживаться браузером
        нативно без доп инструментов. Однако сейчас браузерная поддержка
        неполная, поэтому ESM используется вместе с инструментами сборки модулей
        такими как webpack, parcel и другими<br />
        <b
          >ESM разработаны на основе статического анализа, это означает что при
          импорте модулей модуль обрабатывается во время компиляции, т.е до
          запуска скрипта, это позволяет удалять экспорт не используемый другими
          модулями прежде чем запускать скрипт, что может привести к
          значительной экономии веса js файла снизив нагрузку на браузер. Это
          называется Tree shaking и выполняется бандлерами автоматически при
          сборке js кода.</b
        ><br />
        <b>Named export</b>. Модуль может экспортировать несколько сущностей,
        которые отличаются своими именами и называются "именуемыми экспортами".
        Чтобы имортировать их в другой модуль необходимо знать имена
        импортируемых сущностей которые мы хотим импортировать <br />
        Первый способ - это использование ключевого слова export перед всеми
        сущностями, которые необходимо экспортировать. Они будут добавлены как
        свойство экпортированых объектов. При импорте мы деструктуризируем
        свойство импортируемого объекта. <br />
      </p>
      <p class="bg">
        const fn = Math.fn; <br />
        export const square = x => x * x;<br />
        export const diag = (x, y) => fn(square(x) + square(y));<br /><br />
        import { square, diag } from './js';<br />
        console.log(square(10));<br />
        console.log(diag(15, 20));<br />
      </p>
      <p>
        Второй способ это явно указать объект со свойствами для экспорта. <br />
      </p>

      <p class="bg">
        const fn = Math.fn; <br />
        const square = x => x * x;<br />
        const diag = (x, y) => fn(square(x) + square(y));<br /><br />

        export { square, diag };<br />
      </p>
      <p>
        Следующий синтаксис импортирует все экспорты модуля как объект с
        указаным именем, это называется namespace import.main.js
      </p>
      <p class="bg">
        import * as module_name from "./путь/имя_файла" <br />
        console.log(module_name.square(4)); <br />
        console.log(module_name.diag(5, 10));
      </p>
      <p>
        <b>Экспорт по умолчанию - export default</b><br />
        Часто модуль эспортирует всего одну сущность. Такой экспорт удобен для
        импорта, экспорт по умолчанию - самое главное экспортируемое значение,
        которое может быть чем угодно: переменной, функцией, классом и т.д
        <br />
        <b>name_function.js</b>
      </p>
      <p class="bg">
        export default function function_name(args){ <br />
        // ... <br />
        }<br />
      </p>
      <p class="bg">
        <b>myClass.js</b>
        export default class class_name{ <br />
        // ... <br />
        }<br />
      </p>
      <p class="bg">
        <b>main.js / app.js</b>
        import function_name from "./..." <br />
        import class_name from "./..." <br />
        function_name() <br />
        const inst = new class_name();
      </p>
      <p>
        Испельзуйте именуемый экспорт если необходимо экспортировать несколько
        сущностей, а экспорт по умолчанию для экспорта одной сущности, хотя
        можно использовать экспорт по умолчанию и именуемый экспорт в одном
        файле. Хорошей практикой будет выбрать один стиль для каждого модуля.
      </p>
      <h3 class="title">Знакомство с webpack</h3>
      <p>
        Webpack это сборщик JS модулей, менеджер модульных зависимостей, который
        анализирует дерево зависимостей и создающий один или несколько
        результирующих файлов, содержащих всю кодовую базу проэкта, выстраивает
        порядок подключения модулей, минифицирует, упаковывает и многое другое.
      </p>
      <img src="./images/webpack.jpg" alt="" />
      <p>
        Webpack стал одним из самых важных веб инструментов веб разработчика. В
        первую очередь это менеджер модульных зависимостей приложения и сборщик
        JS файлов, но может трансформировать все ресурсы, например HTML, CSS,
        SASS и т.д, оптимизировать изображения, компилировать шаблоны, запускать
        локальный веб сервер для разработки и многое другое. <br />
        <b>Принцип работы</b><br />
        Предположим что у нас есть приложение, которое может выполнить 2 простых
        математических задачи - суммировать и умножить. Мы решили разделить эти
        функции на отдельные файлы (модули) для упрощения поддержки кодовой
        базы. Таким образом в index.html скрипты будут подключены в такой
        последовательности.
      </p>
      <p class="bg">
        <b>index.html</b><br />
        &lt;script src=&quot;sum.js&quot;&gt;&lt;/script&gt;<br />
        &lt;script src=&quot;multiply.js&quot;&gt;&lt;/script&gt;<br />
        &lt;script src=&quot;index.js&quot;&gt;&lt;/script&gt;<br />
      </p>
      <p>
        Допустим код из sum.js используется в multiply.js и index.js, а код из
        multiply.js используется только в index.js
      </p>
      <img src="./images/shema_module.jpg" alt="" />
      <p>
        Если ошибится в последовательности подключения скриптов в index.html то
        есть если index.js подключен перед любой из других зависимостей или если
        файл sum.js добавлен после multiply.js возникнет ошибка. Теперь
        представим что мы масштабируем это к реальному проэкту, могут быть сотни
        зависимостей, подключение будет сложным <br />
        Webpack преобразует зависимости в модули и сшит в один или несколько
        файлов, каждый модуль будет иметь закрытое пространство имен и
        подключаться в нужное время и в правильном порядке. Gulp еще занимает
        достойное место в инструментарии разработчика и для некоторых проэктов
        функционал webpack не требуется, хотя он может работать безупречно с
        ним. Несмотря на то, что кривая обучения может быть выше при более
        сложных настройках, webpack незаменим если вы используете современные
        библиотеки и фреймворки для разработки, такие как react, vue, angular и
        т.д. <br />
        <b>Формат JSON</b><br />
        JSON (java script object notation) - современный текстовый формат
        хранения и передачи структурированых данных в текстовом формате.
        Первичный объектообразный синтаксис JSON очень удобен. Именно в этом
        формате данные будут приходить и отпрвляться на сервер, хранится в
        локальных хранилищах и т.д <br />
        JSON это не объект, а его строчное отображение. Приведем пример JSON
        файла - синтаксис похож на объект, за исключением того что ключи это
        всегда строки в двойных ковычках. Строчные значения так же обязательно
        должны быть взяты в двойные кавычки. <b>Значения типов могут быть:</b>
        <b>string, number, object, array, boolean, null</b> <br />
        <b>user.json</b><br />
        { <br />
        "name": "Josh",<br />
        "weight": 175,<br />
        "age": 30,<br />
        "eyecolor": "brown",<br />
        "isHappy": true,<br />
        "cars": ["Chevy", "Honda"],<br />
        "favoriteBook": {<br />
        "title": "The Last Kingdom",<br />
        "author": "Bernard Cornwell",<br />
        "rating": 8.38<br />
        }<br />
        }<br />
        js и json прекрасно работают вместе благодаря методам встроенного класса
        json превращающий js объект в json и наоборот, в не зависимости от того
        что у вас есть можно легко получить обратное. <br />
        <b>Метод JSON.stringify()</b><br />
        Принимает значение и преобразует его в JSON, значение может быть число,
        boolean, null, массив или объект. Строки это уже валидный JSON, поэтому
        в их преобразовании нет смысла
      </p>
      <p class="bg">
        const dog = { <br />
        name: 'Sharik',<br />
        age: 12,<br />
        state: 'Is Happy',<br />
        barking: true,<br />
        };<br /><br />

        const dogJSON = JSON.stringify(dog);<br />
        console.log(dogJSON); //{"name":"Sharik","age":12,"state":"Is
        Happy","barking":true}<br />
      </p>
      <p>
        Результат вызова JSON.stringify(dog) это валидный JSON, который может
        быть сохранен в файл или передан сетью (отправка на сервер). Не любой js
        объект может быть преобразован друг в друга в JSON. Например если у
        объекта есть методы то при преобразовании они будут проигнорированы.
      </p>
      <p class="bg">
        const dog = { <br />
        name: "Mango",<br />
        age: 3,<br />
        isHappy: true,<br />
        bark() {<br />
        console.log("Woof!");<br />
        },<br />
        };<br /><br />

        const dogJSON = JSON.stringify(dog);<br />
        console.log(dogJSON);// "{"name":"Mango","age":3,"isHappy":true}"<br />
      </p>
      <p>
        Так же при попытке превратить функцию в JSON результатом будет undefind
      </p>
      <p class="bg">
        JSON.stringify( () => console . log ( "Ну, это неудобно" )); //
        undefined <br />
      </p>
      <p>
        <b>Метод JSON.parse()</b><br />
        Чтобы получить с JSON валидное значение JS его необходимо распарсить.
        Эта операция обратная преобразованию в строку(stringify). Теперь когда
        dog это валидный объект с ним можно работать обычным образом.
      </p>
      <p>
        const dogJSON = JSON.stringify(dog); <br />
        console.log(dogJSON); // "{"name":"Mango","age":3,"isHappy":true}"<br /><br />

        const json = '{"name":"Mango","age":3,"isHappy":true}';<br />
        const dog = JSON.parse(json);<br />
        console.log(dog);//{ name: 'Mango', age: 3, isHappy: true }<br />
        console.log(dog.name);//'Mango'<br />
      </p>
      <p>
        <b>Обработка ошибок</b><br />
        Если методом класса JSON передать невалидный JSON то они выкинут ошибку
        и весь скрипт упадет. Во избежание этого используется конструкция try
        catch
      </p>
      <p class="bg">
        try { <br />
        // Код, который может вызвать ошибку во время выполнения <br />
        } catch ( error ) {<br />
        // Обработка ошибок<br />
        }<br />
      </p>
      <ul>
        <li>Сначала выполняется код внутри блока try</li>
        <li>
          Если ошибки отсутствуют блок catch игнорируется и управление
          передается дальше
        </li>
        <li>
          Если в блоке try произошла ошибка, его выполнение приостанавливается и
          инторпритатор переходит в блок catch
        </li>
      </ul>
      <ul>
        Переменна error это объект ошибки с информацией о случившимся. у этого
        объекта есть несколько полезных свойств:
        <li>name - тип ошибки. Для ошибки парса - это sintax error</li>
        <li>message - уведомление о деталях ошибки</li>
        <li>
          stack - стек вызова функции на момент ошибки, используется для отладки
        </li>
      </ul>
      <p>
        Например parse строки приведет к такому сценарию, потому что строка с
        символами - это не валидный JSON, поскольку не может быть преобразован в
        валидное JS значение.
      </p>
      <p class="bg">
        // Скрипт завершится сбоем во время анализа <br />
        const data = JSON.parse("Ну, это неудобно");<br />
        console.log("❌ Вы не увидите этот лог");<br />
      </p>
      <p>
        Используя конструкцию try catch мы можем обработать это исключение таким
        образом чтобы скрипт продолжил работать даже в случае ошибки.
      </p>
      <p class="bg">
        try { <br />
        const data = JSON.parse('Well, this is awkward');<br />
        } catch (error) {<br />
        console.log(error.name); // "SyntaxError"<br />
        console.log(error.message); // Unexpected token W in JSON at position
        0<br />
        }<br /><br />

        console.log('✅ This is fine, we handled parse error in
        try...catch');<br />
      </p>
      <p>
        То же будет при попытке парса не валидного JSON, который например может
        прийти из бекЭнда или может прочтен из файла. В примере в свойстве
        username не хватает двойных кавычек
      </p>
      <p class="bg">
        try { <br />
        const data = JSON.parse('{username: "Mango"}');<br />
        } catch (error) {<br />
        console.log(error.name);// "SyntaxError"<br />
        console.log(error.message);// "Unexpected token u in JSON at position
        1"<br />
        }<br /><br />

        console.log("✅ This is fine, we handled parse error in
        try...catch");<br />
      </p>
      <p>
        <b>Фазы выполнения кода</b><br />
        JS код выполняется не сразу. Для начала нужно прочитать код и узнать
        возможно ли его вообще выполнить. <br />
        <b>Фаза интарпритации или оценки</b> <br />
        Подготовка перед выполнением кода находит синтаксические ошибки, ошибки
        типизации и т.д. Т.е код еще не производится, только оценивается. Если
        эта фаза прошла успешно это как минимум означает что в коде отсутствуют
        синтаксические ошибки и его можно запустить для выполнения. <br />
        <b>Фазы выполнения кода (runtime)</b><br />
        Скрипт начинает выполняться, выполняются инструкции вызова функции и
        оценки выражения. Происходит поиск необходимых идентификаторов в
        соответствующих областях видимости. <br />
        Если эта фаза завершилась успешно значит скрипт написан без явных ошибок
        и завершил свою работу. На этой фазе могут быть ошибки связаные с
        отсутствующими свойствами и переменными, преобразование типов и т.д т.е
        нечто что происходит только во время выполнения кода.
      </p>
      <h3 class="title">Web хранилище</h3>
      <p>
        Каждый раз когда вы меняете цветовую тему между светлой и темной,
        просматриваете видео, добавляете товар в корзину, открываете и
        закрываете сайт бар, популярные веб приложения запоминают состояние
        интерфейса и в след посещении восстанавливают его. <br />
        По умолчанию состояние интерфейса сохраняется в памяти вкладки браузера
        и теряется после закрытия веб приложения. Чтобы избежать этого
        необходимо сохранить данные о состоянии интерфейса между посещениями
        страницы. На помощь приходит хранилище информации о состоянии веб
        приложения на компьютере пользователя. <br />
        <b>API Web хранилище</b> <br />
        Веб хранилище состоит из локального хранилища (localStorage) и хранилище
        сеансов (sessionStorage). Обеспечивает способ хранения данных интуитивно
        понятным образом в виде пары ключ:значение. Технически в веб хранилище
        можно записать только строки, но это не проблема если использовать
        методы класса JSON для преобразования сложных типов. Веб хранилище не
        записыывает методы объекта или функции, только данные. <br />
        Локальное хранилище (localStorage) - уникальное для каждого веб
        приложение и будет одинаковое для нескольких вкладок, в которых оно
        запущено (веб приложение). Данные в локальном хранилище не удаляются,
        даже после закрытия браузера или отключения компьютера. Чтобы их удалить
        необходимо использовать JS. <br />
        Хранилище сеансов (sessionStorage) похоже на локальное, оно тоже
        уникальное для каждого веб приложения, но время жизни сохраненных данных
        ограничено сессией вкладки браузера. Как только пользователь закрывает
        вкладку или браузер - данные очищаются. На практике хранилище сеансов
        используется гораздо реже. <br />
        Веб хранилища не хранят пароли, номера банковских карт и подобную
        конфидициальную информацию. Если вредоносный скрипт получит доступ к веб
        страницы, он без проблем прочтет эти данные. <br />
        <b>Локальное хранилище</b><br />
        Позволяет хранить данные без истечения срока действия в формате пары
        ключ:значение на компьютере пользователя и читать их при первом
        посещении страницы. Локальное хранилище и хранилище сессии это часть
        браузера, поэтому они доступны как свойство объекта window, имеют
        одинаковый набор свойств и методов и отличаются только поведением.
      </p>
      <ul>
        <li>
          <b>setItem(key, value)</b> - создает новую или обновляет уже
          существующую запись в хранилище
        </li>
        <li>
          <b>getItem(key)</b> - возвращает из хранилища значение с ключом key
        </li>
        <li>
          <b>removeItem(key)</b> - удаляет из хранилища запись с ключом key
        </li>
        <li><b>clear()</b> - полсностью очищает все записи хранилища</li>
        <li><b>length</b> - кол-во записей в хранилище</li>
      </ul>
      <p>
        <b>Сохранение</b><br />
        Используя метод setItem(key, value) можно добавить новую запись в виде
        пары ключ:значение
      </p>
      <p class="bg">
        localStorage.setItem("Ui-theme", "light"); <br />
        localStorage.setItem("sidebar", "expanded");<br />
        localStorage.setItem("notification-level", "mute");<br />
      </p>
      <p>
        Если необходимо сохранить что-либо кроме строки, например массив или
        объект, необходимо превратить их в строку методом JSON.strigify()
      </p>
      <p class="bg">
        const settings = { <br />
        theme: 'dark',<br />
        isAuthenticated: true,<br />
        options: [1,2,3],<br />
        };<br />
        localStorage.setItem("settings", JSON.stringify(settings));<br />
      </p>
      <p>
        <b>Чтение</b><br />
        Метод getItem(key) позволяет прочитать из хранилища запись с ключом key.
        Если в хранилище отсутствует запись с таким клучом метод возвращает
        null. Если значение это обычная строка нет необходимости его парсить.
      </p>
      <p class="bg">
        localStorage.setItem('Ui-theme', 'dark'); <br /><br />

        const theme = localStorage.getItem("Ui-theme");<br />
        console.log(theme);//"dark"<br />
      </p>
      <p>
        В противном случае необходимо распарсить значение методом JSON.parse()
        чтобы получить валидные данные.
      </p>
      <p class="bg">
        const savedSettings = localStorage.getItem("settings"); <br />
        const parsedSettings = JSON.parse(savedSettings);<br />
        console.log(parsedSettings);// settings object<br />
      </p>
      <p>
        Не забывайте использовать конструкцию try-catch с методом JSON.parse()
        чтобы избежать падение скрипта если вдруг прочитали не валидный JSON.
      </p>
      <p>
        <b>Удалене</b><br />
        Метод removeItem(key) удаляет из хранилища уже существующую запись с
        ключем key.
      </p>
      <p class="bg">
        localStorage.setItem('Ui-theme', 'dark'); <br />
        console.log(localStorage.getItem("Ui-theme"));//dark<br /><br />

        localStorage.removeItem("Ui-theme");<br />
        console.log(localStorage.getItem('Ui-theme'));//null<br />
      </p>
      <p>
        <b> Очищение хранилища</b><br />
        Операция полной очистки хранилищ - описана поскольку может нарушить
        записи, сделаные другими разработчиками проэкта. Однако если вы хотите
        полностью очистить хранилище нужно вызвать метод clear().
      </p>
      <p class="bg">
        localStorage.setItem("Ui-theme", "light"); <br />
        localStorage.setItem('sidebar', 'expanded');<br />
        localStorage.setItem('notification-level', 'mute');<br /><br />

        console.log(localStorage.getItem("Ui-theme"));// light<br />
        console.log(localStorage.getItem("sidebar")); // expanded<br />
        console.log(localStorage.getItem('notification-level')); //mute<br /><br />

        localStorage.clear();<br />
        console.log(localStorage.getItem("Ui-theme"));// null<br />
        console.log(localStorage.getItem("sidebar")); // null<br />
        console.log(localStorage.getItem('notification-level')); //null<br />
      </p>
      <p>
        <b>Сохраняем сообщение</b><br />
        Создадим форму для ввода сообщения и будем хранить его в localStorage по
        submit. Измените значение тектового поля и нажмите кнопку save. Текст в
        поле вывода изменится на введенный. Перезагрузите страницу и вы увидите
        тот же самый текст, хотя вы ничего не вводили. При загрузки страницы мы
        берем из localStorage последнее сохраненное значение. Сначала такая
        запись в хранилище отсутствует, поэтому будет выведена пустая строка.
      </p>
      <form class="feedback-form">
        <textarea name="message"></textarea>
        <button type="submit">Send feedback</button>
      </form>
      <p>
        Просмотреть содержимое веб хранилища можно в инструментах разработчика в
        вкладке application. Там же мы можем вручную удалять или добавлять
        записию На практике это используется при разработки и отладки
        приложения.
      </p>
      <img src="./images/application_localStorage.jpg" alt="" />
      <p>
        <b>Сервис для localStorage</b><br />
        Для того чтобы сократить кол-во повторяющегося кода при работе с веб
        хранилищем можно написать сервис со стандартными методами например save
        и load. Они будут абстрагировать повторяющийся код, проверки ошибок,
        парса и подобную рутину.
      </p>
      <p class="bg">
        const save = (key, value) => { <br />
        try {<br />
        const serializedState = JSON.stringify(value);<br />
        localStorage.setItem(key, serializedState);<br />
        } catch (error) {<br />
        console.error('Ошибка установки состояния: ', error.message);<br />
        }<br />
        };<br /><br />

        const load = key => {<br />
        try {<br />
        const serializedState = localStorage.getItem(key);<br />
        return serializedState === null ? undefined :
        JSON.parse(serializedState);<br />
        } catch (error) {<br />
        console.error('Ошибка получения состояния: ', error.message);<br />
        }<br />
        };<br /><br />

        export default { save, load };<br />
      </p>
      <p>
        Теперь мы можем безопасно добавлять и читать записи из локального
        хранилища.
      </p>
    </section>
    <!-- <script type="module" src="./js/app.js"></script> -->
    <script src="./js/moduleEight.js" type="module"></script>
  </body>
</html>

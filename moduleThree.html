<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Document</title>
  </head>
  <body>
    <main>
      <section class="container">
        <h3 class="title">Объекты</h3>
        <p>
          Объекты позволяют описать и сгруппировать хар-ки в определенную
          сущность пользователя, книги, продукты в магазине, чего угодно.
          Объекты называют словарями, т.е они содержат термины (свойства) и
          определения(значения) <br />
          <b>Создание объекта</b><br />
          Для объявления используются {}
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };
        </p>
        <p>
          Во время создания объекта можно добавлять свойства, которые
          описываются парами ключ: значение. Ключем называют имя свойства и это
          всегда строка. Значением свойства могут быть любые типы, примитивы,
          массивы, були, функции, объекты и т.д. Свойства разделяются запятой
        </p>
        <ul>
          <b>Правила нейминга ключей</b>
          <li>Если ключи взятые в "" то это может быть произвольная строка</li>
          <li>
            Если кавычек нет то есть ограничения - имя без пробела, начинается
            буквой или символами _ и $
          </li>
        </ul>
        <p>
          <b>Вложенные свойства</b>. Значением свойства может быть другой объект
          для того чтобы хранить вложенные и сгруппированные данные. Например,
          статистика пользователя соц сети состоит из кол-ва отслежевателей,
          просмотров и ругательств и сохранять эти данные удобнее всего в виде
          объекта. То же с местом раположения - отдельно страна и город
        </p>
        <p class="bg">
          const user = { <br />
          name: "Vasya Pupkin",<br />
          tag: "#Vasya",<br />
          location: {<br />
          country: "England",<br />
          city: "London",<br />
          },<br />
          stats: {<br />
          folowers: 15,<br />
          views: 2,<br />
          like: 1,<br />
          }<br />
          }
        </p>
        <p>
          В будущем это можно использовать для поиска пользователей, города,
          минимальному и максимальному кол-ву подписчиков и т.д <br /><br />
          <b>Доступ к свойству через точку</b><br /><br />
          Первый способ получить доступ к свойству объекта это синтаксис
          <b>объект.имя_свойство</b>. Синтаксис через точку используется в
          большинстве случаев и уместен тогда, когда мы заранее знаем имя (ключ)
          свойства, к которому хотим получить доступ <br /><br />
          На месте обращения будет возвращено свойство с таким именем. Если
          объект не содержит свойтво с таким именем на месте обращения будет
          возвращено undefind.
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          const bookTitle = book.title;<br />
          console.log(bookTitle);//Kingdom<br />
          const bookAuthor = book.author;<br />
          console.log(bookAuthor);//Name Lastname<br />
          const bookPrice = book.price;<br />
          console.log(bookPrice);//undefind<br />
        </p>
        <p>
          <b>Обращение к вложенным свойствам</b>
          <br />
          Для доступа к вложенным свойствам используется цепочка запросов через
          точку. Например чтобы получить значени страны пользователя пишем
          user.location.country. Это ссылка к объекту в свойстве location, а
          user.location.country в этом объекте. Таким образом точка указывает на
          следуюзее вложение
        </p>
        <p class="bg">
          const user = { <br />
          name: 'Vasya Pupkin',<br />
          tag: '#Vasya',<br />
          location: {<br />
          country: 'England',<br />
          city: 'London',<br />
          },<br />
          stats: {<br />
          folowers: 15,<br />
          views: 2,<br />
          like: 1,<br />
          },<br />
          };<br /><br />

          const userLocation = user.location.country;<br />
          console.log(userLocation);//England<br />
          const userStatus = user.stats.friends;<br />
          console.log(userStatus);//undefind<br />
        </p>
        <p>
          Если значение свойства это массив то в нашем примере user.hobbies
          обращение к этому массиву. Дальше можно получить доступ к его
          элементам через [] и index, переиспользовать свойства и методы
        </p>
        <p class="bg">
          const user = { <br />
          name: 'Vasya Pupkin',<br />
          tag: '#Vasya',<br />
          location: {<br />
          country: 'England',<br />
          city: 'London',<br />
          },<br />
          stats: {<br />
          folowers: 15,<br />
          views: 2,<br />
          like: 1,<br />
          },<br />
          hobbies: ['Swiming', 'Music', 'Box'],<br />
          };<br /><br />

          const hobbie = user.hobbies;<br />
          console.log(hobbie); //[ 'Swiming', 'Music', 'Box' ]<br />
          const firstHobbie = user.hobbies[0];<br />
          console.log(firstHobbie); //"Swiming"<br />
          const lengthHobie = user.hobbies.length;<br />
          console.log(lengthHobie);//3<br />
        </p>
        <p>
          Обращение к свойствам через [] второй способ получить доступ к
          свойству объекта это синтаксис ["имя свйоства"]. Похоже на обращение к
          элементу массива с разницей в том, что в скобках указывается не индекс
          элемента а имя свойства в виде строки <br /><br />
          Синтаксис [] используется значительно реже, в случае когда имя
          свойства заранее не известно или хранится в переменной например как
          значение параметров функции <br /><br />
          На месте обращения будет возвращено значение свойства с таким именем.
          Если в объекте отсутствует свойство с таким именем вернется undefind.
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          const bookTitle = book['title'];<br />
          console.log(bookTitle); //Kingdom<br /><br />

          const propKey = 'author';<br />
          const bookAuthor = book[propKey];<br />
          console.log(bookAuthor);//Name Lastname<br />
        </p>
        <p>
          <b>Изменение значения свойств</b><br />
          После создания объекта значение его свойства можно изменить, для этого
          нужно обратиться к нему по имени, например через точку и присвоить
          новое значение
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          book.title = 'Castle';<br />
          book.isPublic = false;<br />
          book.genres.push('Drama'); <br /><br />

          console.log(book.title);//Castle<br />
          console.log(book.isPublic);//false<br />
          console.log(book.genres);//[ 'History', 'Horror', 'Comedy', 'Drama'
          ]<br />
        </p>
        <p>
          <b>Добавление свойства</b><br /><br />
          Операция добавления нового свойства после создания объекта ничем не
          отличается от изменения значения уже существующего свойства. Если во
          время записи значения по имени такого свойства нет, оно будет создано
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          book.pageCount = 600;<br />
          book.originalLanguage = "En";<br />
          book.translations = ["Uk", "Ru", "Pl"];<br /><br />

          console.log(book.pageCount);//600<br />
          console.log(book.originalLanguage);//'En'<br />
          console.log(book.translations);//["Uk", "Ru", "Pl"]<br />
        </p>
        <p>
          <b>Короткие свойства</b><br /><br />
          Иногда при создании объекта значение свйоства необходимо взять из
          переменной или параметров функции с тем же именем что и у свойства.
          <br /><br />
          Cинтаксис в след примере слишком большой, потому что приходится
          дублировать имя свойства и имя переменной в которой хранится нужное
          значение
        </p>
        <p class="bg">
          const name = "Vasya Pupkin"; <br />
          const age = 30;<br /><br />

          const user = {<br />
          name: name,<br />
          age: age,<br />
          }<br /><br />

          console.log(user.name);//"Vasya Pupkin"<br />
          console.log(user.age);//30<br />
        </p>
        <p>
          Синтаксис сокращенных свойств решает эту проблему, позволяя
          использовать имя переменной в качестве имени свйоства, а ее значение в
          качестве значения свойства
        </p>
        <p class="bg">
          const name = 'Vasya Pupkin'; <br />
          const age = 30;<br /><br />

          const user = {<br />
          name,<br />
          age,<br />
          };<br /><br />

          console.log(user.name); //"Vasya Pupkin"<br />
          console.log(user.age); //30
        </p>
        <p>
          То есть при объявлении объекта достаточно указать только имя свойства
          и значение будет взято из переменной с аналогичным именем <br /><br />
          <b>Вычислительные свойства</b><br /><br />
          Иногда возникают ситуации когда при объявлении объекта необходимо
          добавить свойство с именем, которое заранее не известно, т.к оно
          хранится как значение переменной или в качестве результата выполнения
          функций <br /><br />
          Ранее для этого приходилось сначала содавать объект а затем добавлять
          свойство через [] что не всегда удобно
        </p>
        <p class="bg">
          const propName = 'name'; <br />
          const user = {<br />
          age: 25,<br />
          };<br /><br />

          user[propName] = 'Vasya Pupkin';<br />
          console.log(user.name);//Vasya Pupkin<br />
        </p>
        <p>
          Синтаксис вычесляемых свойств помогает избежать лишнего кода и в
          некоторых случаях упростить его. Значением вычесляемого свойства может
          быть любое доступное выражение
        </p>
        <p class="bg">
          const propName = 'name'; <br />
          const user = {<br />
          age: 25,<br />
          // Имя этого свойства будет взято с переменной propName<br />
          [propName]: "Vasya Pupkin"<br />
          };<br /><br />

          console.log(user.name); //Vasya Pupkin<br />
        </p>
        <p>
          <b>Методы объекта</b> <br /><br />
          До сих пор мы рассматривали объекты только как хранилище
          взаимосвязанных данных, например информация о книге и т.д.
          Объекты-хранилищ обычно находятся в массиве таких же объектов, которые
          являются коллекцией однотипных элементов <br /><br />
          Объекты могут хранить не только данные но и функции для работы с этими
          данными - методы. Если значения свойства это функция, такое свойство
          называется методом объекта.
        </p>
        <p class="bg">
          const bookShelf = { <br />
          books: ['Kingdom', "Custle"],<br />
          // Это метод объекта<br />
          getBooks() {<br />
          console.log("Этот метод будет проверять все книги - свойство
          books");<br />
          },<br />
          // Это метод объекта<br />
          addBook(BookName) {<br />
          console.log("Этот метод будет добавлять новую книгу в свойства
          books");<br />
          },<br />

          }<br /><br />

          // Вызовы методов<br />
          bookShelf.getBooks();<br />
          bookShelf.addBook("New book");<br />
        </p>
        <p>
          Такие объекты можно назвать моделями, они считают в себе данные и
          методы для работы с этими данными, например можно было объявить
          переменную books и 2 функции getBooks() и addBook(bookName) но в этом
          случае это были бы 3 отдельные сущности без явного синтаксического
          связывания с недостаточной логической связью
        </p>
        <p class="bg">
          const books = []; <br />
          function getBooks() <br />
          function addBook() {}
        </p>
        <p>
          Доступ к свойствам объектов в методах<br /><br />
          Методы используются для работы со свойством объекта и изменения их.
          Для доступа к объекту в методе не используется имя переменной, такое
          как bookShelf, а ключевое слово this - контекст. Значением this будет
          объект перед точкой, то есть объект который вызвал этот метод. В нашем
          случае это ссылка на объект bookShelf.
        </p>
        <p class="bg">
          const bookShelf = { <br />
          books: ["Kingdom"],<br />
          getBooks() {<br />
          console.log(this);<br />
          }<br />
          }<br /><br />

          // Перед точкой находится объект bookShelf, поэтому вызов метода this
          будет сохранять ссылку на него<br />
          bookShelf.getBooks();
        </p>
        <p>
          Для получения доступа к свойствам объекта в методах мы обращаемся к
          нему через this и затем стандартно используем достум к свойствам через
          точку.
        </p>
        <p class="bg">
          const bookShelf = { <br />
          books: ['Kingdom'],<br />
          getBooks() {<br />
          return this.books;<br />
          },<br />
          addBook(bookName) {<br />
          this.books.push(bookName);<br />
          },<br />
          removeBook(bookName) {<br />
          const bookIndex = this.books.indexOf(bookName);<br />
          this.books.splice(bookIndex, 1);<br />
          },<br />
          };<br /><br />

          console.log(bookShelf.getBooks()); //["Kingdom"]<br />
          bookShelf.addBook('New book');<br />
          bookShelf.addBook('Very New book');<br />
          console.log(bookShelf.getBooks()); //[ 'Kingdom', 'New book', 'Very
          New book' ]<br />
          bookShelf.removeBook('Kingdom');<br />
          console.log(bookShelf.getBooks());//[ 'New book', 'Very New book' ]<br />
        </p>
        <p>
          Логично задуматься почему бы не использовать имя объекта в обращении к
          свойствам, ведь мы явно не собираемся его изменять. Дело в том, что
          имя объекта - вещь не надежная, методы одного объекта можно копировать
          в другой (с другим именем), а в будущем узнаем что часто во время
          создания объекта мы заранее отнюдь не знаем имя. Использование этого
          гарантирует что метод работает именно с тем объектом, который его
          вызвал.
        </p>
        <img src="./images/this-keywords.jpg" alt="" class="img" />
        <p>
          <b>Перебор объекта</b>
          <br />
          В отличае от массива или строки объект это не итерабельная сущность,
          т.е его нельзя перебрать циклами for и for .. off
          <br /><b>for..in</b> <br />
          Для перебора объекта используется специальный цикл for .. in который
          перебирает ключи объекта object.
        </p>
        <p class="bg">
          for (key in object){ <br />
          //тело
          <br />
          }
        </p>
        <p>
          Переменная key доступна только в теле цикла. На каждой итерации в нее
          будет записано значение ключа (имя) свойство. Для того чтобы получить
          значение свойства с таким ключом (именем) используется синтаксис []
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          for (const key in book) {<br />
          console.log(key);<br />
          console.log(book[key]);<br />
          }<br />
        </p>
        <p>
          <b>Метод hasOwnProperty()</b><br />
          Разбираем концепцию собственных и не собственных свойств объекта и
          научимся правильно использовать цикл for..in
        </p>
        <p class="bg">
          const animal = { <br />
          legs: 4,<br />
          };<br />
          const dog = Object.create(animal);<br />
          dog.name = 'Sharik';<br /><br />

          console.log(dog); //{ name: 'Sharik' }<br />
          console.log(dog.name);//Sharik<br />
          console.log(dog.legs);//4<br />
        </p>
        <p>
          <b>Метод Object.create(animal)</b><br />
          Создает и возвращает новый объект связывая его с объектом animal.
          Поэтому можно получить значение свойства legs, обратившись к нему как
          dog.legs хотя он отсутствует в объекте dog - это не собственное
          свойство из объекта animal.
          <br />
          <br /><b>Оператор in</b> используемый в цикле for..in не делает
          разницы между собственными и не собственными свойствами объекта. Эта
          особенность мешает, поскольку мы всегда хотим взять только собственные
          свойства. Для того чтобы узнать чтобы узнать содержит ли объект
          собственные свойства используется метод hasOwnProperty(key)
          возвращающий true or false.
        </p>
        <p class="bg">
          // Плохой пример
          <br />
          console.log("name" in dog);//true <br />
          console.log("legs" in dog);//true<br /><br />

          // Хороший пример<br />
          console.log(dog.hasOwnProperty("name"));//true<br />
          console.log(dog.hasOwnProperty("legs"));//false<br />
        </p>
        <p>
          Поэтому перебирая циклом for..in необходимо на каждой итерации
          добавить проверку собственного свойства. Даже если сейчас мы уверены в
          том что в объекте отсутствуют не собственные свойства это защитит от
          возможных ошибок в будущем
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          for (const key in book) {<br />
          // Если это собственное свойство - выполняем тело if<br />
          if (book.hasOwnProperty(key)) {<br />
          console.log(key);<br />
          console.log(book[key]);<br />
          }<br />
          // Если это не собстенное свойство - ничего не делаем<br />
          }<br />
        </p>
        <p>
          <b>Метод Object.keys()</b><br />
          Встроенный класс Object имеет несколько полезных способов для работы с
          объектами. Первый из них - это Object.keys(obj) который принимает
          объект и возвращает массив ключей, его собственных свойств. Если
          объект не обладает свойствами - метод вернет пустой массив.
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname'<br />, genres: ['History', 'Horror',
          'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          const keys = Object.keys(book);<br />
          console.log(keys); //[ 'title', 'author', 'genres', 'isPublic',
          'rating' ]<br />
        </p>
        <p>
          Скомбинировав результат Object.keys() и цикл for..of можно удобно
          перебрать собственные свойства объекта и не использовав архаический
          цикл for..in с проверками принадлежнасти свойств
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br />
          const keys = Object.keys(book);<br /><br />

          for (const key of keys) {<br />
          console.log(key);<br />
          console.log(book[key]);<br />
          }<br />
        </p>
        <p>
          Мы перебираем массив ключей объекта и на каждой итерации получаем
          свойство с таким ключем <br /><br />
          <b>Метод Object.values()</b><br /><br />
          Если метод Object.keys(obj) возвращает массив ключей собственных
          свойств объекта, метод Object.values(obj) возвращает массив значений
          его собственных свойств. Если в объекте отсутствуют свойства, метод
          Object.valuses(obj) вернет пустой массив.
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br /><br />

          const keys = Object.keys(book);<br />
          const values = Object.values(book);<br /><br />

          console.log(`keys: ${keys}\nvalues: ${values} `);<br />
        </p>
        <p>
          Массив значений свойства так же можно перебрать циклом for, например
          для получения общей суммы цифровых значений <br /><br />
          Предположим что нам нужно сосчитать общее кол-во продуктов в объекте
          формата имя-продукта: колличество. В таком случае будет уместен метод
          Object.values(). Для того чтобы получить массив общих значений, а
          затем удобно добавить их
        </p>
        <p class="bg">
          const products = { <br />
          apple: 4,<br />
          carrot: 10,<br />
          broad: 3,<br />
          cheese: 25,<br />
          }<br />
          const values = Object.values(products);<br />
          let total = 0;<br /><br />

          for (const value of values) {<br />
          total += value;<br />
          }<br />
          console.log(total);//42<br />
        </p>
        <p>
          <b>Метод Object.entries()</b><br /><br />
          Метод возвращает массив записи каждый элемент которого будет еще один
          массив из двух элементов: имени свойства и значения этого свойства из
          объекта obj.
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 8.4,<br />
          };<br />
          const keys = Object.keys(book);<br />
          const values = Object.values(book);<br />
          const entries = Object.entries(book);<br /><br />

          console.log(`Keys: ${keys}\nValues: ${values}\nEntries:
          ${entries}`);<br />
        </p>
        <p class="information">
          На практике метод Object.enries(obj) используется редко, только для
          каких то очень спецефических задач. В 99% случаев будет использоваться
          Object.keys() и Object.values()
        </p>
        <p>
          <b> Массив объектов</b> - стандартный набор обычных задач разработчика
          содержит манипуляцию массивом однотипных объектов. Это означает что
          объекты в массиве гарантировано будут иметь одинаковый набор свойств,
          но с разными значениями
        </p>
        <p class="bg">
          const books = [ <br />
          {<br />
          title: 'Kingdom',<br />
          author: 'Stiven King',<br />
          rating: 9.9,<br />
          },<br />
          {<br />
          title: 'Dom2',<br />
          author: 'King Kong',<br />
          rating: 1.1,<br />
          },<br />
          {<br />
          title: 'Custtle',<br />
          author: 'King Artur',<br />
          rating: 7.4,<br />
          },<br />
          ];<br />
        </p>
        <p>
          Для перебора такого массива используется стандартный цикл for..of.
          Значения свойства каждого объекта можно получить использую синтаксис
          через точку, поскольку в каждом объекте набор свойств и их имена будут
          одинаковые, отличаются только значения
        </p>
        <p class="bg">
          const books = [ <br />
          { <br />
          title: 'Kingdom', <br />
          author: 'Stiven King', <br />
          rating: 9.9, <br />
          }, <br />
          { <br />
          title: 'Dom2', <br />
          author: 'King Kong', <br />
          rating: 1.1, <br />
          }, <br />
          { <br />
          title: 'Custtle', <br />
          author: 'King Artur', <br />
          rating: 7.4, <br />
          }, <br />
          ]; <br />
          <br />

          for (const book of books) { <br />
          console.log(`Книги: ${book}\nНазвание: ${book.title}\nАвтор:
          ${book.author}\nРейтинг: ${book.rating}`); <br />
          } <br />
        </p>
        <p>Например получаем список названий всех книг в коллекции books</p>
        <p class="bg">
          const bookName = []; <br /><br />

          for (const book of books) {<br />
          bookName.push(book.title);<br />
          }<br />
          console.log(bookName);//[ 'Kingdom', 'Dom2', 'Custtle' ]<br />
        </p>
        <p>
          Узнаем средний рейтинг всей нашей коллекции, для это добавим все
          рейтинги, после чего поделим это значение на количество книг в
          коллекции
        </p>
        <p class="bg">
          let totalRating = 0; <br /><br />

          for (const book of books) {<br />
          totalRating += book.rating;<br />
          }<br /><br />

          let avgRating = (totalRating / books.length).toFixed(1);<br />
          console.log(avgRating);//6.1<br />
        </p>
        <p>
          <b>Синтаксис spread и rest</b><br />
          В современном стандарте появился новый синтаксис для работы с
          итерабельными сущностями, например строка, массив или объект. Его
          функционал и название зависят от места применения <br />
          <b>Spread: </b>передача аргументов <br />
          Операция spread позволяет распределить коллекцию элементов (массив,
          строку или объект) в место, в котором ожидается набор отдельных
          значений. Конечно существуют некоторые ограничения, например нельзя
          распределить массив в объект и наоборот <br />
          Можно привести аналогию с ящиком яблок. Поставь ящик на пол не вынимая
          из него яблоки, поличим аналог массива значений. Если высыпать яблоки
          из ящика на пол произойдет распределение - набор отдельных значений.
          <br />
          Отличие только одно - в JS распределение не изменяет оригинальную
          коллекцию, т.е создается копия каждого элемента. После распределения
          остается и полный ящик и копия каждого яблока на полу. <br /><br />
          Например метод Math.max(...[14,-2,3,25,0]), после интерпритации
          превращается в Math.max(14,-2,3,25,0) синтаксис ... возвращает
          распакованый массив, т.е распределяет его элементы в качестве
          отдельных доводов.
        </p>
        <p class="bg">
          const temps = [14, -2, 3, 25, 0]; <br />
          // В консоли будет массив<br />
          console.log(`Temps: ${temps}`); //Temps: 14,-2,3,25,0<br /><br />

          // Так не сработает, потому что передаем целый массив<br />
          console.log(Math.max(temps)); //NaN<br /><br />

          // В консоли будет набор отдельных чисел<br />
          console.log(...temps); //14 -2 3 25 0<br /><br />

          // Распределяем коллекцию элементов в качестве отдельных аргументов<br />
          console.log(Math.max(...temps)); //25<br />
        </p>
        <p>
          <b>Spread: создание нового массива</b><br />
          Операция spread позволяет создать копию массива или склеить
          произвольное колличество массивов в один новый. Ранее для этого
          использовали методы slice() и concat() но операция распределения
          позволяет сделать то же самое в более короткой форме
        </p>
        <p class="bg">
          const temps = [14, -2, 3, 25, 0]; <br />
          // Это точная но независимая копия tepms[]<br />
          const copyOfTemps = [...temps];<br />
          console.log(copyOfTemps);//[ 14, -2, 3, 25, 0 ]<br />
        </p>
        <p>
          В выше приведенном примере у нас есть ящик яблок temps и мы хотим
          создать его точную копию. Берем пустой ящик и пересыпаем из него
          яблоки выходного ящика temps и распределяем его в другую коллекцию.
          При таком условии ящик temps не изменится, в нем все еще будут яблоки
          а в новом ящике его точные копии <br />
          В след примере мы высыпаем яблоки из 2 ящиков в один новый.
          Оригинальные ящики (массивы) не изменятся, а новый будет копия всех
          яблок(элементов). Порядок распределения важен, он влияет на порядок
          элементов в новой коллекции
        </p>
        <p class="bg">
          const temps1 = [14, -2, 3, 25, 0]; <br />
          const temps2 = [14, -2, 3, 25, 0];<br />
          const allTemps = [...temps1, ...temps2];<br />
          console.log(allTemps);//[14, -2, 3, 25, 0, 14, -2, 3, 25, 0]<br />
        </p>
        <p>
          <b>Spread: создание нового объекта</b><br />
          Опреция spread позволяет распределить произвольное кол-во объектов в
          один новый.
        </p>
        <p class="bg">
          const first = { <br />
          propA: 1,<br />
          propB: 15,<br />
          };<br />
          const second = {<br />
          propC: 25,<br />
          };<br />
          const third = { ...first, ...second };<br />
          console.log(third);//{ propA: 1, propB: 15, propC: 25 }<br />
        </p>
        <p>
          Порядок распределения не имеет значения. Имена свойств объекта
          уникальные, поэтому свойства распределяемого объекта могут
          перезаписать значения уже существующего свойства, если их имена
          совпадают
        </p>
        <p class="bg">
          const first = { <br />
          propA: 1,<br />
          propB: 15,<br />
          propC: 50,<br />
          };<br />
          const second = {<br />
          propC: 25,<br />
          propD: 20,<br />
          };<br />
          const third = { ...first, ...second };<br />
          console.log(third); //{ propA: 1, propB: 15, propC: 25, propD: 20 }<br /><br />

          const fourth = { ...second, ...first };<br />
          console.log(fourth); //{ propC: 50, propD: 20, propA: 1, propB: 15
          }<br />
        </p>
        <p>
          Если бы яблоки в ящике имели наклейки с пометками то в одном ящике не
          может быть 2х яблок с одинаковыми помеками, поэтому пересыпаю во
          второй ящик все яблоки, отметки которых будут совпадать с уже
          находящимися уже в новом ящике, заменят существующие <br />
          При распределении можно добавить свойство в любое место. Главное
          помнить об уникальных именах свойств и о том что его значение может
          быть перезаписано.
        </p>
        <p class="bg">
          const first = { <br />
          propA: 1,<br />
          propB: 15,<br />
          propC: 50,<br />
          };<br />
          const second = {<br />
          propC: 51,<br />
          };<br />
          const third = {<br />
          propB: 10,<br />
          ...first,<br />
          ...second,<br />
          };<br />
          console.log(third); //{ propB: 15, propA: 1, propC: 51 }<br />
          const fourth = { ...second, ...first, propB: -5 };<br />
          console.log(fourth); //{ propC: 50, propA: 1, propB: -5 }<br /><br />

          const fifth = { ...first, propC: 100, ...second };<br />
          console.log(fifth);//{ propA: 1, propB: 15, propC: 51 }<br />
        </p>
        <p>
          <b>Rest: сбор всех аргументов функции</b><br />
          Операция ...(rest) позволяет собрать в группу независимых элементов в
          новую коллекцию. Синтаксически это близнец операции распределения, но
          отличить их просто - распределение когда находится в первой части
          операции присвоения, а сбор когда находится в ее левой части <br />
          Вернемся к аналогии с яблоками. Если на полу лежат яблоки и у нас есть
          пустой ящик то операция rest позволит собрать яблоки в ящик. В то же
          время оригинальные яблоки останутся на полу а в ящике будут копии
          каждого яблока. Одна из сфер применения операции rest это создании
          функций, которые могут принимать любое количество аргуметов.
        </p>
        <p class="bg">
          // Как объявить параметры функции таким образом чтобы можно было
          передать большое количество аргументов
          <br />
          function multiply(...args) {<br />
          console.log(`args: ${args}`);<br />
          }<br />
          multiply(1, 3, 5);<br />
        </p>
        <p>
          Если убрать весь синтаксический шум и посмотреть на аргументы и
          параметры функции, то аргументы находятся в правой части операции
          присвоения, а параметры в левйо, потому что значения аргументов
          присваивается объявленным параметрам. Следовательно можно собрать все
          аргументы функции в один параметр используя операцию rest <br />
          Имя параметров может быть произвольным, чаще всего его называют args,
          restArgs и otherArgs сокращенно от arguments <br />
          <b>Rest: сбор части аргументов функции</b><br />
          Операция ...(rest) так же позволяет собрать в массив только ту часть
          аргументов, которая необходимо объявить параметры до сбора
        </p>
        <p class="bg">
          function multiply(firstNumber, secondNumber, ...args) { <br />
          console.log(firstNumber);<br />
          console.log(secondNumber);<br />
          console.log(args);<br />
          }<br /><br />

          multiply(10, 20, 30); //10 20 [ 30 ]<br />
          multiply(10, 20, 30, 100, 1000);//10 20 [(30, 100, 1000)];<br />
        </p>
        <p>
          Все доводы для которых будут объявлены хар-ки передадут свои значения
          в массив. Операция ...(rest) собирает все остальные аргументы а потому
          должна быть последней в подписи функции иначе возникнет ошибка
        </p>
        <h3 class="title">Деструктуризация объектов</h3>
        <p>
          При разработке приложений данные приходят как правило в виде массивов
          и объектов, данные которых необходимо записать в локальные переменные.
          Для того чтобы делать это максимально просто в современном стандарте
          существует синтаксис деструктуаризированого присвоения
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: false,<br />
          rating: 8.4,<br />
          };<br /><br />

          const accessType = book.isPublic ? 'в печати' : 'не в печати';<br />
          const message = `Книга ${book.title} автора ${book.author} с рейтингом
          ${book.rating} находится ${accessType}`;<br />
          console.log(message);//Книга Kingdom автора Name Lastname с рейтингом
          8.4 находится не в печати<br />
        </p>
        <p>
          Деструктуризация позволяет распаковать значения свойств объекта в
          локальные переменные, это делает код менее шумным
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: false,<br />
          rating: 8.4,<br />
          };<br /><br />

          const { title, author, genres, isPublic, rating, likes } = book;<br />
          console.log(likes); //undefined<br /><br />

          const accessType = isPublic ? 'в печати' : 'не в печати';<br />
          const message = `Книга ${title} автора ${author} с рейтингом ${rating}
          находится ${accessType}`;<br />
          console.log(message);//Книга Kingdom автора Name Lastname с рейтингом
          8.4 находится не в печати<br />
        </p>
        <p>
          Деструктуризация всегда находится в левой части операции присвоения.
          Пременная внутри фигурных скобок присваивается значение свйоств
          объекта. Если имя переменной и имя свойства совпадают происходит
          присвоение, в противном случае ей будет присвоена undefind. Порядок
          объявления переменных в фигурных скобках не важен <br />
          <b>Значения по умолчанию</b><br />
          Чтобы избежать присвоения undefind во время Деструктуризации в
          несуществующих свойств объекта можно задать переменным значения по
          умолчанию, которые будут присвоены только в том случае если объект не
          содержит свойство с таким именем.
        </p>
        <p class="bg">
          const book = { <br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          };<br />
          // Добавим изображение обертки, если оно отсутствует в объекте
          книги<br /><br />

          const { title, author, img = 'https://via.placeholder.com/640/480' } =
          book;<br />
          console.log(title); //Kingdom<br />
          console.log(author); //Name Lastname<br />
          console.log(img); //https://via.placeholder.com/640/480<br />
        </p>
        <p>
          <b>Изменение имени переменной</b><br />
          При Деструктуризации можно изменить имя переменной, в которой
          распаковывается значение свойства. Сначала пишем имя свойства из
          которого хотим получить значение, после чего ставим двоеточие и пишем
          имя переменной в которую хотим поместить значение этого свойства.
        </p>
        <p class="bg">
          const firstBook = { <br />
          title: 'First book',<br />
          img: 'https://via.placeholder.com/640/480',<br />
          };<br />
          const {<br />
          title: firstTitle,<br />
          img: firstImg =
          'https://images-na.ssl-images-amazon.com/images/I/51b5YG6Y1rL.jpg', }
          = firstBook;<br /><br />

          console.log(firstTitle); //First book<br />
          console.log(firstImg); //https://via.placeholder.com/640/480<br /><br />

          const secondBook = {<br />
          title: 'Second book',<br />
          };<br />
          const { title: secondTitle, img: secondImg = 'https://asdasdads' } =
          secondBook;<br />
          console.log(secondTitle); //Second book<br />
          console.log(secondImg); //https://asdasdads<br />
        </p>
        <p>
          Такая запись читается как создать переменную firstTitle в котору
          поместить значение свйоства title из объекта firstBook и т.д <br />
          <b>Деструктуризация в циклах</b><br />
          Перебирая массив объектов циклом for..of образуется многократное
          обращение к свойствам объекта
        </p>
        <p class="bg">
          const books = [ <br />
          {<br />
          title: 'Kingdom',<br />
          author: 'Name Lastname',<br />
          genres: ['History', 'Horror', 'Comedy'],<br />
          isPublic: false,<br />
          rating: 8.4,<br />
          },<br />
          {<br />
          title: 'Custle',<br />
          author: 'Harry',<br />
          genres: ['Drama', 'Melodrama', 'Comedy'],<br />
          isPublic: true,<br />
          rating: 0.4,<br />
          },<br />
          ];<br /><br />

          for (const book of books) {<br />
          console.log(book.title);<br />
          console.log(book.author);<br />
          console.log(book.rating);<br />
          }<br />
        </p>
        <p>
          Чтобы сократить кол-во повторений можно Деструктуризировать свойства
          объекта в локальную переменную в теле цикла
        </p>
        <p class="bg">
          //Деструктуризированый вариант
          <br />
          for (const book of books) {<br />
          const { title, author, rating } = book;<br />
          console.log(title);<br />
          console.log(author);<br />
          console.log(rating);<br />
          }
        </p>
        <p>
          Если в объекте не много свойств можно выполнить деструктуаризацию
          непосредственно на месте объявления переменной book
        </p>
        <p class="bg">
          for (const { title, author, rating } of books) { <br />
          console.log(title); <br />
          console.log(author);<br />
          console.log(rating);<br />
          }
        </p>
        <p>
          <b>Глубокая деструктуаризация</b><br />
          Для деструктуаризации свойств вложенных объектов используются те же
          принципы что и в трех предидущих упражнениях
        </p>
        <p class="bg">
          const user = { <br />
          name: 'Username',<br />
          tag: '#User',<br />
          stats: {<br />
          folovers: 50,<br />
          views: 15,<br />
          likes: 10,<br />
          },<br />
          };<br />
          const {<br />
          name,<br />
          tag,<br />
          stats: { folovers, views: userViews, likes: userLikes = 0 },<br />
          } = user;<br />
          console.log(name);//Username<br />
          console.log(tag);//#User<br />
          console.log(folovers);//50<br />
          console.log(userViews);//15<br />
          console.log(userLikes);//10<br />
        </p>
        <h3 class="title">Деструктурицация массивов</h3>
        <p>
          Деструктуризированое присвоение можно использовать для массивов но с
          некоторыми особенностями <br />
          Вместо фигурных скобок используем квадратные. Переменным, указанным в
          квадратных скобках, будут последовательно присваиваться значения
          элементов массива. <br />
          Например есть массив цветов из которого нужно получить значение
          каждого состовляюзего цвета в отдельной переменной
        </p>
        <p class="bg">
          const rgb = [200, 255, 100]; <br />
          const [red, green, blue] = rgb;<br /><br />

          console.log(`R: ${red}, G: ${green}, B: ${blue}`);//R: 200, G: 255, B:
          100<br />
        </p>
        <p>
          После ключевого слова const или let ставим квадратные скобки как и в
          случае объявления массива. Внутри скобок через запятую указываем имена
          переменных в которые будут помещены значения массива. <br />
          <br />В результате такой записи будут созданы 3 переменных и в них
          будут помещены элементы в нумерованом порядке от 0 до конца массива.
          При диструктуризации массива значение переменной может присваиваться
          после ее объявления. На практике редко используется.
        </p>
        <p class="bg">
          const rgb = [200, 255, 100]; <br />
          let red, green, blue;<br />
          [red, green, blue] = rgb;<br /><br />

          console.log(`R: ${red}, G: ${green}, B: ${blue}`); //R: 200, G: 255,
          B: 100<br />
        </p>
        <p>
          Если переменных больше элементов массива им будет присвоено undefind,
          поэтому можно указывать значение по умолчанию
        </p>
        <p class="bg">
          const rgb = [200, 255, 100]; <br />
          const [red, green, blue, alpha = 0.3] = rgb;<br /><br />

          console.log(`R: ${red}, G: ${green}, B: ${blue}, Alpha: ${alpha}`);
          //R: 200, G: 255, B: 100, Alpha: 0.3<br />
        </p>
        <p>
          Иногда из массива необходимо деструктуризировать только первые
          элементы, а другие сохранить в отдельную переменную в виде массива,
          деструктурируя массив можно распаковать и присвоить другую часть
          элемента в переменную массива используя операцию ...rest
        </p>
        <p class="bg">
          const rgb = [200, 255, 100]; <br />
          const [red, ...colors] = rgb; <br />
          <br />

          console.log(red);//200 <br />
          console.log(colors);//[ 255, 100 ] <br />
        </p>
        <p>
          Элементы можно пропускать. Предположим из массива rgb необходимо взять
          только последнее значение, на практике это редко используется
        </p>
        <p class="bg">
          const rgb = [200, 255, 100]; <br />
          const [, , blue] = rgb;<br /><br />

          console.log(`B: ${blue}`);//B: 100<br />
        </p>
        <p>
          <b>Паттерн "Объект параметров"</b><br />
          Если функция принимает более 2-3 аргументов то легко запутаться в
          какой последовательности и что передавать, получается очень
          неочевидный код в месте вызова.
        </p>
        <p class="bg">
          function doStuffWithBook(title, numberOfPages, downloads, rating,
          public) { <br />
          // Что то делаем с параметрами<br />
          console.log(title);<br />
          console.log(numberOfPages);<br />
          // И так далее<br />
          }<br /><br />

          doStuffWithBook('Kingdom', 250, 15, 9.8, true);
        </p>
        <p>
          Паттерн объект параметров помогает решить эту проблему заменяя набор
          параметров всего одним объектом с именуемыми свойствами
        </p>
        <p class="bg">
          function doStuffWithBook(book) { <br />
          // Делаем что то со свойствами объекта<br />
          console.log(book.title);<br />
          console.log(book.downloads);<br />
          console.log(book.rating);<br />
          // И так далее<br />
          }<br />
        </p>
        <p>
          В таком случае при ее вызове передаем один объект с необходимыми
          свойствами
        </p>
        <p class="bg">
          doStuffWithBook({ title: 'Ringdom', numberOfPages: 250, rating: 9.8
          });
        </p>
        <p>
          Еще один плюс в том что можно деструктуризировать объект в параметре
          book это можно сделать в теле функции
        </p>
        <p class="bg">
          function doStuffWithBook(book) { <br />
          const { title, numberOfPages, rating } = book;<br />
          console.log(title);<br />
          console.log(rating);<br />
          }
        </p>
        <p>Или сразу в сигнатуре функции - нет разницы</p>
        <p class="bg">
          function doStuffWithBook({ title, numberOfPages, rating }) { <br />
          console.log(title);<br />
          console.log(rating);<br />
          }<br />
        </p>
      </section>
    </main>
    <script src="./js/moduleThree.js"></script>
  </body>
</html>

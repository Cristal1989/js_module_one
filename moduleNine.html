<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 9</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Асинхронность</h3>
      <p>
        Весть код выполняется процессором компьютера и весь код, который мы
        писали до сих пор был синхронным, т.е занимал процессор на все время
        своего исполнения, скорость выполнения цикла для итерации по массиву
        зависит от скорости процессора. <br />
        Есть операции взаимодействующие с внешним миром, к примеру обмен данными
        с сервером в сети что намного медленнее чем получение их из памяти. Если
        такие операции обрабатываются синхронно - процессор простаивает во время
        своего запроса на сервер вместо того чтобы выполнять другой код. <br />
        Синхронный код выполняется последовательно, каждая итерация ожидает пока
        выполнится предварительно. Когда вы вызываете функцию, выполняющую
        длитильное действие это останавливает программу на все время ее
        выполнения т.е у модели синхронного программирования все происходит
        поочередно. <br />
        В асинхронном коде могут одновременно выполнятся несколько операций. В
        такой модели сетевой запрос на сервер не остановит программу (приложение
        например), она продолжит выполнять другие операции. Когда запрос
        завершится программа сообщает об этом и получает доступ к результату,
        например данные из сервера. <br />
        Рассмотрим разницу на примере, в котором приложение выполняет два
        сетевых запроса на сервер, после чего обрабатывает их результат.
        Операции 1 и 2 это функции, которые делают запрос на сервер, а 3, 4 и 5
        - любой другой первичный для вас код.
      </p>
      <img src="./images/sync-vs-async.jpg" alt="" />
      <p>
        В синхронной модели все понятно и довольно грустно. Предварительные
        операции блокируют выполнение следующих пока они не завершаться. Если
        операции 3 и 5 это обработка кликов пользователя то интерфейс просто
        зависнет пока не будут выполнены и обработаны результаты 1 и 2. <br />
        Например пользователь отпрвил коментарий (сетевой запрос) и захотел
        открыть сайдбар с последними новостями. После щелчка отправить
        коментарий, интерфейс зависнет и не будет реагировать на его действия
        пока от сервера не прийдет результат отправки коментария. Очень не
        удобно в использовании. <br />
        В асинхронной модели старт сетевого запроса вызывает нечто вроде
        разветвления т.е запуск запроса и результат его обработки - это разные
        действия. Пока выполняется запрос программа продолжает работать и
        выполнять другой код. Как только сетевой запрос будет выполнен программа
        может начать обрабатывать результат сразу после его освобождения. Это
        значит что пользователь отправил коментарий и сразу может открыть
        сайдбар со свежими новостями не дожидаясь пока прийдет ответ от сервера.
        <br />
        Т.е за еденицу времени по прежнему может выполняться только одна
        операция, потому что JS однопоточный. Асинхронное программирование
        достигается путем отложенных вызовов функций где инициализация
        асинхронной операции и обработка ее результата это разные действия.
        <br />
        <b>Асинхронный код</b><br />
        В синхронном коде такая инструкция не может начать своего выполнения
        пока не выполнится предидущая т.е инструкция обрабатывается
        последовательно.
      </p>
      <p class="bg">
        console.log("First"); <br />
        console.log("Second");<br />
        console.log("Third");
      </p>
      <p>
        Следующий код асинхронный функцией setTimeout(). Сейчас о ней нам нужно
        знать только то, что она принимает 2 параметра - callback функцию,
        которая будет вызвана по истечению времени которую мы передаем вторым
        аргументом.
      </p>
      <p class="bg">
        //Запустится 1й лог <br />
        console.log('First log');<br /><br />

        setTimeout(() => {<br />
        // Выпонится последним через 2000ms<br />
        console.log('Second log');<br />
        }, 2000);<br /><br />

        // Запустится вторым<br /><br />

        console.log('Third log');<br />
        //First log<br />
        //Third log<br />
        //Second log
      </p>
      <p>
        Функция setTimeout() обрабатывает синхронно и регистрирует отложеный
        вызов передаваемый callback функцией, которая будет вызвана асинхронно
        через указаный промежуток времени. <br />
        <b>Многопоточность</b><br />
        Не путать асинхронность и многопоточность, это еще называют параллелизм.
        Это разные модели программирования. В простой аналогии в которой все
        расставит по местам представим что вы шеф и в ресторане приходит заказ
        на кофе и тосты.
      </p>
      <ul>
        <li>
          <b>Синхронный однопоточный подход</b> - вы сами сначала готовите кофе,
          затем тосты и подаете их, после чего убираете на кухне
        </li>
        <li>
          <b>Асинхронный однопоточный подход</b> - вы начинаете готовить кофе,
          устанавливаете таймер, затем начинаете готовить тосты и уставливаете
          таймер. Пока кофе и тосты готовятся вы убираетесь на кухне. Когда
          таймеры срабатывают вы достаете с огня кофе, достаете тосты и подаете
          их.
        </li>
        <li>
          <b>Многопоточный подход</b> - вы нанимаете 2х помощников - одного для
          приготовления кофе, а другого для приготовления тостов. Теперь у вас
          есть проблема управления помощниками (потоками) чтобы они не
          конфликтовали друг с другом на кухне при совместном использовании
          ресурсов
        </li>
      </ul>
      <p>
        А асинхронных однопоточных процессах у вас есть график задач в котором
        некоторые задачи зависят от результата работы других. При выполнении
        каждой задачи вызывается код для обработки его результата. Но вам нужен
        только один работник для выполнения всех задач. <br />
        <b>Таймеры</b><br />
        Внутренний таймер планировщик браузера позволяет откладывать вызов
        функции на определенный период времени. Для этого есть таймауты и
        интервалы, контролирующие когда и как часто вызываются функции. Таймеры
        реаизованы в браузере, а не встроены в язык и доступны на глобальном
        объекте window. <br />
        <b>Таймаут</b><br />
        Метод setTimeout() позволяет запланировать запуск функции через
        некоторое время
      </p>
      <p class="bg">
        const timerId = setTimeout(callback, delay, arg1, arg2, ...);
      </p>
      <ul>
        <li>callback - функция выполнения, которую необходимо запланировать</li>
        <li>
          delay - время в ms через которое callback функция будет вызвана 1 раз
        </li>
      </ul>
      <p>
        Дополнительные аргументы arg1 и arg2 будут переданы callback функцией во
        время вызова. Возвращает цифровой индификатор таймера, который
        используется для его удаления
      </p>
      <div>
        <button class="btn" type="button">Click me</button>
      </div>
      <p class="bg">
        const button = document.querySelector('button'); <br />
        const onClick = () => { const timerId = setTimeout(() => {<br />
        console.log('Async code'); <br />
        }, 2000); <br />
        console.log(timerId); };<br />
        button.addEventListener('click', onClick);<br />
      </p>
      <p>
        Если нам по какой либо причине нужно отменить вызов функции внутри
        timeout используется метод clearTimeout(id) который принимает
        индификатор тамера и очищает его.
      </p>
      <p class="bg">
        const greet = () => console.log("Hello"); <br />
        const timerId = setTimeout(greet, 3000);<br />
        clearTimeout(timerId);<br />
      </p>
      <p>
        Поскольку мы вызвали clearTimeout который выполняется раньше чем вызвана
        функция greet таймер с timerId будет удален и регистрация отложенного
        вызова greet() будет отменена. <br />
        <b>Интервал</b><br />
        Метод setInterval() это простой способ повторения кода снова и снова с
        установленным промежутком времени повторений. Синтаксис и параметры
        такие же как у setTimeout(). Отличие от setTimeout() интервал запускает
        выполнение функции ни один раз, а регулярно повторяет ее через указаный
        промежуток времени. Остановить выполнение можно методом
        clearInterval(id)
      </p>
      <p class="bg">
        const timerId = setInterval(callback, delay, arg1, arg2, ...);
      </p>
      <p>
        Щелкая на кнопку старт запустим интервал и будем каждую секунду выводить
        в консоль строку. Используем Math.random() чтобы строчки были разные по
        щелчку на кнопку стоп. Вызовем clearInterval() и передадим индификатор
        интервала, который нужно остановить.
      </p>
      <div>
        <button class="btn js-start">Start</button>
        <button class="btn js-stop">Stop</button>
      </div>
      <p class="bg">
        const startBtn = document.querySelector('.js-start'); <br />
        const stopBtn = document.querySelector('.js-stop');<br />
        let timerId = null;<br /><br />

        startBtn.addEventListener('click', () => {<br />
        timerId = setInterval(() => {<br />
        console.log(`Start async js ${Math.random()}`);<br />
        }, 1000);<br />
        });<br /><br />

        stopBtn.addEventListener('click', () => {<br />
        clearInterval(timerId);<br />
        console.log(`Interval with id ${timerId} has stoped`);<br />
        });<br />
      </p>
      <p>
        <b>Частота срабатывания счетчика</b><br />
        У браузерного таймера имеется минимальная возможная задержка. В
        современных браузерах она колеблится от 0 до 4, в более старых до 15 мс.
        По стандарту минимальная задержка составляет 4мс. Поэтому между
        setTimeout(callback, 1) и setTimeout(callback, 4) разницы нет. <br />
        Таймер может срабатывать реже чем указано в параметре delay т.к при
        слишком большой загрузке процессора некоторые запуски функций-интервалов
        будут пропущены. Браузеры продолжают выполнять таймауты и интервалы даже
        если вкладка браузера не активна но одновременно снижает частоту
        срабатывания таймера.
      </p>
      <h3 class="title">Дата и время</h3>
      <p>
        Класс Date непосредственно абстрагирует большую часть работы с датами.
        Это позволяет отображать моменты во времени как объекты и манипулировать
        ими заранее определенными методами. Используя возможности класса Date
        можно создавать часы, счетчики, календари и другие интерактивные
        элементы интерфейса. <br />
        <b>Создание Date</b><br />
        Экземпляр объекта Date это объект отображающий определенный момент
        времени. Создание даты без аргументов возвращает объект, сохраняющий
        дату и время на момент его инициализации т.е текущее. В строчном
        преобразовании объект возвращает результат вызова метода toString()
        поэтому в первом логе мы получаем строчку а не объект.
      </p>
      <p class="bg">
        const date = new Date(); <br />
        console.log(date); //2024-08-24T11:11:25.675Z <br />
        console.log(date.toString()); //Sat Aug 24 2024 14:12:28 GMT+0300
        (Восточная Европа, летнее время)
      </p>
      <p>
        <b>unix время</b><br />
        Внутри даты значения отражены в милисекундах прошедших после полуночи 1
        января 1970 в часовом поясе UTC. Для компьютера это дата начало отсчета
        времени unix время, поэтому во время инициализации даты значение
        передается одним числом. Оно представляет собой уже прошедшее кол-во
        милисекунд.
      </p>
      <p class="bg">
        console.log(new Date(0)); //1970-01-01T00:00:00.000Z <br />
        console.log(new Date(15000)); //1970-01-01T00:00:15.000Z
      </p>
      <p>
        Метод getTime() повторяет числовое значение этой даты (timestamp) -
        кол-во ms что прошла с полночи 1.01.1970
      </p>
      <p class="bg">
        const date = new Date(); <br />
        console.log(date.getTime());//1724498726117
      </p>
      <p>
        Удобство этого формата заключается в том, что можно отображать точные
        моменты времени в виде одного числа и не беспокоится о датах, строках,
        часовых поясах, поскольку можно получить всю необходимую инфу когда
        необходимо. <br />
        <b>Установка Date</b><br />
        Создавая экземпляр класса Date можно установить дату строкой или числом.
        Строка может описывать только дату или дату и время.
      </p>
      <p class="bg">
        const teamMeetingDate = new Date('March 16, 2030'); <br />
        console.log(teamMeetingDate); //2030-03-15T22:00:00.000Z<br /><br />

        const preciseTeamMeetingDate = new Date('March 16, 2030 14:10:00');<br />
        console.log(preciseTeamMeetingDate); //2030-03-16T12:10:00.000Z<br />
      </p>
      <p>
        Установка времени в виде строк внутри вызывает метод Date.parse()
        который превращает строчку в число - кол-во милисекунд. Именно поэтому
        формат передаваемой строки очень гибкий. К примеру можно не указывать 0
        для дней или месяцев. Рассмотрим несколько примеров которые будут иметь
        одинаковый результат.
      </p>
      <p class="bg">
        new Date("2030-03-16") <br />
        new Date("2030-03")<br />
        new Date("2018")<br />
        new Date("03/16/2030")<br />
        new Date("2030/03/16")<br />
        new Date("2030/3/16")<br />
        new Date("March 16, 2030")<br />
        new Date("March 16, 2030 14:20:20")<br />
        new Date("2030-03-16 14:20:20")<br />
        new Date("2030-03-16t14:20:20")<br />
        new Date("16 March 2030")<br />
      </p>
      <p>
        Другой способ создания новых объектов это передать 7 чисел, описывающих
        год, месяц (начинается с 0), день, часы, минуты, секунды и милисекнды.
        Обязательные только первые 3
      </p>
      <p class="bg">
        const date = new Date(2030, 2, 16, 10, 10, 12, 10); <br />
        console.log(date);//2030-03-16T08:10:12.010Z
      </p>
      <p>
        <b>Методы</b> <br />
        Экземпляр класса Date имеет множество методов для чтения и записи
        значений даты и времени. Методы возвращают или присваивают год, месяц,
        день месяца или недели, час, минута, секунда и т.д для каждого
        экземпляра. Эти данные могут быть в виде строки с учетом местного
        календаря или языка <br /><b>Геттеры</b><br />
        Геттеры используются для чтения всей даты или отдельной состовляющей.
        Возвращаемое значение зависит от текущего часового пояса установленного
        на вашем компе
      </p>
      <p class="bg">
        const date = new Date(); <br />
        console.log('Date: ', date); //Date: 2024-08-24T12:04:55.393Z<br /><br />

        // Возвращает день месяца от 1 до 31<br />
        console.log('getDate(): ', date.getDate()); //getDate(): 24<br /><br />

        // Возвращает день недели от 0 до 6<br />
        console.log('getDay(): ', date.getDay()); //getDay(): 6<br /><br />

        // Возвращает месяц от 0 до 11<br />
        console.log('getMonth(): ', date.getMonth()); //getMonth(): 7<br /><br />

        // Возращает год из 4 цифр<br />
        console.log('getFullYear(): ', date.getFullYear()); //getFullYear():
        2024<br /><br />

        // Возвращает часы<br />
        console.log('getHours(): ', date.getHours()); //getHours(): 15<br /><br />

        // Возращает минуты<br />
        console.log('getMinutes(): ', date.getMinutes()); //getMinutes(): 4<br /><br />

        // Возвращает скунды<br />
        console.log('getSeconds(): ', date.getSeconds()); //getSeconds(): 55<br /><br />

        // Возвращает миллискунды<br />
        console.log('getMilliseconds(): ',
        date.getMilliseconds());//getMilliseconds(): 393<br />
      </p>
      <p>
        Существующий эквивалент версий этих методов который возвращает значение
        в формате UTC (coordinated universal time) а не адаптивный к текущему
        часовому поясу пользователя.
      </p>
      <p class="bg">
        const date = new Date(); <br />
        console.log('Date: ', date); //Date: 2024-08-24T12:04:55.393Z<br /><br />

        // Возращает день месяца от 1 до 31<br />
        console.log('getUTCDate(): ', date.getUTCDate()); //getUTCDate(): 24<br /><br />

        // Возвращает день недели от 0 до 6<br />
        console.log('getUTCDay(): ', date.getUTCDay()); //getUTCDay(): 6<br /><br />

        // Возвращает месяц от 0 до 11<br />
        console.log('getUTCMonth(): ', date.getUTCMonth()); //getUTCMonth():
        7<br /><br />

        // Возращает год из 4 цифр<br />
        console.log('getUTCFullYear(): ', date.getUTCFullYear());
        //getUTCFullYear(): 2024<br /><br />

        // Возвращает часы<br />
        console.log('getUTCHours(): ', date.getUTCHours()); //getUTCHours():
        12<br /><br />

        // Возращает минуты<br />
        console.log('getUTCMinutes(): ', date.getUTCMinutes());
        //getUTCMinutes(): 13<br /><br />

        // Возвращает скунды<br />
        console.log('getUTCSeconds(): ', date.getUTCSeconds());
        //getUTCSeconds(): 47<br /><br />

        // Возвращает миллискунды<br />
        console.log('getUTCMilliseconds(): ', date.getUTCMilliseconds());
        //getUTCMilliseconds(): 118<br />
      </p>
      <p>
        <b>Сеттеры</b><br />
        Все что можно прочитать - можно записать, методы для записи называются
        так же геттеры но начинаются с префикса set. Так же для всех способов
        есть их UTC эквивалент
      </p>
      <p class="bg">
        const date = new Date('March 16 2030 12:10:10'); <br />
        date.setMinutes(20);<br />
        console.log(date); //2030-03-16T10:20:10.000Z<br /><br />

        date.setFullYear(2040, 4, 8);<br />
        console.log(date);//2040-05-08T09:20:10.000Z
      </p>
      <p>
        <b>Форматирование времени</b><br />
        Объект даты может быть предоставлен в разных строчных и числовых
        форматах. Для этого сущетсвует целый набор способов. Например
        toString(), toDateString(), возвращает toTimeString() стандартное
        строчное отображение не заданое жестко в стандарте а зависит от
        браузера. Единственное требование к нему - читабельность для человека.
        Метод toString() возвращает дату полностью, а toDateString() и
        toTimeString() только дату и время соответственно.
      </p>
      <p class="bg">
        const date = new Date('March 16 2030 12:15:20'); <br /><br />

        console.log(date.toString()); // Sat Mar 16 2030 12:15:20 GMT+0200
        (Восточная Европа, стандартное время)<br />
        console.log(date.toTimeString()); // 12:15:20 GMT+0200 (Восточная
        Европа, стандартное время)<br />
        console.log(date.toLocaleTimeString()); // 12:15:20<br />
        console.log(date.toUTCString()); // Sat, 16 Mar 2030 10:15:20 GMT<br />
        console.log(date.toDateString()); // Sat Mar 16 2030<br />
        console.log(date.toISOString()); // 2030-03-16T10:15:20.000Z<br />
        console.log(date.toLocaleString()); //16.03.2030, 12:15:20<br />
        console.log(date.getTime());//1899886520000<br />
      </p>
      <p>
        <b>Promise</b><br />
        Поли обещает испечь торт на мой день рождения через 2 недели. Если все
        будет хорого и она не заболеет у меня будет торт. Если Поли будет плохо
        чебя чувствовать она не сможет испечь торт. Во всяком случае мы все
        равно устроим вечеринку. Обещание - это не гарантия выполнения, мы не
        знаем выполнит ли ее или нет. В программировании так же есть задачи
        результаты которых мы узнаем только в будущем
      </p>
      <img src="./images/promise-story.jpg" alt="" />
      <p>
        <b>Promise (обещание, promise)</b> - объект предоставляющий текущее
        состоянии асинхронной операции. Это обертка для значения, неизвестного к
        моменту создания promise. Позволяет обрабатывать результаты асинхронной
        операции таким образом, если они были синхронными: вместо конечного
        результата асинхронной операции, возвращается своебразное обещание
        получить результат в будущем <br />
        Promise может быть в 3 состояниях
      </p>
      <ul>
        <li>
          <b>Ожидание (pending)</b> - начальное состояние при создании promise
        </li>
        <li>
          <b>Выполнение (fulfilled)</b> - операция выполнена успешно с любым
          результатом
        </li>
        <li><b>Отклонено (rejected)</b> - операция отклонена с ошибкой</li>
      </ul>
      <img src="./images/promise-state.jpg" alt="" />
      <p>
        На момент создания promise находится в ожидании (pending), после чего
        может успешно завершиться (fulfilled), вернув результат (значение) или с
        ошибкой (rejected), вернув причину. Когда promise переходит в состояние
        fulfilled или rejected это навсегда. <br />
        <b
          >Когда promise выполнен или отклонен то говорят что он завершен
          (settled). Это просто термин, описывающий то, что promise находится в
          любом состоянии кроме ожидания</b
        >
      </p>
      <ul>
        Результат promise и callback функции
        <li>callback - это функции, promise - объект</li>
        <li>
          callback передаются в качестве аргументов из внешнего кода во
          внутренний, а promise возвращается из внутреннего кода во внешний
        </li>
        <li>
          callback обрабатывают успешное или неуспешное завершение операций, а
          promise ничего не обрабатывает
        </li>
        <li>
          callback могут обрабатывать несколько событий, promise связано только
          с одним событием
        </li>
      </ul>
      <p>
        <b>Создание</b><br />
        Промис создается как экземпляр класса Promise, который принимает функцию
        (executer) как аргумент и сразу вызывает ее, еще до создания и возврата
        Promise
      </p>
      <p class="bg">
        const promise = new Promise((resolve, reject) => { <br />
        // Асинхронная операция<br />
        })<br />
      </p>
      <p>
        Функция executer сообщает экземпляр (promise) когда и как операция с
        которой он связан будет завершена. В ней можно выполнить любую
        асинхронную операцию, по завершению которой нужно вызвать resolve(). В
        случае успешного выполнения состояния fulfilled или reject в случае
        ошибки. Возвращаемое значение этой функции игнорируется.
      </p>
      <ul>
        <li>
          resolve(value) - функция для вызова при успешной операции. Переданый
          ей аргумент будет являться значением выполненого promise
        </li>
        <li>
          reject(error) - функция вызова в случае ошибки. Переданный ей аргумент
          будет являться значением отклоненного promise
        </li>
      </ul>
      <img src="./images/create-promise.jpg" alt="" />
      <p class="bg">
        <br />
        // Изменить значение переменной isSuccess для вызова разрешения или
        отклоненияъ<br />
        const isSuccess = true;<br /><br />

        const promise = new Promise((resolve, reject) => {<br />
        setTimeout(() => {<br />
        if (isSuccess) {<br />
        resolve('Успех, значение функции передано resolve');<br />
        } else {<br />
        reject('Ошибка передана в функцию reject');<br />
        }<br />
        }, 2000);<br />
        });<br />
      </p>
      <p>
        В переменную promise будет записан promise объект в состоянии pending, а
        через 2 секунды как только будет вызван resolve или reject promis
        перейдет в состояние fulfilled или reject и мы сможем его обработать.
      </p>
      <p>
        <b>Метод then()</b><br />
        Код которому нужно сделать что-то асинхронно создает promise и
        возвращает его. Внешний код получив promise навешивает на него
        обработчики. После завершения процесса асинхронный код переводит promise
        в состояние fulfilled или reject и автоматически вызывает обработчики во
        внешнем коде. <br />
        После создания promise его результат обрабатывается в callback функции.
        Код пишется таким образом будто мы думаем о том, что может произойти
        если promise выполнится или не выполнится не думая о временных рамках.
        <br />
        Метод then() принимает 2 аргумента: callback функции, которые будут
        вызваны, когда promise изменит свое состояние. Результатом promise или
        ошибку они получат в качестве аргумента.
      </p>
      <p class="bg">promise.then(onResolve, onReject);</p>
      <ul>
        <li>
          onResolve(value) - будет вызван в случае успешного выполнения promise
          и получит его результат в качестве аргумента.
        </li>
        <li>
          onReject(error) - будет вызван в случае выполнения promise с ошибкой и
          получит его результат в качестве его аргумента
        </li>
      </ul>
      <img src="./images/then-method.jpg" alt="" class="img" />
      <p>
        В примере caallback функция onResolve() будет вызвана через 2 секунды
        если promise успешно выполнится, а onReject() будет вызвана через 2
        секунды если promise будет выполнена с ошибкой.
      </p>
      <p class="bg">
        const isSuccess = true; <br /><br />

        const promise = new Promise((resolve, reject) => {<br />
        setTimeout(() => {<br />
        if (isSuccess) {<br />
        resolve('Успех');<br />
        } else {<br />
        reject('Ошибка');<br />
        }<br />
        }, 2000);<br />
        });<br /><br />

        // Сначала запустится<br />
        console.log('Before promise.then()');<br /><br />

        // Регистрация promise колбек promise.then()<br />
        promise.then(<br />
        value => {<br />
        console.log('onResolve вызван вне promise.then()');<br />
        console.log(value);<br />
        // Задача успешно передана в результат<br />
        },<br />
        error => {<br />
        console.log('onReject вызван внутри promise.then()');<br />
        console.log(error);<br />
        }<br />
        );<br />
        // Сначала запустится первым<br />
        console.log("console.log('Before promise.then()');");<br /><br />

        // Регистрация callbacks promise.then()<br />
        promise.then(<br />
        // onResolve запустится третим или не запуститься вообще<br />
        (value => {<br />
        console.log("onResolve вызывается внутри promise.then()");<br />
        console.log(value);<br />
        },<br />
        // onReject выполняется третий раз или не выполнится вообще<br />
        error => {<br />
        console.log("onReject вызывается внутри promise.then()");<br />
        console.log(error);<br />
        }))<br />
        console.log("After promise.then()");<br />
      </p>
      <p>
        <b
          >Если функция onResolve и onReject содержит сложную логику их для
          удобства объявляют как внешние вйнкции и передают в метод then() по
          имени. <br />
          Метод catch()</b
        >
        <br />
        На приктике в методе then() создаются только успешно выполненые promise
        а ошибки в его выполнении в специальном методе catch()
      </p>
      <img src="./images/catch-method.jpg" alt="" class="img" />
      <p>
        <b
          >promise.catch(error =>{ <br />
          // Отклоненный promise <br />
          })</b
        >
      </p>
      <p>
        callback функция будет вызвана в случае выполнения promise с ошибкой и
        получит ее в качестве аргумента.
      </p>
      <p class="bg">
        promise.then(value => { <br />
        console.log(value);<br />
        }).catch(error => {<br />
        console.log(error);<br />
        })<br />
      </p>
      <p>
        <b>Метод finally()</b><br />
        Этот метод может быть полезен если необходимо выполнить код после того
        как promise будет завершен в состояние fulfilled или reject независимо
        от результата, позволяет избежать дублирование кода обработчика then() и
        catch()
      </p>
      <img src="./images/finally-method.jpg" alt="" class="img" />
      <p class="bg">
        promise.finally(()=>{ <br />
        // promise выполнен или отклонен <br />
        })<br />
      </p>
      <p>
        callback функция не получит никаких аргуметов поскольку невозможно
        определить выполнен или отклонен promise
      </p>
      <p class="bg">
        promise.then(value => { <br />
        console.log(value);// Успех, значение передано в функцию resolve<br />
        }).catch(error => {<br />
        console.log(error);// Ошибка, значение передано в функцию reject<br />
        }).finally(() => {<br />
        console.log("Обещание(promise) выполнено");<br />
        })
      </p>
      <p>
        <b>Цепочка promise</b><br />
        Метод then() результатом свое исполнения возвращает еще 1 promise
        значением которого будет то, что вернет callback функция onResolve. Это
        позволяет строить асинхронные цепочки из promise.
      </p>
      <img src="./images/promise-chain.jpg" alt="" class="img" />
      <p>
        Поскольку метод then() возвращает promise перед выполнением может пройти
        некоторое время, поэтому часть оставшийся цепочки будет в ожидании. В
        случае возникновения ошибки в любом месте цепочки выполнение всех
        последующий then() прекратятся а управление передается методу catch(),
        поэтому он находится в конце цепочки promise
      </p>
      <p class="bg">
        const promise = new Promise((resolve, reject) => { <br />
        setTimeout(() => {<br />
        resolve(5)<br />
        }, 2000)<br />
        })<br /><br />

        promise.then(value => {<br />
        console.log(value);//5<br />
        return value * 2;<br />
        }).then(value => {<br />
        console.log(value);//10<br />
        return value * 3;<br />
        }).then(value => {<br />
        console.log(value);//30<br />
        }).catch(error => {<br />
        console.log(error);<br />
        }).finally(() => {<br />
        console.log("Final task");<br />
        })<br />
      </p>
      <p>
        Промисификация функции. Представим что у нас есть асинхронная функция
        которая выполняет некую асинхронную операцию, например запрос на сервер.
        Для того чтобы обработать результат ее прийдется спроэктировать таким
        образом что она будет ждать 2х callbacs для успешного запроса и для
        ошибки
      </p>
      <p class="bg">
        const fatchUserFromServer = (username, onSuccess, onError) => { <br />
        console.log(`Fatching data for ${username}`);<br />
        setTimeout(() => {<br />
        // Изменения значения переменной isSuccess для имитации статуса
        запроса<br />
        const isSuccess = true;<br />
        if (isSuccess) {<br />
        onSuccess('Success value');<br />
        } else {<br />
        onError('Error');<br />
        }<br />
        }, 2000);<br />
        };<br /><br />

        const onFatchSuccess = user => console.log(user);<br />
        const onFatchError = error => console.log(error);<br /><br />

        fatchUserFromServer('Ann', onFatchSuccess, onFatchError);//Fatching data
        for Ann<br />
        //Success value<br />
      </p>
      <p>
        Сейчас функция fatchUserFromServer() знает слишком много о том коде
        который будет использовать результат ее работы. Она ожидает callbacs и
        отвечает за их вызов при определенных условиях. Т.е мы передаем что-то
        внутрь функции (callbacs) и надеемся что оно отработает правильно.
        <br />
        Лучше если функция не учитывает код, который будет использовать ее
        результат. Она просто выполняет какую-нибудь операцию и возвращает
        результат своей работы во внешний код. Чтобы вернуть результат
        асинхронной операции из функции необходимо вернуть promise.
        Промисификация это преобразование функции с callbac таким образом чтобы
        она не принимала callbacs а возвращала promise.
      </p>
      <p class="bg">
        const fatchUserFromServer = username => { <br />
        return new Promise((resolve, reject) => {<br />
        console.log(`Fatching data for ${username}`);<br />
        setTimeout(() => {<br />
        const isSuccess = true;<br />
        if (isSuccess) {<br />
        resolve("Success value")<br />
        } else {<br />
        reject(error)<br />
        }<br />
        },2000)<br />
        })<br />
        };<br /><br />

        fatchUserFromServer('Petya')<br />
        .then(user => console.log(user))<br />
        .catch(error => console.error(error));<br />
      </p>
      <p>
        <b
          >Большинство современных библиотек основывается на promise. В случае
          вызова метода для асинхронной операции его результат доступен в
          качестве promise к которому можно прицепить обработчики в методах
          then() и catch()</b
        >
      </p>
    </section>
    <script src="./js/moduleNine.js"></script>
    <!-- <script src="./js/promise.js"></script> -->
  </body>
</html>

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 2</title>
  </head>
  <body>
    <main>
      <section class="container">
        <h3 class="title">Массивы</h3>
        <p>
          <b>Массив</b> - структура данных для хранения и манипулирования
          коллекций индексированых значений. Используется для храннения
          упорядоченых коллекций данных, например списка курортов, товаров,
          клиентов в гостиннице и т.д <br />
          <b>Создание</b> <br />
          Массив объявляется и берется в квадратные скобки [] - литералом
          массива. Внутри скобок каждый элемент массива разделяется запятой
        </p>
        <p class="bg">const clients = ["Vasya", "Ann", "Polya"];</p>
        <p>
          <b>Доступ к элементам</b> <br />
          Для доступа к значению элемента массива используется синтаксис [] -
          массив[индекс 0...]. Между именем и переменной, хранящей массив, и []
          не должно быть пробела.
        </p>
        <p class="bg">
          const clients = ['Vasya', 'Ann', 'Polya']; <br />
          console.log(clients[0], clients[2]);<br />
          console.log(clients[1]);<br />
          console.log(clients[2]);<br />
        </p>
        <p>Индексация частей массива начинается с 0</p>
        <img src="./images/indices.jpg" alt="" class="img" />
        <p>
          <b>Переопределение</b> <br />
          В отличии от строк элементы массива можно изменять, обратившись к ним
          по индексу и присвоить другое значение
        </p>
        <p class="bg">
          const clients = ["Vasya", "Ann", "Polya"]; <br />
          clients[0] = "Petya"; <br />
          clients[1] = "Vasya" <br />
          console.log(clients);// ["Petya", "Vasya", "Polya"]
        </p>
        <p>
          <b>Длинна массива</b> <br />
          Длина массива, т.е количество его элементов, сохраняется в свойстве
          length. Это динамическая величина, которая меняется автоматически при
          добавлении или удалении элементов
        </p>
        <p class="bg">
          const clients = ["Vasya", "Ann", "Polya"]; <br />
          console.log(clients.length);//3
        </p>
        <p>
          <b>Индекс последнего элемента</b><br />
          Чаще всего мы заранее не знаем какова будет длинна массива в коде. Для
          того чтобы получить значение последнего элемента, применяется след
          подход - длинна массива всегда на еденицу больше, чем индекс
          последнего элемента. Используя формулу длинна_массива - 1, можно
          получить значение последнего элемента массива произвольной длинны
        </p>
        <p class="bg">
          const clients = ['Vasya', 'Ann', 'Polya']; <br />
          const lastElement = clients.length - 1;<br />
          console.log(lastElement);//2<br />
          console.log(clients[lastElement]);//Polya<br />
        </p>
        <p><b>Итерация по массиву</b> <br /></p>

        <p>
          <b>Цикл for</b> - можно использовать для итерации по массиву, т.е
          перебор его по элементно
        </p>

        <p class="bg">
          const clients = ['Vasya', 'Ann', 'Polya']; <br /><br />

          for (let i = 0; i < clients.length; i += 1) { <br />
          console.log(clients[i]); <br />
          }
        </p>
        <p>
          Для доступа к элементам используется синтаксис квадратных скобок
          массив[индекс], где индекс это значение счетчика цикла с 0 и до
          последнего индекса массива, т.е меньшее но не равное его длинне
        </p>
        <p>
          <b>Цикл for...of</b><br />
          Конструкция for..of обявляет цикл перебирающий итерабельные объекты,
          например массив и строки. Тело цикла будет производится для значения
          каждого элемента. Это хорошая замена цикла for если не требуется
          доступ к счетчику итерации
        </p>
        <p class="bg">
          for (const variable of iterable) { <br />
          //тело цикла <br />
          }
        </p>
        <ul>
          <li>
            <b>variable</b> - переменная которая сохраняет значение элемента на
            каждой итерации.
          </li>
          <li>
            <b>iterable</b> - коллекция содержащая итерабельные (что можно
            посчитать) элементы, например массив
          </li>
        </ul>
        <p class="bg">
          const clients = ['Vasya', 'Ann', 'Polya']; <br /><br />

          for (client of clients) {<br />
          console.log(client);<br />
          }<br /><br />

          const string = "JS";<br /><br />

          for (const character of string) {<br />
          console.log(character);<br />
          }<br />
        </p>
        <p>
          <b>Операторы break и continue</b><br />
          Будем искать имя клиента в массиве имен, если нашли - прерывается
          цикл, поскольку нет смысла искать дальше, имена у нас уникальные
        </p>
        <p class="bg">
          const clients = ['Vasya', 'Ann', 'Polya']; <br />
          const clietsNameFind = "Ann";<br />
          let message;<br /><br />

          for (client of clients) {<br />
          //На каждой итерации будет проверять совпадает ли элемент массива с
          именем клиента, если совпадает, запишем в message<br />
          //Про успех и работу break чтобы дальше не искать<br /><br />

          if (client === clietsNameFind) {<br />
          message = 'Client found';<br />
          break;<br />
          }<br /><br />

          //Если они не совпадают записываем message об отсутствии имени<br /><br />

          message = "Client not found";<br />
          }<br />
          console.log(message);<br />
        </p>
        <p>
          Можно сначала задать message значение неудачи поиска а в цикле
          перезаписать его на упех, если нашли имя. Но break все равно нам
          понадобится, поскольку если у нас массив из 1000 клиентов, а нужный
          нам находится на 2й позиции, то нет никакого смысла перебирать
          оставшиеся элементы
        </p>
        <p class="bg">
          const clients = ['Vasya', 'Ann', 'Polya']; <br />
          const clietsNameFind = 'Ann';<br />
          let message = "Client not found";<br /><br />

          for (const client of clients) {<br />
          if (client === clietsNameFind) {<br />
          message = "Client found";<br />
          break;<br />
          }<br />
          //Если не совпадает, то на этой итерации ничего не делается<br />
          }<br />
          console.log(message);<br />
        </p>
        <p>
          Используем цикл для вывода чисел только больше определенного значения
        </p>
        <p class="bg">
          const numbers = [1, 3, 14, 18, 4, 7, 29, 6, 34]; <br />
          const threshold = 15;<br /><br />

          //Для чисел меньше порогового значения срабатывает continue.
          Выполнение тела прекращается и управление <br />передается на след
          итерацию<br /><br />

          for (let i = 0; i < numbers.length; i += 1){<br />
          if (numbers[i] < threshold) {<br />
          continue;<br />
          } <br />
          console.log(`Число больше ${threshold} : ${numbers[i]}`);<br />
          }
        </p>
        <h3 class="title">Присвоение по ссылке и значению</h3>
        <p>
          Фундаментальным отличаем сложных типов от примитивов является то как
          они хранятся и копируются. Примитивы: строки, числа, були, null,
          underfind, при присвоении полностью копируется по значению (by value)
          <br />
          Со сложными типами все по другому. В переменной, котрой присвоен
          массив или объект сохраняется не само значение, а адрес его места и
          памяти, иными словами - ссылка (указатель) на него и они передаются по
          ссылке (by reference) <br />
          Представим переменную в виде листа бумаги. Ее значени мы представим
          как запись на этом листе
        </p>
        <img src="./images/original.svg" alt="" class="img" />
        <p>
          Если мы захотим сообщить содержание этой записи пользователю, то можем
          это сделать след образом - сделать физические копии и вручить каждому,
          т.е сделать много независимых копий (присвоение по значению)
        </p>
        <img src="./images/by-value.svg" alt="" class="img" />
        <p>
          Или положить лист в закрытой комнате и дать ключ к этой комнате, т.е
          один экземпляр с общим доступом (присвоение по ссылке)
        </p>
        <img src="./images/by-reference.svg" alt="" class="img" />
        <p>
          Теперь изменим данные на листе бумаги - значение переменной. Очевидно
          что посетители всегда будут видеть изменения, которые мы вносим,
          поскольку меняется оригинал и иони имеют к нему доступ. И так же
          очевидно что владельцы бумажных копий не заметят перемен, глядя на
          свои копии.
        </p>
        <p>
          При передачи по значению переменной выделяется новая ячейка памяти и в
          нее копируются данные. Аналогия со многими копиями бумажного листа
          имеет реальное воплощение - отдельный лист для каждой копии. <br />
          При передаче по ссылке, вместо создания нового объекта переменной
          присваивается ссылка (указатель) на уже существующий объект, т.е на
          его место в памяти. Таким образом несколько переменных могут указать
          на один и тот же объект, по аналогии с закрытой комнатой, они имеют
          ключ доступа к оригиналу листа <br />
          Все типичные типы присваиваются по значению, другими словами создается
          копия
        </p>
        <p class="bg">
          let a = 5; <br /><br />

          //Присвоение по значению в памяти будет создана еще 1 ячейка, в
          которую будет скопировано значение 5<br /><br />

          let b = a;<br />
          console.log(a);//5<br />
          console.log(b);//5<br /><br />

          //Изменим значение a<br /><br />

          a = 10;<br />
          console.log(a);//10<br /><br />

          //Значение b не изменилось поскольку это отдельная копия<br /><br />

          console.log(b);//5<br />
        </p>

        <p>
          <b>Сложные типы</b> - объекты, массивы, функции присваиваются по
          ссылке, т.е переменная получает ссылку на уже существующий объект
        </p>
        <p class="bg">
          const a = ['Ann']; <br /><br />

          //Поскольку а это массив в b записывается ссылка на уже существующий
          массив в памяти. Теперь a и b <br />указывают на один и тот же
          массив<br /><br />

          const b = a;<br />
          console.log(a); //["Ann"]<br />
          console.log(b); //["Ann"]<br /><br />

          //Изменим массив - добавим еще 1 элемент, используя указатель из а<br />

          a.push('Vasya');<br />
          console.log(a); //[ 'Ann', 'Vasya' ]<br /><br />

          //b так же изменилась, потому что b как и а просто содержит ссылку на
          то же место в памяти<br /><br />

          console.log(b); //[ 'Ann', 'Vasya' ]<br /><br />

          //Результат повторяется<br /><br />

          b.push('Petya');<br />
          console.log(a);//['Ann', 'Vasya', 'Petya']<br />
          console.log(b);//[ 'Ann', 'Vasya', 'Petya']<br />
        </p>
        <h3 class="title">Методы массивов</h3>
        <p>
          <b>Методы split() и join()</b><br />
          <b>Метод split(delimiter)</b> превращает строку в массив, разбивая его
          разделителем delimeter. Если разделитель это пустая строка, то
          создается массив отдельных символов. Разделителем можЕТ быть один или
          несколько символов
        </p>
        <p class="bg">
          const name = 'Mango'; <br />
          console.log(name.split('')); //[ 'M', 'a', 'n', 'g', 'o' ]
          <br /><br /><br />
          const message = 'JS - is awesome'; <br />
          console.log(message.split(' '));//[ 'JS', '-', 'is', 'awesome' ]
        </p>
        <p>
          <b>Метод массива join (delimiter)</b> <br />
          Объеденяет элементы массива в строку, в строке элементы будут
          разделены символом или группой символов, указанных в delimiter.
        </p>
        <p class="bg">
          const message = ['JS', '-', 'is', 'awesome']; <br />
          console.log(message.join('')); //JS-isawesome<br />
          console.log(message.join(' ')); //JS - is awesome<br />
          console.log(message.join('-'));//JS---is-awesome<br />
        </p>
        <p>
          <b>Метод indexOf(value)</b><br />
          Возвращает первый индекс, в котором элемент со значением value был
          найден в массиве или число - 1, если такой элемент отсутствует
          используется indexOf() когда необходимо получить сам индекс элемента
        </p>
        <p class="bg">
          const clients = ["Ann", "Petya", "Vasya", "Polina"]; <br />
          console.log(clients.indexOf("Vasya"));//2 <br />
          console.log(clients.indexOf("Ignat"));//-1 <br />
        </p>
        <p>
          <b>Метод includes(value)</b><br />
          Проверяет содержит ли массив элемент со значением value, возвращает
          true или false. Применение этого способа полезно в ситуациях, когда
          нужно проверить есть ли элемент в массиве и не принципиальна его
          позиция (index)
        </p>
        <p class="bg">
          const clients = ["Ann", "Petya", "Vasya", "Polina"]; <br />
          console.log(clients.includes("Ann"));//true <br />
          console.log(clients.includes('Ignat'));//false
        </p>
        <p>Проверка многих условий includes</p>
        <p class="bg">
          // Запишем один из способов который на первый взгляд выглядит хорошо
          <br />
          const fruit = "Apple"; <br /><br />

          if (fruit === "Apple" || fruit === "Strawberry") {<br />
          console.log("It is a red fruit");<br />
          }<br />
        </p>
        <p>
          Однако что делать если у нас больше красных фруктов, например вишня
          или клюква? Будем ли мы расширять условие с помощью дополнительных ||
        </p>
        <p class="bg">
          const fruit = 'Apple'; <br /><br />

          if (fruit === "Apple" || fruit === "Strawberry" || fruit === "Cherry"
          || fruit === "Cranberries") {<br />
          console.log("It is a red fruit");<br />
          }<br />
        </p>
        <p>
          Модем перепесить условие используя includes(), это очень просто и
          масштабируемо
        </p>
        <p class="bg">
          const redFruits = ["Apple", "Strawberry", "Cherry", "Cranberries"];
          <br />
          const fruit = "Cherry";<br /><br />

          const hasFruit = redFruits.includes(fruit);<br /><br />

          if (hasFruit) {<br />
          console.log(`${fruit} is a red fruit`);//Cherry<br />
          }<br />
        </p>
        <p>
          <b>Методы push() и pop()</b> <br />
          Добавляют или удаляют крайние элементы массива. Работают только с
          крайним левым и крайним правым элементом массива и не могут вставить
          или удалить элемент из произвольной позиции
        </p>
        <img src="./images/arr-method.jpg" alt="" class="img" />
        <p>
          <b>Метод push()</b><br />
          Добавляет один или несколько элементов в конец массива без
          необходимости указывать индекс прилегаемых элементов
        </p>
        <img src="./images/puh.jpg" alt="" class="img" />
        <p class="bg">
          const numbers = []; <br /><br />

          numbers.push(1);<br />
          console.log(numbers); //[ 1 ]<br /><br />

          numbers.push(2);<br />
          console.log(numbers); //[ 1, 2 ]<br /><br />

          numbers.push(3);<br />
          console.log(numbers); //[ 1, 2, 3 ]<br /><br />

          numbers.push(4);<br />
          console.log(numbers); //[ 1, 2, 3, 4 ]<br /><br />

          numbers.push(5);<br />
          console.log(numbers); //[ 1, 2, 3, 4, 5 ]<br /><br />

          numbers.push(6);<br />
          console.log(numbers);//[ 1, 2, 3, 4, 5, 6 ]<br /><br />
        </p>
        <p>
          <b>Метод pop()</b><br />
          Удаляет последний элемент из конца массива и возвращает удаленный
          элемент. Если массив пуст метод возвращает underfind
        </p>
        <p class="bg">
          const numbers = [1, 2, 3, 4, 5]; <br /><br />

          console.log(numbers.pop());<br />
          console.log(numbers); //[ 1, 2, 3, 4 ]<br /><br />

          console.log(numbers.pop());<br />
          console.log(numbers); //[ 1, 2, 3 ]<br /><br />

          console.log(numbers.pop());<br />
          console.log(numbers); //[ 1, 2 ]<br /><br />

          console.log(numbers.pop());<br />
          console.log(numbers); //[1]<br /><br />

          console.log(numbers.pop());<br />
          console.log(numbers);//[]<br /><br />
        </p>
        <p>
          <b>Метод slice(begin, end)</b><br />
          Возвращает новый массив, содержащий копию части исходного массива, не
          изменяя его. Копия создается из значения begin и до end включительно;
          это индексы элементов исходного массива
        </p>
        <img src="./images/slice.jpg" alt="" class="img" />
        <p class="bg">
          const clients = ['Ann', 'Petya', 'Vasya', 'Polina']; <br /><br />

          console.log(clients.slice(1, 3));//[ 'Petya', 'Vasya' ]
        </p>
        <p>
          Если begin и end не указаны будет создана полная копия исходного
          массива
        </p>
        <p class="bg">
          const clients = ['Ann', 'Petya', 'Vasya', 'Polina']; <br /><br />

          console.log(clients.slice());//[ 'Ann', 'Petya', 'Vasya', 'Polina' ]
        </p>
        <p>
          Если не указана end копирование будет сокращаться из begin и до конца
          исходного массива
        </p>
        <p class="bg">
          const clients = ['Ann', 'Petya', 'Vasya', 'Polina']; <br /><br />

          console.log(clients.slice(1));//[ 'Petya', 'Vasya', 'Polina' ] <br />
          console.log(clients.slice(2));//[ 'Vasya', 'Polina' ]
        </p>
        <p>
          Если значение begin отрицательное а end не указано, будут скопированы
          последние begin элементы (c конца)
        </p>
        <p class="bg">
          const clients = ['Ann', 'Petya', 'Vasya', 'Polina']; <br /><br />

          console.log(clients.slice(-2));//[ 'Vasya', 'Polina' ]
        </p>
        <p>
          <b>Метод splice()</b><br />
          Splice() для работы с массивами, если необходимо изменить исходный
          массив. Удаляет, добавляет и заменяет элементы в любом месте массива
          <br />
          <b>Удаление</b> <br />
          Чтобы удалить элементы в массиве передаются два аргумента -
          splice(position, num)
        </p>
        <p class="bg">splice(position, num)</p>
        <ul>
          <li>
            <b>Position</b> - указывает позицию (index) первого элемента для
            удаления
          </li>
          <li><b>Num</b> - определяет колличество удаляемых элементов</li>
        </ul>
        <p>
          Метод splice() изменяет исходный массив и возвращает массив содержащий
          удаленные элементы. К примеру у нас есть массив оценок, содержащий
          пять чисел от 1 до 5
        </p>
        <p class="bg">
          const scores = [1, 2, 3, 4, 5]; <br /><br />

          // Удаляем три элемента массива начиная с первого элемента (index
          0)<br />
          const deleteScores = scores.splice(0, 3);<br /><br />

          // Теперь массив scores содержит два элемента<br />
          console.log(scores);// [ 4, 5 ]<br /><br />

          // А массив deleteScores содержит три удаленных элементов<br />
          console.log(deleteScores);// [ 1, 2, 3 ]<br />
        </p>
        <p>На изображении показан вызов методов score.splice(0, 3)</p>
        <img src="./images/splice-remove.jpg" alt="" class="img" />
        <p class="information">
          На практике возвращаемое значение (массив удаленных элементов)
          используется редко. Предпочтительно просто удалить элементы из массива
        </p>
        <p>
          <b>Добавление</b><br />
          Для того чтобы добавить один или несколько элементов в массив
          необходимо передать три или более аргумента, при таком условии, второй
          аргумент должен быть равен нулю
        </p>
        <p class="bg">splice(position, 0, newElement_1, newElement_2, ...)</p>
        <ul>
          <li>
            Аргумент position указывает исходную позицию в массиве, куда будут
            вставлены новые элементы
          </li>
          <li>
            Второй аргумент это 0. Он говорит методу не удалять элементы в месте
            добавления новых
          </li>
          <li>
            Третий и последующие аргументы - это новые элементы, которые
            добавляются в массив
          </li>
        </ul>
        <p>
          К примеру у нас есть массив с названиями цветов в виде строк. Добавим
          новый цвет с элементом с индексом 2
        </p>
        <p class="bg">
          const colors = ['red', 'green', 'blue']; <br />
          colors.splice(2, 0, 'black'); <br />
          console.log(colors);//[ 'red', 'green', 'black', 'blue' ]
        </p>
        <p>На рисунке показан вызов метода colors.splice(2, 0 , "Purple")</p>
        <img class="img" src="./images/splice-insert.jpg" alt="" />
        <p>
          Можно добавить любое количество элементов передав 4, 5 аргумент и т.д
        </p>
        <p class="bg">
          const colors = ['red', 'green', 'blue']; <br />
          colors.splice(1, 0, 'yellow', 'pink'); <br />
          console.log(colors);//[ 'red', 'yellow', 'pink', 'green', 'blue' ]
        </p>
        <p>
          <b>Замена</b><br />
          Это операция добавления в которой удаляются элементы вместо добавления
          новых. Для этого необходимо передать минимум три аргумента,
          колличество удаляемых и добавляемых элементов может не совпадать.
        </p>
        <p class="bg">splice(position, num, newElement_1, newElement_2, ...)</p>
        <ul>
          <li>
            Position указывает позицию (index) первого элемента для удаления
          </li>
          <li>Num определяет колличество удаляемых элементов</li>
          <li>
            3й, 4й и последующие аргументы - это новые жлементы, которые
            добавляются в массив
          </li>
        </ul>
        <p class="bg">
          const languages = ['Js', 'C++', 'C', 'C#', 'Java']; <br /><br />

          //Заменяем элемент с индексом 1 на новый<br />
          languages.splice(1, 1, 'Pyton');<br />
          console.log(languages); //[ 'Js', 'Pyton', 'C', 'C#', 'Java' ]<br /><br />

          // Заменяем один элемент с индексом 2 на несколько<br />
          languages.splice(2, 1, 'Swift', 'Go');<br />
          console.log(languages);//[ 'Js', 'Pyton', 'Swift', 'Go', 'C#', 'Java'
          ]<br />
        </p>
        <img src="./images/splice-replace.jpg" alt="" class="img" />
        <p>
          <b>Метод concat()</b> объеденяет два или более массивов в один. Он не
          меняет массив на котором вызывается, а возвращает новый. Порядок
          аргументов способа оказывает влияние на порядок частей нового элемента
        </p>
        <p class="bg">
          const oldClients = ['Vasya', 'Petya', 'Ann', 'Jora']; <br />
          const newClients = ['Polna', 'Max'];<br /><br />

          const allClientsWithOldFirst = oldClients.concat(newClients);<br />
          console.log(allClientsWithOldFirst); //[ 'Vasya', 'Petya', 'Ann',
          'Jora', 'Polna', 'Max' ]<br /><br />

          const allClientsWithNewFirst = newClients.concat(oldClients);<br />
          console.log(allClientsWithNewFirst); //[ 'Polna', 'Max', 'Vasya',
          'Petya', 'Ann', 'Jora' ]<br /><br />

          console.log(oldClients);//['Vasya', 'Petya', 'Ann', 'Jora'];<br />
          console.log(newClients);//['Polna', 'Max'];<br />
        </p>
        <h3 class="title">Функции</h3>
        <p>
          Функции это подпраграмма, независимая часть кода, предназначеная для
          многократного выполнения конкретной задачи с разными начальными
          значениями. Функции позволяют структуировать обширные программы,
          уменьшают повторения и изолируют код <br /><br />
          Функцию можно представить в виде черного ящика. Она получает что то на
          входе(данные) и возвращает что-то на выходе (резальтат выполнения кода
          внутри нее)
        </p>
        <img src="./images/fn-basic.jpg" alt="" class="img" />
        <p><b>Объявление функций</b></p>
        <p class="bg">
          // 1. Объявление функции multiply
          <br />
          function multiply() {<br />
          // тело функции<br />
          console.log('This is decloration function multiply');<br />
          }<br /><br />

          // 2. Вызов фунции multiply<br />
          multiply();//This is decloration function multiply<br />
          multiply();//This is decloration function multiply<br />
          multiply();//This is decloration function multiply<br />
        </p>
        <p>
          <b>Объявление функций (Function declaration)</b><br />
          Начиная с ключевого слова function, после которого стоит имя - глагол,
          на вопрос отвечающий "что сделать?" и пара круглых скобок () <br />
          Тело функции берется в фигурные скобки {} и содержит инструкции
          которые необходимо выполнить на момент вызова. Затем когда необходимо,
          функция вызывается с помощью имени и пары круглых скобок
          <br /><br /><b>Параметры и аргументы</b><br />
          В круглых скобках после имени функции указываем параметры - список
          данных, которые функция ожидает на момент вызова
        </p>
        <p class="bg">
          // Объявление параметров x, y, z
          <br />
          function multiply(x, y, z) {<br />
          console.log(`Результат умножения равен ${x*y/z}`);<br />
          }<br /><br />

          multiply(15, 3, 2);
        </p>
        <p>
          <b>Параметры</b> - это локальные параметры, доступные только в теле
          функции, они разделяются запятыми. Параметров может быть несколько или
          вообще не быть, в таком случае записываются просто пустые круглые
          скобки
        </p>
        <p class="information">
          Параметры будут создаваться каждый раз во время выполнения функции и
          их отдельной итерации, никак друг с другом не связаны
        </p>
        <p>
          На момент вызова в круглых скобках можно передать аргументы - значения
          для объявленных параметров функции
        </p>
        <p class="bg">
          // 1. Объявление параметров
          <br />
          function multiply(x, y, z) {<br />
          console.log(`Результат умножения равен ${(x * y) / z}`);<br />
          }<br /><br />

          // 2. Передача аргументов<br />
          multiply(15, 3, 2); //22,5<br />
          multiply(5, 3, 1); //15<br />
          multiply(11, 2, 2); //11<br />
        </p>
        <p class="information">
          Порядок передачи аргументов должен соответствовать порядку объявленных
          параметров. Значение первого аргумента будет присвоено первому
          паметру, второму - второй и т.д. Если если параметров будет больше
          аргументов, то параметрам без значений будет присвоено idefind
        </p>
        <p>
          <b>Возврат значения</b><br />
          Оператор return используется для передачи значения из тела функции во
          внешний код. Когда инорпритатор встречает return он сразу же выходит
          из функции (прекращает ее выполнение) и возвращает указанное значение
          в то место кода где была вызвана функция
        </p>
        <p class="bg">
          function multiply(x, y, z) { <br />
          // Возвращаем результат выражения умножения<br />
          return x * y * z;<br />
          console.log(`Этот лог никогда не выполнится, он стоит после
          return`);<br />
          }<br /><br />

          // Результат работы функции можно сохранить в переменную<br /><br />

          let result = multiply(2, 3, 4);<br />
          console.log(`Результат умножения равен: ${result}`); //Результат
          умножения равен: 24<br /><br />

          result = multiply(5, 6, 1);<br />
          console.log(`Результат умножения равен: ${result}`); //Результат
          умножения равен: 30<br /><br />

          result = multiply(3, 3, 1);<br />
          console.log(`Результат умножения равен: ${result}`); //Результат
          умножения равен: 9<br />
        </p>
        <p class="information">
          Оператор return без явно указаного значения возвращает специальное
          значение udefind. При отсутствии return в теле функции она все равно
          вернет undefind
        </p>
        <p>
          <b>Порядок выполнения кода</b><br />
          Когда интерпритатор встречает вызов функции или метода он
          приостанавливает выполнение текущего кода и начинает выполнять код из
          тела функции. После того как весь код функции будет исполнен
          инторпритатор выходит из тела функции, возвращаясь в то место откуда
          пришел и продолжает выполнять код, следующий после вызова функции
        </p>
        <p class="bg">
          function multiply(x, y, z) { <br />
          console.log(`Результат умножения равен ${(x * y) / z}`);<br />
          }<br /><br />

          console.log('Лог к вызову функции multiply ');<br />
          multiply(1, 2, 3); // результат<br />
          console.log('Лог после вызова функции multiply');<br /><br />

          // Последовательность логов в консоли<br />
          // "Лог к вызову функции multiply"<br />
          // "Результат функции"<br />
          // "Лог после вызова функции multiply"<br />
        </p>
        <p>
          <b>Параметры по умолчанию</b><br />
          Иногда необходимо объявить функцию у которой будут значения отличимые
          от undefind, даже если для них не передали аргументы. Это делается
          очень простым и очевидным образом - достаточно указать значения по
          умолчанию, непосредственно на момент объявления параметров в подписи
          функции. В случае такой записи если для параметров не было передано
          значение аргумента используется значение по умолчанию
        </p>
        <p class="bg">
          function count(countForm = 0, countTo = 10, step = 1) { <br />
          console.log(`countForm = ${countForm}, countTo = ${countTo}, step =
          ${step}`);<br /><br />

          for (let i = countForm; i <= countTo; i += step) {<br />
          console.log(i);<br />
          }<br />
          }<br /><br />

          count(2, 3); //countForm = 2, countTo = 3, step = 1 // 2..3<br />
          count(2); //countForm = 2, countTo = 10, step = 1 // 2..10<br />
          count(); //countForm = 0, countTo = 10, step = 1 // 0..10<br />
        </p>
        <p>
          <b>Псевдо массив arguments</b><br />
          Доступ к списку всех аргументов можно послучить с помощью специальной
          переменной arguments, которая доступна только внутри функции и
          сохраняет все аргументы в качестве псевдомассива <br />
          <br />
          <b>Псевдомассив</b> - коллекция со свойством length и возможностью
          обратиться к элементу за индексом, но отсутствием большинства методов
          для работы с массивом <br />
          Рассмотрим пример использования arguments в функции, умножающей любое
          колличество аргументов
        </p>
        <p class="bg">
          function multiply() { <br />
          let total = 1;<br /><br />

          for (const argument of arguments) {<br />
          total *= argument;<br />
          }<br />
          return total;<br />
          }<br /><br />

          console.log(multiply(5)); //5<br />
          console.log(multiply(1, 4, 5)); //20<br />
          console.log(multiply(3, 6, 8, 3, 1)); //432<br />
          console.log(multiply());//1
        </p>
        <p>
          <b>Превращение псевдомассива</b><br />
          Обычно псевдомассив необходимо превратить в полноценный массив,
          поскольку у псевдомассива отсутствуют методы массива, например slice()
          или includes(). На практике используют несколько главных методов.
          Используя метод <b>Array.form()</b> который создаст массив из
          псевдомассива
        </p>
        <p class="bg">
          function fn() { <br />
          // Переменная args будет содержать полноценный массив<br />
          const args = Array.from(arguments);<br />
          }<br />
        </p>
        <p>
          Используя операцию "...(rest)", она позволяет собрать любое
          колличество элементов, в нашем случае аргументов в массив и сохранить
          его в переменную. Собираем все доводы используя операцию rest
          непосредственно в подписи функции
        </p>
        <p class="bg">
          function fn(...args) { <br />
          // Переменная args будет содержать полноценный массив <br />
          }
        </p>
        <p class="information">
          Операция rest более подробно рассматривается далее
        </p>
        <p>
          <b>Pattern "Раннее возвращение"</b><br />
          Оператор if..else это основной способ создания разветвлений. Однако
          сложные вложенные разветвления делают код сложным для понимания
          <br /><br />
          Создадим функцию, обрабатывающую снятие средств с личного счета в
          банке, она получает сумму для снятия и текущий баланс счета, после
          чего, в зависимости от условия, выполняет необходимый блок кода
        </p>
        <p class="bg">
          function widthDraw(amount, balance) { <br />
          if (amount === 0) {<br />
          console.log('Для проведения опрерации введите сумму больше 0');<br />
          } else if (amount > balance) {<br />
          console.log('Недостаточно средств на счете');<br />
          } else {<br />
          console.log('Операция прошла успешно');<br />
          }<br />
          }<br /><br />

          widthDraw(0, 300); //Для проведения опрерации введите сумму больше
          0<br />
          widthDraw(550, 300); //Недостаточно средств на счете<br />
          widthDraw(100, 300); //Операция прошла успешно<br />
        </p>
        <p>
          Даже в таком простом примере есть группа вложенных условий оператора,
          среди которых не сразу можно понять логику выполнения кода
          <br /><br />
          У функции может быть больше одного оператора return. Главное помнить
          что выполнение функции прерывается, когда инторпритатор встречает
          возврат и весь код после него будет проигнорирован в текущем
          выполнении функции <br /><br />
          <b>Паттерн "ранний возврат"</b> это способ использовать возможность
          досрочноего возвращения из функции с помощью оператора return.
          Используя этот прием мы получаем более чистый, плоский, понятный код,
          который проще рефакторить <br /><br />
          Выделим все проверки условий в отдельный оператор if, после чего
          добавим находящийся в теле код else. В идеальном случае должен
          получиться плоский список условий оператора следующий один за другим,
          а в конце блок, который выполнится только в том случае если не
          выполнится ни один if
        </p>
        <p class="bg">
          function widthDraw(amount, balance) { <br />
          // Если условие выполнится вызывается консоль лог<br />
          // И выход из функции. Код после тела if не выполнится<br />
          if (amount === 0) <br />
          console.log('Для проведения опрерации введите сумму больше 0');<br />
          return;<br />
          }<br /><br />

          // Если условие первого if не выполнилось то его тело пропускается и
          инторпритатор доходит до второго if<br />
          // Если условие выполняется - вызывается консоль лог и выходит из
          функции<br />
          // Код, находящийся после тела if не выполняется<br /><br />

          if (amount > balance) {<br />
          console.log('Недостаточно средств на счете');<br />
          return;<br />
          }<br /><br />

          //Если ни один из предыдущих if не выполнился то инторпритатор доходит
          до этого кода и выполняет его<br /><br />

          console.log('Операция прошла успешно');<br />
          }<br /><br />

          widthDraw(0, 300); //Для проведения опрерации введите сумму больше
          0<br />
          widthDraw(550, 300); //Недостаточно средств на счете<br />
          widthDraw(100, 300); //Операция прошла успешно<br />
        </p>
        <h3 class="title">Функциональные выражения</h3>
        <p>
          Функциональные выражения (function expression) обычно объявляются
          переменной, значением которой будет функция, альтернативный способ
          объявления функции
        </p>
        <p class="bg">
          // Объявление функции (function declaration)
          <br />
          function multiply(x, y, z) { <br />
          console.log(`Результат умножения равен ${x * y * z}`); <br />
          } <br />
          <br />

          // Функциональное выражение (function expression) <br />
          const multiply = function (x, y, z) { <br />
          console.log(`Результат умножения равен ${x * y * z}`); <br />
          };
        </p>
        <p>
          Разница в том, что функциональное выражение нельзя вызвать до его
          создания, только после него, потому что буквально объявляется const
          переменная
        </p>
        <p class="bg">
          // ❌ Помилка! Не працює виклик до оголошення <br />
          multiply(1, 2, 3);<br /><br />

          const multiply = function (x, y, z) {<br />
          console.log(`Результат множення дорівнює ${x * y * z}`);<br />
          };<br /><br />

          // ✅ Працює виклик після оголошення<br />
          multiply(4, 5, 6);<br />
        </p>
        <p>А объявление функции можно вызвать до места ее создания в коде</p>
        <p class="bg">
          // ✅ Працює виклик до оголошення <br />
          multiply(1, 2, 3);<br /><br />

          function multiply(x, y, z) {<br />
          console.log(`Результат множення дорівнює ${x * y * z}`);<br />
          }<br /><br />

          // ✅ Працює виклик після оголошення<br />
          multiply(4, 5, 6);
        </p>
        <p>
          <b>Область видимости (scope)</b><br />
          Механизм, который определяет доступность переменных в коде, которые
          выполняются. <br />
          Цепочка областей видимости (scope chain) - область видимости создает
          иерархии, которые дочерние области имеют доступ к переменным
          родительских областей, а не наоборот <br /><br />
          <b>Глобальная область видимости</b>. Переменные объявленные на
          наивысшем уровне, т.е за границами каких либо конструкций на примере
          if, while, for и функций находящихся в глобальной области видимости
          доступны везде после их оглашения
        </p>
        <p class="bg">
          const globalValue = 10; <br />
          console.log(globalValue);//10<br /><br />

          function foo() {<br />
          console.log(globalValue);//10<br />
          }<br /><br />

          for (let i = 0; i < 5; i++) {<br />
          console.log(globalValue);//10<br /><br />

          if (i === 2) {<br />
          console.log(globalValue);//10<br />
          }<br />
          }<br />
        </p>
        <p>
          Блочная область видимости. Переменные объявленные в инструкции if,
          for, функций и других блоках кода, взятых в {} находятся в блочной
          области видимости и доступны только в середине блока кода или его
          секции, вложенных в него
        </p>
        <p class="bg">
          function foo() { <br />
          const a = 20;<br />
          console.log(a); //20<br /><br />

          for (let i = 0; i < 5; i++) {<br />
          console.log(a); //20<br />
          if (i === 2) {<br />
          console.log(a); //20<br />
            }<br />
           }<br />
          }
        </p>
        <p>
          Это можно представить в виде дома с комнатами. Дом находится в
          глобальной области видимости. Каждая функция и блок создают новую
          комнату, вложенную в середину дома. Переменные объявленные в центре
          этих комнат доступны только тогда, когда вы находитесь внутри этих
          комнат, за границами комнат эти переменные не доступны
        </p>
        <p class="bg">
          for (let i = 0; i < 5; i++){ <br />
          const a = 20;<br /><br />

          console.log(a);//20<br /><br />

          if (i === 2) {<br />
          const b = 30;<br /><br />

          console.log(a);//20<br />
          console.log(b);//30<br />
          }<br /><br />

          if (i === 3) {<br />
          console.log(a);//20<br />
          }<br />
          }<br />
        </p>
        <p>
          <b>Поиск по цепочке областей видимости</b><br />
          Инторпритатор пытается сначала найти переменную в той области
          видимости в которой к ней обратился. Если такая переменная в локальной
          области видимости отсутвует то он выходит на уровень выше, на 1
          уровень за 1 попытку, пока не найдет значчение или дойдет до
          максимальной области видимости (глобальной) и поймет, что переменной с
          таким модификатором не существует, в таком случае возникает ошибка,
          что переменная не объявлена
        </p>
        <img src="./images/scope-chain-search.png" alt="" class="img" />
        <h3 class="title">Стэк вызовов</h3>
        <p>
          На момент вызова функции в середине ее тела могут вызываться другие
          функции, в середине тех функций еще одни. JS - однопоточный язык, т.е
          за 1 еденицу времени может выполнятся только 1 инструкция. Это
          означает что вызванные функции, которые не закончили свое выполнение
          должны ждать вызова функции, вызваных в середине этих функций, для
          того чтобы продолжить свою работу
        </p>
        <p class="bg">
          function fnA() { <br />
          console.log('Лог в середине функции fnA до вызова функции fnB');<br /><br />

          fnB(console.log('Лог в середине функции fnA после вызова функции
          fnB'));<br />
          }<br /><br />

          function fnB() {<br />
          console.log('Лог в середине функции fnB');<br />
          }<br /><br />

          // Лог до вызова fnA<br />
          // Лог в середине функции fnA до вызова fnB<br />
          // Лог в середине функции fnB<br />
          // Лог в середине функции fnA после вызова fnB<br />
          // Лог после fnA
        </p>
        <p>
          Необходим механизм сохранения списка функций, которые были вызваны, но
          не завершили свое выполнение и механизм управления этих функций,
          именно за это отвечает стек вызова (call stack) <br /><br />
          <b>Stack</b> <br />
          Структура данных, которые работают по принципу LIFO(last in first
          out), т.е последним пришел, первым ушел. Последнее что добавляется в
          стек, будет удалено из него первым, поэтому можно удалять или
          добавлять элементы только с верхушки стека. <br /><br />
          Представьте стек в виде массива у которого есть методы только pop() и
          push(), т.е можно добавлять или удалять элементы в конец коллекции
        </p>
        <img src="./images/stack.png" alt="" class="img" />
        <p>
          <b>Стек вызова (call stack)</b> <br />
          Это механизм для отслеживания поточного местоположения интерпритатора
          в коде, который вызывает несколько функций. Какая из функций
          выполняется в этот момент, какие функции вызываются в середине
          функции, которые выполняются, какая функция юудет вызвана следующей
        </p>
        <ul>
          <li>
            Когда скрипт вызывает функцию интерпритатор добавляет ее в стек
            вызова и начинает ее выполнение
          </li>
          <li>
            Все функции, вызваные функцией, которая выполняется, добавляется в
            стек вызова и выполняются, как только происходит их вызов
          </li>
          <li>
            Когда выполнение функции завершено, интерпритатор снимает ее из
            стека вызова и восстанавливает выполнение кода с той точки, где
            закончил до этого. Т.е начинает выполнение функции, запись которой
            следущей в стеке
          </li>
        </ul>
        <p class="information">
          <b>Stack frame(кадр стека, запись стека)</b> - структура, которая
          добавляется в стек на момент вызова функции. Сохраняет служебную
          информацию, например имя функции и номер ряда, в котором был вызван
        </p>
        <p class="bg">
          function bar() { <br />
          console.log('bar');<br />
          }<br /><br />

          function bus() {<br />
          console.log('bus');<br />
          }<br /><br />

          function foo() {<br />
          console.log('foo');<br /><br />

          bar(console.log('bar'));<br />
          bus(console.log('bus'));<br />
          }<br /><br />

          foo(console.log('foo'));<br />
          // 1. foo<br />
          // 2. foo<br />
          // 3. bar<br />
          // 4. bar<br />
          // 5. bus<br />
          // 6. bus<br />
        </p>
        <p>
          Когда выполняется этот код сначала вызывается foo(), потом foo в
          середине вызывается bar(), а потом bus(). Вызовы console.log() так же
          учитывается, т.к это функция
        </p>
        <img src="./images/call-stack.png" alt="" class="img" />
        <p>
          <b>Переполнение стек вызова</b><br />
          Стек вызовов не бесконечный, ему выделяется конечный объем памяти.
          Иногда в консоли можно увидеть ошибку "Uncaught RangeError: Maximum
          call stack size exceeded" - переполнение стка (stack overflow)
          <br /><br />
          Это может случится в случае неправильного использования рекурсии или
          закливанием вызова функции, т.е если выполняются бесконечные вызовы
          функции и результат не возвращается то стек увеличивается. Такая
          ошибка возникнет после достижения лимита количества записей стека и
          скрипт падает.
        </p>
      </section>
    </main>
    <script src="./js/moduleTwo.js"></script>
    <script src="./js/test.js"></script>
  </body>
</html>

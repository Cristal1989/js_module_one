<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Document</title>
  </head>
  <body>
    <main>
      <section class="container">
        <h3 class="title">Call back функции</h3>
        <p>
          Функции не отличаются чисел, строк или массивов - это просто
          специальный тип данных (объект высшего порядка - приоритета), значение
          которого можно хванить в переменной или передавать в качестве
          аргумента в другую функцию
        </p>
        <p class="bg">
          function greet(name) { <br />
          return `Добро пожаловать ${name}`;<br />
          }<br /><br />

          // Вызываем функцию greet и выводи результат в консоль<br />
          console.log(greet('Vasya')); // Добро пожаловать Vasya<br /><br />

          // Выводим функцию greet в консоль не вызывая ее<br />
          console.log(greet); // f greet() {`Добро пожаловать ${name}`}<br />
        </p>
        <p>
          В первом логе мы вызываем функцию greet с помощью круглых скобок и в
          консоль выводится результат ее исполнения. Во втором логе передается
          ссылка на функцию, а не результат вызова(отсутствуют круглые скобки,
          поэтому в консоль выводится ее тело). Это означает что функцию можно
          присвоить в переменную или передать в качестве аргумента другой
          функции <br /><br />
          <b>Функция обратного вызова (callback)</b> - это функция которая
          передается другой функции как аргумент, а та в свою очередь вызывает
          передаваемую функцию. <br />
          Функция высшего порядка (high order function) - функция принимающая в
          качестве параметров другие функции или возвращающая функцию в качестве
          результата.
        </p>
        <p class="bg">
          function greet(name) { <br />
          return console.log(`Добро пожаловать ${name}`);<br />
          }<br /><br />

          // Функция высшего порядка<br />
          function registerGuest(name, callback) {<br />
          console.log(`Регистрация гостя ${name}`);<br />
          // callback - Передача функции<br />
          callback(name);<br />
          }<br /><br />

          registerGuest('Petya', greet); //Регистрация гостя Petya<br />
          //Добро пожаловать Petya
        </p>
        <p>
          Мы передали ссылку на функцию greet в качестве аргумента, поэтому она
          будет присвоена в параметр callback и будет вызвана внутри функции
          registerGuest с помощью(). Имя параметров callback может быть
          произвольным, главное помнить что значение будет функция. <br /><br />
          <b>Инлайн callback</b><br />
          Если callback функция маленькая и нужна только для передачи аргументом
          ее можно объявить непосредственно на момент вызова функции в которую
          передадим callback. Такая функция будет доступна только в качестве
          значения параметра и больше нигде в коде.
        </p>
        <p class="bg">
          function registerGuest(name, callback) { <br />
          console.log(`Регистрация гостя ${name}`);<br />
          callback(name);<br />
          }<br /><br />

          // Передадим инлайн функцию grett в качестве callback<br />
          registerGuest('Max', function greet(name) {<br />
          console.log(`Добро пожаловать ${name}`);<br />
          }); //Регистрация гостя Max<br />
          //Добро пожаловать Max<br /><br />

          // Передадим инлайн функцию notify в качестве callback<br />
          registerGuest('Ann', function notify(name) {<br />
          console.log(`Уважаемый(-я) ${name}, ваш номер будет готов через
          день`);<br />
          });//Регистрация гостя Ann<br />
          //Уважаемый(-я) Ann, ваш номер будет готов через день<br />
        </p>
        <p>
          <b>Несколько callback</b><br />
          Функция может принимать любое колличество callback. К примеру
          представим что мы пишем логику принятия звонка для телефона, программа
          должна включать автоответчик если абонент не доступен или подключить
          звонок в противном случае. Доступность абонента будем имитировать
          генератором случайного числа чтобы между разными вызовами функции
          можно было получить разные результаты
        </p>
        <p class="bg">
          function processCall(resepient) { <br />
          // Имитируем доступность абонента случайным числом<br />
          const isResepientAvalable = Math.random() > 0.5;<br />
          if (!isResepientAvalable) {<br />
          console.log(`Абонент ${resepient} недоступный, оставьте
          сообщение`);<br />
          // Логика активации автоответчика<br />
          } else {<br />
          console.log(`Cоединяем с ${resepient}, ожидайте`);<br />
          // Логика принятия звонка<br />
          }<br />
          }<br /><br />

          processCall('Vasya');
        </p>
        <p>
          Проблема такого подхода состоит в том, что функция processCall
          производит слишком много и привязывает проверку доступности абонента к
          двум заранее определенным действиям. Что будет если в будущем вместо
          автоответчика нужно будет оставить галограмму <br /><br />
          Мы могли бы написать функцию таким образом чтобы она возвращала
          какое-то значение, а затем по результату ее выполнения делать проверки
          и выполнять нужный код. Но проверки не касаются внешнего кода и будут
          его засорять. Выполним рефакторинг функции таким образом чтобы она
          принимала два callback onAvalable и onNotAvalable и вызвала их по
          условию
        </p>
        <p class="bg">
          function processCall(recepient, onAvalable, onNotAvalable) { <br />
          const isResepientAvalable = Math.random() > 0.5;<br />
          if (!isResepientAvalable) {<br />
          onAvalable(recepient);<br />
          return;<br />
          }<br />
          onNotAvalable(recepient);<br />
          }<br /><br />

          function takeCall(name) {<br />
          console.log(`Соединяю с ${name}, ожидайте`);<br />
          }<br /><br />

          function activateAnswerignMachine(name) {<br />
          console.log(`Абонент ${name} недостпен, оставьте сообщение`);<br />
          }<br /><br />

          function leaveHelloMessage(name) {<br />
          console.log(`Абонент ${name} недоступный, записываем
          видеосообщение`);<br />
          }<br /><br />

          processCall('Ann', takeCall, activateAnswerignMachine); //Соединяю с
          Ann, ожидайте<br />
          processCall('Ann', takeCall, leaveHelloMessage);//Абонент Ann
          недоступный, записываем видеосообщение
        </p>
        <p>
          Callback применяются для обработки действия пользователя на странице,
          на момент обработки запроса на сервер, выполнение заранее неизвестных
          функций и т.д. В этом состоит их сущность, эти функции предназначены
          для отложенного исполнения. <br />
          <b>Абстрагирование, повторение</b><br />
          Абстракция - сокрытие деталей реализации. Позволяет думать о задачах
          на высшем (абстрактном) уровне. Функции это хороший способ построения
          абстракции. <br />
          К примеру скрипт выполняет какое-то действие определенное колличество
          раз, с этой целью можно написать цикл for
        </p>
        <p class="bg">
          for (let i = 0; i < 10; i += 1) { <br />
          console.log(i); <br />
          }
        </p>
        <p>
          Можем ли отвлечся, делать что то n раз в качестве функции - да.
          Напишем функцию вызывающую console.log n раз
        </p>
        <p class="bg">
          function repeatLog(n) { <br />
          for (let i = 0; i < n; i++){<br />
          console.log(i);<br />
          }<br />
          }<br /><br />

          repeatLog(5);//0-4
        </p>
        <p>
          Но что делать если мы хотим выполнить что нибудь кроме логирования
          чисел? Поскольку "делать что-то" можно представить фукцией, а функция
          это просто значение. Мы можем передать действие как аргумент
        </p>
        <p class="bg">
          function printValue(value) { <br />
          console.log(value);<br />
          }<br /><br />

          function prettyValue(value) {<br />
          console.log('Logging value: ', value);<br />
          }<br /><br />

          function repeat(n, action) {<br />
          for (let i = 0; i < n; i++) {<br />
          action(i);<br />
          }<br />
          }<br /><br />

          // Передаем printValue как callback функцию repeat(3, printValue)<br />
          repeat(3, printValue);//0-2<br /><br />

          // Передадим prettyPrint как callback функцию<br />
          repeat(3, prettyValue);//Logging value: 0-2<br />
        </p>
      </section>
    </main>
    <script src="./js/moduleFour.js"></script>
  </body>
</html>

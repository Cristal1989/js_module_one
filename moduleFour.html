<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Document</title>
  </head>
  <body>
    <main>
      <section class="container">
        <h3 class="title">Call back функции</h3>
        <p>
          Функции не отличаются чисел, строк или массивов - это просто
          специальный тип данных (объект высшего порядка - приоритета), значение
          которого можно хванить в переменной или передавать в качестве
          аргумента в другую функцию
        </p>
        <p class="bg">
          function greet(name) { <br />
          return `Добро пожаловать ${name}`;<br />
          }<br /><br />

          // Вызываем функцию greet и выводи результат в консоль<br />
          console.log(greet('Vasya')); // Добро пожаловать Vasya<br /><br />

          // Выводим функцию greet в консоль не вызывая ее<br />
          console.log(greet); // f greet() {`Добро пожаловать ${name}`}<br />
        </p>
        <p>
          В первом логе мы вызываем функцию greet с помощью круглых скобок и в
          консоль выводится результат ее исполнения. Во втором логе передается
          ссылка на функцию, а не результат вызова(отсутствуют круглые скобки,
          поэтому в консоль выводится ее тело). Это означает что функцию можно
          присвоить в переменную или передать в качестве аргумента другой
          функции <br /><br />
          <b>Функция обратного вызова (callback)</b> - это функция которая
          передается другой функции как аргумент, а та в свою очередь вызывает
          передаваемую функцию. <br />
          Функция высшего порядка (high order function) - функция принимающая в
          качестве параметров другие функции или возвращающая функцию в качестве
          результата.
        </p>
        <p class="bg">
          function greet(name) { <br />
          return console.log(`Добро пожаловать ${name}`);<br />
          }<br /><br />

          // Функция высшего порядка<br />
          function registerGuest(name, callback) {<br />
          console.log(`Регистрация гостя ${name}`);<br />
          // callback - Передача функции<br />
          callback(name);<br />
          }<br /><br />

          registerGuest('Petya', greet); //Регистрация гостя Petya<br />
          //Добро пожаловать Petya
        </p>
        <p>
          Мы передали ссылку на функцию greet в качестве аргумента, поэтому она
          будет присвоена в параметр callback и будет вызвана внутри функции
          registerGuest с помощью(). Имя параметров callback может быть
          произвольным, главное помнить что значение будет функция. <br /><br />
          <b>Инлайн callback</b><br />
          Если callback функция маленькая и нужна только для передачи аргументом
          ее можно объявить непосредственно на момент вызова функции в которую
          передадим callback. Такая функция будет доступна только в качестве
          значения параметра и больше нигде в коде.
        </p>
        <p class="bg">
          function registerGuest(name, callback) { <br />
          console.log(`Регистрация гостя ${name}`);<br />
          callback(name);<br />
          }<br /><br />

          // Передадим инлайн функцию grett в качестве callback<br />
          registerGuest('Max', function greet(name) {<br />
          console.log(`Добро пожаловать ${name}`);<br />
          }); //Регистрация гостя Max<br />
          //Добро пожаловать Max<br /><br />

          // Передадим инлайн функцию notify в качестве callback<br />
          registerGuest('Ann', function notify(name) {<br />
          console.log(`Уважаемый(-я) ${name}, ваш номер будет готов через
          день`);<br />
          });//Регистрация гостя Ann<br />
          //Уважаемый(-я) Ann, ваш номер будет готов через день<br />
        </p>
        <p>
          <b>Несколько callback</b><br />
          Функция может принимать любое колличество callback. К примеру
          представим что мы пишем логику принятия звонка для телефона, программа
          должна включать автоответчик если абонент не доступен или подключить
          звонок в противном случае. Доступность абонента будем имитировать
          генератором случайного числа чтобы между разными вызовами функции
          можно было получить разные результаты
        </p>
        <p class="bg">
          function processCall(resepient) { <br />
          // Имитируем доступность абонента случайным числом<br />
          const isResepientAvalable = Math.random() > 0.5;<br />
          if (!isResepientAvalable) {<br />
          console.log(`Абонент ${resepient} недоступный, оставьте
          сообщение`);<br />
          // Логика активации автоответчика<br />
          } else {<br />
          console.log(`Cоединяем с ${resepient}, ожидайте`);<br />
          // Логика принятия звонка<br />
          }<br />
          }<br /><br />

          processCall('Vasya');
        </p>
        <p>
          Проблема такого подхода состоит в том, что функция processCall
          производит слишком много и привязывает проверку доступности абонента к
          двум заранее определенным действиям. Что будет если в будущем вместо
          автоответчика нужно будет оставить галограмму <br /><br />
          Мы могли бы написать функцию таким образом чтобы она возвращала
          какое-то значение, а затем по результату ее выполнения делать проверки
          и выполнять нужный код. Но проверки не касаются внешнего кода и будут
          его засорять. Выполним рефакторинг функции таким образом чтобы она
          принимала два callback onAvalable и onNotAvalable и вызвала их по
          условию
        </p>
        <p class="bg">
          function processCall(recepient, onAvalable, onNotAvalable) { <br />
          const isResepientAvalable = Math.random() > 0.5;<br />
          if (!isResepientAvalable) {<br />
          onAvalable(recepient);<br />
          return;<br />
          }<br />
          onNotAvalable(recepient);<br />
          }<br /><br />

          function takeCall(name) {<br />
          console.log(`Соединяю с ${name}, ожидайте`);<br />
          }<br /><br />

          function activateAnswerignMachine(name) {<br />
          console.log(`Абонент ${name} недостпен, оставьте сообщение`);<br />
          }<br /><br />

          function leaveHelloMessage(name) {<br />
          console.log(`Абонент ${name} недоступный, записываем
          видеосообщение`);<br />
          }<br /><br />

          processCall('Ann', takeCall, activateAnswerignMachine); //Соединяю с
          Ann, ожидайте<br />
          processCall('Ann', takeCall, leaveHelloMessage);//Абонент Ann
          недоступный, записываем видеосообщение
        </p>
        <p>
          Callback применяются для обработки действия пользователя на странице,
          на момент обработки запроса на сервер, выполнение заранее неизвестных
          функций и т.д. В этом состоит их сущность, эти функции предназначены
          для отложенного исполнения. <br />
          <b>Абстрагирование, повторение</b><br />
          Абстракция - сокрытие деталей реализации. Позволяет думать о задачах
          на высшем (абстрактном) уровне. Функции это хороший способ построения
          абстракции. <br />
          К примеру скрипт выполняет какое-то действие определенное колличество
          раз, с этой целью можно написать цикл for
        </p>
        <p class="bg">
          for (let i = 0; i < 10; i += 1) { <br />
          console.log(i); <br />
          }
        </p>
        <p>
          Можем ли отвлечся, делать что то n раз в качестве функции - да.
          Напишем функцию вызывающую console.log n раз
        </p>
        <p class="bg">
          function repeatLog(n) { <br />
          for (let i = 0; i < n; i++){<br />
          console.log(i);<br />
          }<br />
          }<br /><br />

          repeatLog(5);//0-4
        </p>
        <p>
          Но что делать если мы хотим выполнить что нибудь кроме логирования
          чисел? Поскольку "делать что-то" можно представить фукцией, а функция
          это просто значение. Мы можем передать действие как аргумент
        </p>
        <p class="bg">
          function printValue(value) { <br />
          console.log(value);<br />
          }<br /><br />

          function prettyValue(value) {<br />
          console.log('Logging value: ', value);<br />
          }<br /><br />

          function repeat(n, action) {<br />
          for (let i = 0; i < n; i++) {<br />
          action(i);<br />
          }<br />
          }<br /><br />

          // Передаем printValue как callback функцию repeat(3, printValue)<br />
          repeat(3, printValue);//0-2<br /><br />

          // Передадим prettyPrint как callback функцию<br />
          repeat(3, prettyValue);//Logging value: 0-2<br />
        </p>
        <p><b>Метод forEach()</b><br /></p>
        <p>
          Метод перебора массива, используемый для замены цикла for и for..of в
          работе с коллекцией данных.
        </p>
        <p class="bg">
          array.forEach(function callback(element, index, array){ <br />
          тело функции <br />
          })
        </p>
        <p>
          Поэлементно берет массив, вызывает функцию callback для каждого
          элемента массива. Ничего не возвращает. <br />
          Аргументы callback функции это значения текущего элемента element, его
          индекс - index и исходный массив array. Можно объявлять только
          необходимые параметры, чаще всего это элементы, главное не забывать об
          их порядке.
        </p>
        <p class="bg">
          const numbers = [2, 5, 7, 4, 1, 0]; <br /><br />

          for (let i = 0; i < numbers.length; i++){<br />
          console.log(`Индекс ${i}, значение ${numbers[i]}`);<br />
          }<br /><br />

          // Метод перебора через forEach()<br />
          numbers.forEach(function (number, index) {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          })<br />
        </p>
        <p>
          <b>Стрелочные функции</b><br />
          Стрелочные функции имеют сокращенный, более локаничный синтаксис, что
          уменьшает объем кода, особенно когда функция маленькая или если она
          используется в качестве callback. <br />
          Все стрелки создаются как функциональные выражения и если функция не
          анонимна ее необходимо присваивать переменной.
        </p>
        <p class="bg">
          function multiply(a, b, c) { <br />
          return a + b + c;<br />
          // Это обычная функция<br />
          }<br /><br />

          const foo = (a, b, c) => {<br />
          return a + b + c;<br />
          // Это стрелочная функция<br />
          }<br />
        </p>
        <p>
          Ключевое слова function не используется, вместо этого сразу
          указывается объявление параметров, после него символ => и тело
          функции. Если параметров несколько, то они перечисляются через запятую
          в круглых скобках <br />
          const name = () => { <br />
          telo <br />
          console.log("Hello");<br />
          // Если параметров нет<br />
          }<br />
        </p>
        <p class="bg">
          const name = a => { <br />
          return a+5; <br />
          // Если параметр 1 <br />
          }<br />
        </p>
        <p>
          <b>Неявное возвращение</b><br />
          В стрелочной функции после символа => находится ее тело. Есть 2
          варианта с фигурными скобками и без них
        </p>
        <p class="bg">
          const name = (a, b, c) => { <br />
          console.log(a, b, c);<br />
          return a + b + c;<br />
          }<br />
        </p>
        <p>
          Если есть фигурные скобки и функция должна возвращать какое либо
          значение, то необходимо явно поставить return, это называется явный
          возврат. Такой синтаксис используется если в теле функции нужно
          выполнить еще инструкции кроме возврата значений <br />
          const name = (a, b, c) => a + b + c;<br />
          console.log(name(3,4,5));//12<br />
        </p>
        <p>
          Если фигурные скобки отсутствуют, то возвращается результат стоящего
          после =>. Это называется неявное возвращение. В примере вернется
          результат выражения добавления а параметров b и c <br />
          Синтаксис неявного возврата существенно сокращает шум объявление
          функции с возвращаемым телом и выражением, но уместен только тогда,
          когда в теле функции не требуется выполнить никаких доп инструкций
          кроме возврата значений.
        </p>
        <p>
          <b>Псевдомассив arguments</b><br />
          В стрелочных функциях нет локальной переменной arguments, содержащей
          все аргументы. Если нужно собрать все аргументы в массив используется
          операция ...rest
        </p>
        <p class="bg">
          const fn = (...args) => { <br />
          console.log(args);<br />
          };<br /><br />

          fn(3, 2, 1, 0);//[ 3, 2, 1, 0 ]<br />
        </p>
        <p>
          <b>Стрелочные функции как callback</b><br />
          Анонимные стрелочные функции отлично подходят как callback для
          перебирающего метода массива, благодаря более короткому синтаксису
          объявления, особенно если не требуется тело функции
        </p>
        <p class="bg">
          const array = [3, 5, 8, 9, 10]; <br />
          array.forEach(function (number, index) {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          });<br /><br />

          // Анонимная стрелочная функция<br />
          array.forEach((number, index) => {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          });
        </p>
        <p>
          <b>Стрелочная callback функция</b> можно так же объявлять отдельно и
          передавать на нее ссылку. Это следует делать если одна функция
          используется в нескольких местах программы или слишком большая
        </p>
        <p class="bg">
          const array = [3, 5, 8, 9, 10]; <br />
          const logMessage = (number, index) => {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          }<br /><br />

          array.forEach(logMessage);<br />
        </p>
        <h3 class="title">Разновидности кода</h3>
        <p>
          <b>Императивное программирование</b><br />
          Описывает процесс вычисления в виде заданной последовательности
          инструкций, изменяющих состояние программы. Описание того, как что-то
          выполняется <br />
          Императивный стиль программирования это такой стиль, который
          предоставляет машине подробный набор инструкций для выполнения задач,
          например цикл for, который дает точные задания для итерации по
          индексам массива <br />
          Можно провести аналоги с рецептом приготовления продуктов, где рецепт
          это пошаговая инструкция для получения желаемого результата
        </p>
        <img src="./images/imperative-recipe.jpg" alt="" class="img" />
        <p>
          <b>Декларативное программирование</b><br />
          Описывает что мы хотим получить в итоге, а не способ сделать. Порядок
          выполнения и способ достижения не важны. Когда мы пишем html код, то
          декларативно с помощью тегов и атрибутов описывам то, что хотим
          получить в итоге. Браузер читает этот код и сам выполняет все
          необходимые операции по созданию html элементов и размещению их на
          странице <br />
          Можно привести аналог из меню ресторана - это декларативный набор
          заказных блюд, подробности приготовления и подачи которых скрыты
        </p>
        <img src="./images/declarative-menu.jpg" alt="" class="img" />
        <p>
          Декларативное описание задачи нагляднее и легче формулируется. Мы
          говорим что мы хотим сделать, вызываем метод или функцию. Ее
          реализация вероятнее всего использует императивный код, но он скрыт
          внутри и не затрудняет понимание основного кода <br />
          <b>Императивнй vs Декларативный</b><br />
          Рассмотрим разновидность подхода на примере базовой операции
          фильтрации коллекции. Напишем код переборки и фильтрации массива чисел
          по определенному критерию
        </p>
        <p class="bg">
          // Императивный подход <br />
          const array = [3, 5, 8, 9, 10];<br />
          const filterArray = [];<br /><br />

          for (let i = 0; i < array.length; i++) {<br />
          if (array[i] > 7) {<br />
          filterArray.push(array[i]);<br />
          }<br />
          }<br /><br />

          console.log(filterArray);<br /><br />

          // Декларативный подход<br />
          const array = [3, 5, 8, 9, 10];<br />
          const filterArray = array.filter(num => num > 7);<br /><br />

          console.log(filterArray);<br />
        </p>
        <p>
          <b>Чистые функции</b><br />
          Функция с побочными эффектами - это функция которая в процессе может
          изменять или использовать глобальные переменные, изменять значения
          аргументов ссылочного типа, выполнять операции ввода-вывода
        </p>
        <p class="bg">
          const multiply = (array, value) => { <br />
          for (let i = 0; i < array.length; i++) {<br />
          array[i] = array[i] * value;<br />
          }<br />
          };<br />
          const numArr = [4, 7, 1, 4, 10, 22, 50];<br /><br />

          multiply(numArr, 2);<br />
          // Мутация исходных данных - массива numArr<br />
          console.log(numArr);//[ 8, 14, 2, 8, 20, 44, 100]<br />
        </p>
        <p>
          Функция multiply(array, value) умножает каждый элемент массива array
          на число value. Она изменяет(мутирует) исходный массив по ссылке
          <br />
          Чистая функция (pure function) - это функция, результат которой
          зависит только от значений переданых аргументов. При одинаковых
          аргументах она возвращает всегда один и тот же результат и не имеет
          побочных эффектов, т.е не изменяет значение аргументов. <br />
          Напишем реализацию чистой функции умножения элементов массива,
          возвращающей в новый массив, не изменяя исходный.
        </p>
        <p class="bg">
          const multiply = (arr, value) => { <br />
          let newArr = [];<br />
          arr.forEach(element => {<br />
          newArr.push(element * value);<br />
          });<br />
          return newArr;<br />
          };<br /><br />

          const numArr = [4, 7, 1, 4, 10, 22, 50];<br />
          const doubledArr = multiply(numArr, 2);<br /><br />

          // Мутация исходных данных не состоялась<br />
          console.log(numArr);//[4, 7, 1, 4, 10, 22, 50]<br />
          // Функция вернула новый массив с измененными данными<br />
          console.log(doubledArr);//[ 8, 14, 2, 8, 20, 44, 100]<br />
        </p>
      </section>
    </main>
    <script src="./js/moduleFour.js"></script>
  </body>
</html>

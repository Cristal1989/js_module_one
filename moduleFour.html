<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Document</title>
  </head>
  <body>
    <main>
      <section class="container">
        <h3 class="title">Call back функции</h3>
        <p>
          Функции не отличаются чисел, строк или массивов - это просто
          специальный тип данных (объект высшего порядка - приоритета), значение
          которого можно хванить в переменной или передавать в качестве
          аргумента в другую функцию
        </p>
        <p class="bg">
          function greet(name) { <br />
          return `Добро пожаловать ${name}`;<br />
          }<br /><br />

          // Вызываем функцию greet и выводи результат в консоль<br />
          console.log(greet('Vasya')); // Добро пожаловать Vasya<br /><br />

          // Выводим функцию greet в консоль не вызывая ее<br />
          console.log(greet); // f greet() {`Добро пожаловать ${name}`}<br />
        </p>
        <p>
          В первом логе мы вызываем функцию greet с помощью круглых скобок и в
          консоль выводится результат ее исполнения. Во втором логе передается
          ссылка на функцию, а не результат вызова(отсутствуют круглые скобки,
          поэтому в консоль выводится ее тело). Это означает что функцию можно
          присвоить в переменную или передать в качестве аргумента другой
          функции <br /><br />
          <b>Функция обратного вызова (callback)</b> - это функция которая
          передается другой функции как аргумент, а та в свою очередь вызывает
          передаваемую функцию. <br />
          Функция высшего порядка (high order function) - функция принимающая в
          качестве параметров другие функции или возвращающая функцию в качестве
          результата.
        </p>
        <p class="bg">
          function greet(name) { <br />
          return console.log(`Добро пожаловать ${name}`);<br />
          }<br /><br />

          // Функция высшего порядка<br />
          function registerGuest(name, callback) {<br />
          console.log(`Регистрация гостя ${name}`);<br />
          // callback - Передача функции<br />
          callback(name);<br />
          }<br /><br />

          registerGuest('Petya', greet); //Регистрация гостя Petya<br />
          //Добро пожаловать Petya
        </p>
        <p>
          Мы передали ссылку на функцию greet в качестве аргумента, поэтому она
          будет присвоена в параметр callback и будет вызвана внутри функции
          registerGuest с помощью(). Имя параметров callback может быть
          произвольным, главное помнить что значение будет функция. <br /><br />
          <b>Инлайн callback</b><br />
          Если callback функция маленькая и нужна только для передачи аргументом
          ее можно объявить непосредственно на момент вызова функции в которую
          передадим callback. Такая функция будет доступна только в качестве
          значения параметра и больше нигде в коде.
        </p>
        <p class="bg">
          function registerGuest(name, callback) { <br />
          console.log(`Регистрация гостя ${name}`);<br />
          callback(name);<br />
          }<br /><br />

          // Передадим инлайн функцию grett в качестве callback<br />
          registerGuest('Max', function greet(name) {<br />
          console.log(`Добро пожаловать ${name}`);<br />
          }); //Регистрация гостя Max<br />
          //Добро пожаловать Max<br /><br />

          // Передадим инлайн функцию notify в качестве callback<br />
          registerGuest('Ann', function notify(name) {<br />
          console.log(`Уважаемый(-я) ${name}, ваш номер будет готов через
          день`);<br />
          });//Регистрация гостя Ann<br />
          //Уважаемый(-я) Ann, ваш номер будет готов через день<br />
        </p>
        <p>
          <b>Несколько callback</b><br />
          Функция может принимать любое колличество callback. К примеру
          представим что мы пишем логику принятия звонка для телефона, программа
          должна включать автоответчик если абонент не доступен или подключить
          звонок в противном случае. Доступность абонента будем имитировать
          генератором случайного числа чтобы между разными вызовами функции
          можно было получить разные результаты
        </p>
        <p class="bg">
          function processCall(resepient) { <br />
          // Имитируем доступность абонента случайным числом<br />
          const isResepientAvalable = Math.random() > 0.5;<br />
          if (!isResepientAvalable) {<br />
          console.log(`Абонент ${resepient} недоступный, оставьте
          сообщение`);<br />
          // Логика активации автоответчика<br />
          } else {<br />
          console.log(`Cоединяем с ${resepient}, ожидайте`);<br />
          // Логика принятия звонка<br />
          }<br />
          }<br /><br />

          processCall('Vasya');
        </p>
        <p>
          Проблема такого подхода состоит в том, что функция processCall
          производит слишком много и привязывает проверку доступности абонента к
          двум заранее определенным действиям. Что будет если в будущем вместо
          автоответчика нужно будет оставить галограмму <br /><br />
          Мы могли бы написать функцию таким образом чтобы она возвращала
          какое-то значение, а затем по результату ее выполнения делать проверки
          и выполнять нужный код. Но проверки не касаются внешнего кода и будут
          его засорять. Выполним рефакторинг функции таким образом чтобы она
          принимала два callback onAvalable и onNotAvalable и вызвала их по
          условию
        </p>
        <p class="bg">
          function processCall(recepient, onAvalable, onNotAvalable) { <br />
          const isResepientAvalable = Math.random() > 0.5;<br />
          if (!isResepientAvalable) {<br />
          onAvalable(recepient);<br />
          return;<br />
          }<br />
          onNotAvalable(recepient);<br />
          }<br /><br />

          function takeCall(name) {<br />
          console.log(`Соединяю с ${name}, ожидайте`);<br />
          }<br /><br />

          function activateAnswerignMachine(name) {<br />
          console.log(`Абонент ${name} недостпен, оставьте сообщение`);<br />
          }<br /><br />

          function leaveHelloMessage(name) {<br />
          console.log(`Абонент ${name} недоступный, записываем
          видеосообщение`);<br />
          }<br /><br />

          processCall('Ann', takeCall, activateAnswerignMachine); //Соединяю с
          Ann, ожидайте<br />
          processCall('Ann', takeCall, leaveHelloMessage);//Абонент Ann
          недоступный, записываем видеосообщение
        </p>
        <p>
          Callback применяются для обработки действия пользователя на странице,
          на момент обработки запроса на сервер, выполнение заранее неизвестных
          функций и т.д. В этом состоит их сущность, эти функции предназначены
          для отложенного исполнения. <br />
          <b>Абстрагирование, повторение</b><br />
          Абстракция - сокрытие деталей реализации. Позволяет думать о задачах
          на высшем (абстрактном) уровне. Функции это хороший способ построения
          абстракции. <br />
          К примеру скрипт выполняет какое-то действие определенное колличество
          раз, с этой целью можно написать цикл for
        </p>
        <p class="bg">
          for (let i = 0; i < 10; i += 1) { <br />
          console.log(i); <br />
          }
        </p>
        <p>
          Можем ли отвлечся, делать что то n раз в качестве функции - да.
          Напишем функцию вызывающую console.log n раз
        </p>
        <p class="bg">
          function repeatLog(n) { <br />
          for (let i = 0; i < n; i++){<br />
          console.log(i);<br />
          }<br />
          }<br /><br />

          repeatLog(5);//0-4
        </p>
        <p>
          Но что делать если мы хотим выполнить что нибудь кроме логирования
          чисел? Поскольку "делать что-то" можно представить фукцией, а функция
          это просто значение. Мы можем передать действие как аргумент
        </p>
        <p class="bg">
          function printValue(value) { <br />
          console.log(value);<br />
          }<br /><br />

          function prettyValue(value) {<br />
          console.log('Logging value: ', value);<br />
          }<br /><br />

          function repeat(n, action) {<br />
          for (let i = 0; i < n; i++) {<br />
          action(i);<br />
          }<br />
          }<br /><br />

          // Передаем printValue как callback функцию repeat(3, printValue)<br />
          repeat(3, printValue);//0-2<br /><br />

          // Передадим prettyPrint как callback функцию<br />
          repeat(3, prettyValue);//Logging value: 0-2<br />
        </p>
        <p><b>Метод forEach()</b><br /></p>
        <p>
          Метод перебора массива, используемый для замены цикла for и for..of в
          работе с коллекцией данных.
        </p>
        <p class="bg">
          array.forEach(function callback(element, index, array){ <br />
          тело функции <br />
          })
        </p>
        <p>
          Поэлементно берет массив, вызывает функцию callback для каждого
          элемента массива. Ничего не возвращает. <br />
          Аргументы callback функции это значения текущего элемента element, его
          индекс - index и исходный массив array. Можно объявлять только
          необходимые параметры, чаще всего это элементы, главное не забывать об
          их порядке.
        </p>
        <p class="bg">
          const numbers = [2, 5, 7, 4, 1, 0]; <br /><br />

          for (let i = 0; i < numbers.length; i++){<br />
          console.log(`Индекс ${i}, значение ${numbers[i]}`);<br />
          }<br /><br />

          // Метод перебора через forEach()<br />
          numbers.forEach(function (number, index) {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          })<br />
        </p>
        <p>
          <b>Стрелочные функции</b><br />
          Стрелочные функции имеют сокращенный, более локаничный синтаксис, что
          уменьшает объем кода, особенно когда функция маленькая или если она
          используется в качестве callback. <br />
          Все стрелки создаются как функциональные выражения и если функция не
          анонимна ее необходимо присваивать переменной.
        </p>
        <p class="bg">
          function multiply(a, b, c) { <br />
          return a + b + c;<br />
          // Это обычная функция<br />
          }<br /><br />

          const foo = (a, b, c) => {<br />
          return a + b + c;<br />
          // Это стрелочная функция<br />
          }<br />
        </p>
        <p>
          Ключевое слова function не используется, вместо этого сразу
          указывается объявление параметров, после него символ => и тело
          функции. Если параметров несколько, то они перечисляются через запятую
          в круглых скобках <br />
          const name = () => { <br />
          telo <br />
          console.log("Hello");<br />
          // Если параметров нет<br />
          }<br />
        </p>
        <p class="bg">
          const name = a => { <br />
          return a+5; <br />
          // Если параметр 1 <br />
          }<br />
        </p>
        <p>
          <b>Неявное возвращение</b><br />
          В стрелочной функции после символа => находится ее тело. Есть 2
          варианта с фигурными скобками и без них
        </p>
        <p class="bg">
          const name = (a, b, c) => { <br />
          console.log(a, b, c);<br />
          return a + b + c;<br />
          }<br />
        </p>
        <p>
          Если есть фигурные скобки и функция должна возвращать какое либо
          значение, то необходимо явно поставить return, это называется явный
          возврат. Такой синтаксис используется если в теле функции нужно
          выполнить еще инструкции кроме возврата значений <br />
          const name = (a, b, c) => a + b + c;<br />
          console.log(name(3,4,5));//12<br />
        </p>
        <p>
          Если фигурные скобки отсутствуют, то возвращается результат стоящего
          после =>. Это называется неявное возвращение. В примере вернется
          результат выражения добавления а параметров b и c <br />
          Синтаксис неявного возврата существенно сокращает шум объявление
          функции с возвращаемым телом и выражением, но уместен только тогда,
          когда в теле функции не требуется выполнить никаких доп инструкций
          кроме возврата значений.
        </p>
        <p>
          <b>Псевдомассив arguments</b><br />
          В стрелочных функциях нет локальной переменной arguments, содержащей
          все аргументы. Если нужно собрать все аргументы в массив используется
          операция ...rest
        </p>
        <p class="bg">
          const fn = (...args) => { <br />
          console.log(args);<br />
          };<br /><br />

          fn(3, 2, 1, 0);//[ 3, 2, 1, 0 ]<br />
        </p>
        <p>
          <b>Стрелочные функции как callback</b><br />
          Анонимные стрелочные функции отлично подходят как callback для
          перебирающего метода массива, благодаря более короткому синтаксису
          объявления, особенно если не требуется тело функции
        </p>
        <p class="bg">
          const array = [3, 5, 8, 9, 10]; <br />
          array.forEach(function (number, index) {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          });<br /><br />

          // Анонимная стрелочная функция<br />
          array.forEach((number, index) => {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          });
        </p>
        <p>
          <b>Стрелочная callback функция</b> можно так же объявлять отдельно и
          передавать на нее ссылку. Это следует делать если одна функция
          используется в нескольких местах программы или слишком большая
        </p>
        <p class="bg">
          const array = [3, 5, 8, 9, 10]; <br />
          const logMessage = (number, index) => {<br />
          console.log(`Индекс ${index}, значение ${number}`);<br />
          }<br /><br />

          array.forEach(logMessage);<br />
        </p>
        <h3 class="title">Разновидности кода</h3>
        <p>
          <b>Императивное программирование</b><br />
          Описывает процесс вычисления в виде заданной последовательности
          инструкций, изменяющих состояние программы. Описание того, как что-то
          выполняется <br />
          Императивный стиль программирования это такой стиль, который
          предоставляет машине подробный набор инструкций для выполнения задач,
          например цикл for, который дает точные задания для итерации по
          индексам массива <br />
          Можно провести аналоги с рецептом приготовления продуктов, где рецепт
          это пошаговая инструкция для получения желаемого результата
        </p>
        <img src="./images/imperative-recipe.jpg" alt="" class="img" />
        <p>
          <b>Декларативное программирование</b><br />
          Описывает что мы хотим получить в итоге, а не способ сделать. Порядок
          выполнения и способ достижения не важны. Когда мы пишем html код, то
          декларативно с помощью тегов и атрибутов описывам то, что хотим
          получить в итоге. Браузер читает этот код и сам выполняет все
          необходимые операции по созданию html элементов и размещению их на
          странице <br />
          Можно привести аналог из меню ресторана - это декларативный набор
          заказных блюд, подробности приготовления и подачи которых скрыты
        </p>
        <img src="./images/declarative-menu.jpg" alt="" class="img" />
        <p>
          Декларативное описание задачи нагляднее и легче формулируется. Мы
          говорим что мы хотим сделать, вызываем метод или функцию. Ее
          реализация вероятнее всего использует императивный код, но он скрыт
          внутри и не затрудняет понимание основного кода <br />
          <b>Императивнй vs Декларативный</b><br />
          Рассмотрим разновидность подхода на примере базовой операции
          фильтрации коллекции. Напишем код переборки и фильтрации массива чисел
          по определенному критерию
        </p>
        <p class="bg">
          // Императивный подход <br />
          const array = [3, 5, 8, 9, 10];<br />
          const filterArray = [];<br /><br />

          for (let i = 0; i < array.length; i++) {<br />
          if (array[i] > 7) {<br />
          filterArray.push(array[i]);<br />
          }<br />
          }<br /><br />

          console.log(filterArray);<br /><br />

          // Декларативный подход<br />
          const array = [3, 5, 8, 9, 10];<br />
          const filterArray = array.filter(num => num > 7);<br /><br />

          console.log(filterArray);<br />
        </p>
        <p>
          <b>Чистые функции</b><br />
          Функция с побочными эффектами - это функция которая в процессе может
          изменять или использовать глобальные переменные, изменять значения
          аргументов ссылочного типа, выполнять операции ввода-вывода
        </p>
        <p class="bg">
          const multiply = (array, value) => { <br />
          for (let i = 0; i < array.length; i++) {<br />
          array[i] = array[i] * value;<br />
          }<br />
          };<br />
          const numArr = [4, 7, 1, 4, 10, 22, 50];<br /><br />

          multiply(numArr, 2);<br />
          // Мутация исходных данных - массива numArr<br />
          console.log(numArr);//[ 8, 14, 2, 8, 20, 44, 100]<br />
        </p>
        <p>
          Функция multiply(array, value) умножает каждый элемент массива array
          на число value. Она изменяет(мутирует) исходный массив по ссылке
          <br />
          Чистая функция (pure function) - это функция, результат которой
          зависит только от значений переданых аргументов. При одинаковых
          аргументах она возвращает всегда один и тот же результат и не имеет
          побочных эффектов, т.е не изменяет значение аргументов. <br />
          Напишем реализацию чистой функции умножения элементов массива,
          возвращающей в новый массив, не изменяя исходный.
        </p>
        <p class="bg">
          const multiply = (arr, value) => { <br />
          let newArr = [];<br />
          arr.forEach(element => {<br />
          newArr.push(element * value);<br />
          });<br />
          return newArr;<br />
          };<br /><br />

          const numArr = [4, 7, 1, 4, 10, 22, 50];<br />
          const doubledArr = multiply(numArr, 2);<br /><br />

          // Мутация исходных данных не состоялась<br />
          console.log(numArr);//[4, 7, 1, 4, 10, 22, 50]<br />
          // Функция вернула новый массив с измененными данными<br />
          console.log(doubledArr);//[ 8, 14, 2, 8, 20, 44, 100]<br />
        </p>
        <h3 class="title">Перебирающие массивы</h3>
        <p>
          В JS есть методы массивов пришедших из функциональных языков.
          Большинство из них это чистые функции. Они создают новый массив,
          заполняют его, применяя к значению каждого элемента указанную callback
          функцию, после чего возвращают этот новый массив
        </p>
        <p class="bg">arr.method(currentValue, index, array)</p>
        <p>
          Все перебирающие способы массива имеют схожий синтаксис. Исходящий
          массив arr, вызов метода method() и callback функция callback как
          аргумент метода
        </p>
        <p class="bg">
          arr.method((item, idx, array) => { <br />
          // Логика, которая будет применяться на каждой итерации <br />
          })<br />
        </p>
        <p>
          Все параметры кроме значения элемента item необязательны. Названия
          параметров могут быть любые, но есть неофициальные договоренности.
        </p>
        <p class="bg">
          arr.method(item => { <br />
          // Логика, которая будет применяться на каждой итерации <br />
          })<br />
        </p>
        <h3 class="title">Метод map()</h3>
        <p>
          Метод map(callback) используется для траснсформации массива. Он
          использует callback функцию для каждого элемента исходного массива, а
          результат ее работы записывает в новый массив, который будет являться
          выполнением метода
        </p>
        <p class="bg">
          arr.map((element, idx, array) => {<br />
          // Тело callback функции<br />
          })<br />
        </p>
        <ul>
          <li>Поэлементно перебирает оригинальный массив</li>
          <li>Не изменяет оригинальный массив</li>
          <li>Результат работы callback функции записывает в новый массив</li>
          <li>Возвращает новый массив одинаковой длинны</li>
        </ul>
        <p>
          Его можно использовать для того, чтобы изменить каждый элемент
          массива. Оригинальный массив используется в качестве эталлона. На
          основе которого можно сделать другую коллекцию
        </p>
        <p class="bg">
          const planets = ['Earth', 'Venus', 'Jupiter', 'Mars'];<br /><br />

          const planetsInUpperCase = planets.map(planet =>
          planet.toUpperCase());<br />
          console.log(planetsInUpperCase); //[ 'EARTH', 'VENUS', 'JUPITER',
          'MARS' ]<br /><br />

          const planetsInLowerCase = planets.map(planet =>
          planet.toLowerCase());<br />
          console.log(planetsInLowerCase); //[ 'earth', 'venus', 'jupiter',
          'mars' ]<br /><br />

          // Оригинальный массив<br />
          console.log(planets);//[ 'Earth', 'Venus', 'Jupiter', 'Mars' ]<br />
        </p>
        <p>
          Использование анонимных стрелочных функций с неявным возвратом
          существенно сокращает шум объявления callback функций, что делает код
          более чистым, простым для восприятия
        </p>
        <h3 class="title">Массив объектов</h3>
        <p>
          Мы уже знаем, что повседневная задача это манипуляция массивом
          объектов. Например получить массив значений свойства из всех объектов.
          У нас есть массив студентов, а нужно получить отдельный массив их имен
        </p>
        <p class="bg">
          const students = [<br />
          {<br />
          name: 'Ann',<br />
          score: 5,<br />
          },<br />
          {<br />
          name: 'Vasya',<br />
          score: 23,<br />
          },<br />
          {<br />
          name: 'Petya',<br />
          score: 1,<br />
          },<br />
          {<br />
          name: 'Ivan',<br />
          score: 45,<br />
          },<br />
          {<br />
          name: 'Polina',<br />
          score: 30,<br />
          },<br />
          ];<br />
          const names = students.map(student => student.name);<br />
          console.log(names); //[ 'Ann', 'Vasya', 'Petya', 'Ivan', 'Polina' ]<br /><br />

          const scores = students.map(student => student.score);<br />
          console.log(scores); //[ 5, 23, 1, 45, 30 ]<br />
        </p>
        <p>
          Используя метод map() мы можем перебирать массив объектов в callback
          функции и вернуть значения свойства каждого из них
        </p>
        <h3 class="title">Метод flatMap()</h3>
        <p>
          Метод flatMap(callback) - это аналогичный метод map() но применяется в
          случаях когда результат - это многомерный массив, который необходимо
          "разгладить"
        </p>
        <p class="bg">
          arr.flatMap((element, idx, array) => {<br />
          // Тело callback функции<br />
          })<br />
        </p>
        <p>
          В массиве students хранится список студентов со списком предметов,
          посещаемых студентом, в свойстве courses. Несколько студентов может
          посещать один и тот же предмет. Необходимо составить список всех
          предметов посещаемых этой группой студентов, пока еще даже
          повторяющихся
        </p>
        <p class="bg">
          const students = [<br />
          {<br />
          name: 'Ann',<br />
          score: 5,<br />
          courses: ['Math', 'Physic'],<br />
          },<br />
          {<br />
          name: 'Vasya',<br />
          score: 23,<br />
          courses: ['Drawing', 'Swimming', 'Math'],<br />
          },<br />
          {<br />
          name: 'Petya',<br />
          score: 1,<br />
          courses: ['Math', 'Flying', 'Drawing'],<br />
          },<br />
          {<br />
          name: 'Ivan',<br />
          score: 45,<br />
          courses: ['Swimming', 'Physic', 'Flying'],<br />
          },<br />
          {<br />
          name: 'Polina',<br />
          score: 30,<br />
          courses: ['Math', 'Physic', 'Swimming', 'Flying', 'Drawing'],<br />
          },<br />
          ];<br /><br />

          students.map(student => student.courses);<br />
          const allCourses = students.flatMap(student => student.courses);<br />
          console.table(students.flatMap(student => student.courses));<br />
          //['Math', 'Physic',<br />
          //'Drawing', 'Swimming',<br />
          //'Math', 'Math',<br />
          //'Flying', 'Drawing',<br />
          //'Swimming', 'Physic',<br />
          //'Flying', 'Math',<br />
          //'Physic', 'Swimming',<br />
          //'Flying', 'Drawing']<br />
        </p>
        <h3 class="title">Метод filter()</h3>
        <p>
          Метод filter(callback) - используется для единственной операции -
          фильтрации массива, т.е когда необходимо выбрать более одного элемента
          из коллекции по определенному критерию.
        </p>
        <p class="bg">
          arr.filter((element, idx, array) => {<br />
          // Тело callback функции<br />
          })
        </p>
        <ul>
          <li>Не изменяет оригинальный массив</li>
          <li>Поименно перебирает оригинальный массив</li>
          <li>Возвращает новый массив</li>
          <li>
            Добавляет в возвращаемый массив элементы, удовлетворяющие условиям
            callback функции
          </li>
          <li>
            Если callback вернет true - элемент добавляется в возвращаемый
            массив
          </li>
          <li>
            Если callback вернет false - элемент не добавляется в возвращаемый
            массив
          </li>
          <li>
            Если ни один из элементов не удовлетворил условие - возвращает
            пустой массив
          </li>
        </ul>
        <p class="bg">
          const values = [3, 19, -5, 55, -34, 105, -38]; <br />
          const positiveValues = values.filter(value => value >= 0);<br />
          console.log(positiveValues); //[ 3, 19, 55, 105 ]<br /><br />

          const negativeValues = values.filter(value => value < 0);<br />
          console.log(negativeValues); //[ -5, -34, -38 ]<br /><br />

          const nullValues = values.filter(value => value > 1000);<br />
          console.log(nullValues); //[]<br /><br />

          // Исходный массив<br />
          console.log(values);//[3, 19, -5, 55, -34, 105, -38]<br />
        </p>
        <p>
          То есть метод filter() вызывает callback функцию для каждого элемента
          исходного массива и если результат ее выполнения true добавляет
          текущий элемент в новый массив.
        </p>
        <h3 class="title">Фильтрация уникальных элементов</h3>
        <p>
          Используя метод filter() можно выполнить фильтрацию массива таким
          образом, что на нем останутся только уникальные элементы. Этот пример
          работает только с массивом примитивных значений - не объектов. <br />
          Вернемся в группу студентов и массив всех посещаемых предметов,
          который мы получим через метод flatMap(). <br />
          Переменной allCourses равняется массив всех посещаемых предметов,
          которые могут повторяться. Задача состоит в том чтобы создать новый
          массив, в котором будут состоять только уникальные предметы без
          повторений
        </p>
        <p class="bg">
          const students = [ <br />
          {<br />
          name: 'Ann',<br />
          score: 5,<br />
          courses: ['Math', 'Physic'],<br />
          },<br />
          {<br />
          name: 'Vasya',<br />
          score: 23,<br />
          courses: ['Drawing', 'Swimming', 'Math'],<br />
          },<br />
          {<br />
          name: 'Petya',<br />
          score: 1,<br />
          courses: ['Math', 'Flying', 'Drawing'],<br />
          },<br />
          {<br />
          name: 'Ivan',<br />
          score: 45,<br />
          courses: ['Swimming', 'Physic', 'Flying'],<br />
          },<br />
          {<br />
          name: 'Polina',<br />
          score: 30,<br />
          courses: ['Math', 'Physic', 'Swimming', 'Flying', 'Drawing'],<br />
          },<br />
          ];<br /><br />

          const allCourses = students.flatMap(student => student.courses);<br />
          const uniqueCourses = allCourses.filter((course, idx, arr) => {<br />
          return arr.indexOf(course) === idx;<br />
          });<br />
          console.log(uniqueCourses);//[ 'Math', 'Physic', 'Drawing',
          'Swimming', 'Flying' ]
        </p>
        <p>
          Используя arr.indexOf(course) ипользуем поиск первого совпадения
          текущего элемента course и получаем его индекс в оригинальном массиве
          всех курсов. В параметре idx сохраняется индекс текущего элемента
          course перебирая массив методом filter() <br />
          Если результат indexOf() и значение idx равны - это уникальный
          элемент, потому что такие значения встречаются в массиве впервые и на
          текущей итерации фильтр обрабатывает именно его
        </p>
        <p class="bg">
          ['Math', 'Physic', <br />
          'Drawing', 'Swimming',<br />
          'Math', 'Math',<br />
          'Flying', 'Drawing',<br />
          'Swimming', 'Physic',<br />
          'Flying', 'Math',<br />
          'Physic', 'Swimming',<br />
          'Flying', 'Drawing']<br />
        </p>
        <p>Для элемента Math под индексом 0:</p>
        <ul>
          <li>indexOf() вернет 0, потому что ищет первое совпадение</li>
          <li>Значение параметра idx будет 0</li>
          <li>Они равны, так что это будет уникальный элемент</li>
        </ul>
        <p>Для элемента Math под индексом 4:</p>
        <ul>
          <li>indexOf() вернет 0, потому что ищет первое совпадение</li>
          <li>Значение параметра idx будет 4</li>
          <li>Они не равны, так что это будет не уникальный элемент</li>
        </ul>
        <p>
          <b>Массив объектов</b> <br />
          При работе с массивом объектов выполняется фильтрация по определенному
          свойству в итоге образуется новый массив отфильтрованых объектов
          <br />
          К примеру у нас есть массив студентов с баллами за тест. Необходимо
          отфильтровать лучших (балл выше 80) и худших (балл ниже 50) и средних
          студентов(от 50 до 80)
        </p>
        <p class="bg">
          const LOW_SCORE = 50; <br />
          const HIGH_SCORE = 80;<br /><br />

          const students = [<br />
          {<br />
          name: 'Ann',<br />
          score: 55,<br />
          },<br />
          {<br />
          name: 'Vasya',<br />
          score: 83,<br />
          },<br />
          {<br />
          name: 'Petya',<br />
          score: 15,<br />
          },<br />
          {<br />
          name: 'Ivan',<br />
          score: 45,<br />
          },<br />
          {<br />
          name: 'Polina',<br />
          score: 90,<br />
          },<br />
          {<br />
          name: 'Alina',<br />
          score: 64,<br />
          },<br />
          ];<br /><br />

          // Высший балл<br />
          const bestScore = students.filter(student => student.score >=
          HIGH_SCORE);<br />
          console.log(bestScore); //[ { name: 'Vasya', score: 83 }, { name:
          'Polina', score: 90 } ]<br /><br />

          // Средний балл<br />
          // const mediumScore = students.filter(student => student.score <
          HIGH_SCORE && student.score<br />
          // >= LOW_SCORE);<br />
          const mediumScore = students.filter(<br />
          ({ score }) => score >= LOW_SCORE && score < HIGH_SCORE<br />
          );<br />
          console.log(mediumScore); //[ { name: 'Ann', score: 55 }, { name:
          'Alina', score: 64 } ]<br /><br />

          // Низший балл<br />
          const worstScore = students.filter(student => student.score <
          LOW_SCORE);<br />
          console.log(worstScore); //[ { name: 'Petya', score: 15 }, { name:
          'Ivan', score: 45 } ]<br />
        </p>
      </section>
    </main>
    <script src="./js/moduleFour.js"></script>
  </body>
</html>

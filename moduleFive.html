<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 5</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Ключевое слово this. Прототипы и классы</h3>
      <p>
        <b>Контекст выполнения функции</b><br />
        Можно с уверенностью сказать что ключевое свойство this одно из самых
        запутанных концепций в JS. Новички часто подставляют this методом
        научного тыка до тех пор пока скрипт не сработает. Контекст в JS похож
        на Контекст в предложении
      </p>
      <ul>
        <li>Петя бежит быстро, потому что Петя пытается поймать поезд</li>
        <li>Петя бежит быстро, потому что он пытается поймать поезд</li>
      </ul>
      <p>
        Второе предложение звечит более локанично. Мы можем сказать что контекст
        предложения это Петя, потому что он в центре внимания в это конкретное
        время в предложении, даже местоимение кто касается Пети. <br />
        И точно так же объект может являться текущем контекстом выполнения
        функции
      </p>
      <p class="bg">
        //Петя бежит быстро, потому что Петя пытается поймать поезд <br />
        const petya = {<br />
        username: "Petya",<br />
        showName() {<br />
        console.log(petya.username);<br />
        }<br />
        };<br /><br />

        console.log(petya.showName());//"Petya"
      </p>
      <p>
        Обращение к свойствам объекта внутри метода используется имя самого
        объекта аналогично использованию Петя вместо "он". <br />
        Внутри функции можно использовать зарезервированое ключевое слово this.
        При выполнение функции в this записывается ссылка на объект, в контексте
        которого она была вызвана. Таким образом в теле функции мы может
        получить доступ к свойствам и методам объекта.
      </p>
      <p class="bg">
        // Петя бежит быстро, потому что он (this) пытается поймать поезд<br /><br />

        const petya = {<br />
        username: 'Petya',<br />
        showName() {<br />
        console.log(this.username);<br />
        },<br />
        };<br />
        console.log(petya.showName()); //"Petya"<br />
      </p>
      <p>Рассмотрим пример с коллекцией книг</p>
      <p class="bg">
        const bookShelf = { <br />
        author: ['Stiven King', 'Boris Akunin'],<br />
        getAuthor() {<br />
        return this.author;<br />
        },<br />
        addAuthor(newAuthor) {<br />
        this.author.push(newAuthor);<br />
        },<br />
        };<br /><br />

        console.log(bookShelf.getAuthor()); //[ 'Stiven King', 'Boris Akunin'
        ]<br />
        bookShelf.addAuthor('Doncova');<br />
        console.log(bookShelf.getAuthor()); //[ 'Stiven King', 'Boris Akunin',
        'Doncova' ]<br />
      </p>
      <p>
        Методы getAuthor() и addAuthor() это функции(методы объекта), вызываемые
        в контексте объекта bookShelf. Во время их выполнения в this
        записываемой ссылке на объект bookShelf и мы можем обратиться к его
        свойствам и методам
      </p>
      <p>
        <b>Правила определения this</b><br />
        Необходимо усвоить только одно правило определения для this - значение
        контекста внутри функции (не стрелочной), определяется не на момент ее
        создания, а на момент вызова. Т.е значение this определяется тем, как
        вызывается функция, а не где она была объявлена <br />
        <b>this в глобальной области видимости</b><br />
        В глобальной области видимости, если скрипт выполнется не в "use stict",
        this ссылается на объект window. В "use strict" значение this, в
        глобальной области видимости, будет undefind
      </p>
      <p class="bg">
        function foo(){ <br />
        console.log(this) <br />
        }; <br />
        foo();// undefind. Окно c use strict
      </p>
      <p>
        <b>this в методе объекта</b><br />
        Если функция была вызвана как метод объекта, контекст будет ссылаться на
        объект, частью которого является метод
      </p>
      <p class="bg">
        const petya = { <br />
        username: 'Petya',<br />
        showThis() {<br />
        console.log(this);<br />
        },<br />
        showName() {<br />
        console.log(this.username);<br />
        },<br />
        };<br />
        petya.showThis();//username: 'Petya', showThis: [F: showThis], showName:
        [F: showName]<br />
        petya.showName();//Petya<br />
      </p>
      <p>
        Рассмотрим более сложный пример для лучшего понимания. <br />Сначала
        создим функция в глобальной области видимости и вызовем ее <br />
        После чего присвоим ее свойство объекта и вызовем ее как метод этого
        объекта
      </p>
      <p class="bg">
        function showThis() { <br />
        // Это showThis<br />
        console.log(this);<br />
        }<br />
        // Вызываем в глобальном контексте showThis<br />
        const user = {<br />
        username: 'Mango',<br />
        };<br />
        // Записываем ссылку на функцию в свойстве объекта<br />
        // Обратите внимание что это не вызов - нет ()<br />
        user.showContext = showThis;<br /><br />

        // Вызываем функцию в контексте объекта<br />
        // Это будет указывать на текущий объект в контексте которого
        осуществляется вызов, а не глобальный объект<br /><br />

        console.log(user.showContext());<br />
        //{ username: 'Mango', showContext: [Function: showThis] }<br />
        //undefined<br />
      </p>
      <p>
        <b>this в callback функциях</b> <br />
        Передавая методы объекта в качестве callback функции контекста не
        сохраняется. Callback это ссылка, не метод, который присваивается как
        зрначения вызываемого параметра без объекта.
      </p>
      <p class="bg">
        const customer = {<br />
        firstname: 'Petya',<br />
        lastname: 'Vasechkin',<br />
        getFullName() {<br />
        return `${this.firstname} ${this.lastname}`;<br />
        },<br />
        };<br /><br />

        function makeMessage(callback) {<br />
        // Вызов метода getFullName без объекта<br />
        console.log(`Обрабатываем заявку от ${callback}`);<br />
        }<br /><br />

        makeMessage(customer.getFullName); // Ошибка при вызове<br />
        makeMessage(customer.getFullName()); //Обрабатываем заявку от Petya
        Vasechkin<br />
      </p>
      <p>
        <b>this в стрелочных функциях </b><br />
        Стрелочные функции не имеют своего this. В отличии от обычных функций
        изменить значение this внутри стрелки после ее объявления невозможно
      </p>
      <p class="information">
        Контекст внутри стрелки определяется местом ее объявления, а не вызовом,
        и ссылается на контекст родительской функции <br />
        Стрелочные функции так же игнорируют наличие "use strict". Если стрелка
        заполнила глобальный контест, то this в ней будет содержать ссылку
        window, независимо от того выполняется ли скрипт в строгом режиме.
      </p>
      <p class="bg">
        const showThis = () => { <br />
        console.log(`Это showThis: ${this}`); <br />
        }; <br />
        showThis(); // Объект window <br /><br />

        const user = {<br />
        username: 'Mango',<br />
        };<br />
        user.showContext = showThis;<br />
        user.showContext(); //Объект window<br />
      </p>
      <p>
        Ограничиваем стрелочные функции постоянным контекстом JS движки могут их
        оптимизировать, в отличии от обычных функций значение this, которое
        может быть изменено <br />
        Пример непрактичный, но прекрасно показывает как работает контекст для
        стрелок. Значение контекста берется из родительской области видимости
      </p>
      <p class="bg">
        const hotel = { <br />
        username: 'Peris Hilton',<br />
        showThis() {<br />
        const foo = () => {<br />
        // Стрелки запоминают контекст во время объявления из родительской
        области видимости<br />
        console.log('This in foo', this);<br />
        };<br />
        foo();<br />
        console.log('This в showThis', this);<br />
        },<br />
        };<br /><br />

        hotel.showThis();<br />
        //This in foo { username: 'Peris Hilton', showThis: [Function: showThis]
        }<br />
        //This в showThis { username: 'Peris Hilton', showThis: [Function:
        showThis] }<br />
      </p>
      <p>
        <b>Метод функции</b><br />
        Случается ситуации когда функцию необходимо вызвать в контексте объекта,
        при этом функция не является его способом. Для этого у функции есть
        методы и call, apply и bind.
      </p>
      <p><b>Метод call()</b></p>
      <p class="bg">foo.call(object, arg1, arg2, ...);</p>
      <p>
        Метод call() вызывает функцию таким образом что у this будет ссылка на
        объект object, а так же передаст аргументы arg1 и arg2 и т.д.
      </p>
      <p class="bg">
        function greetGuest(greeting) { <br />
        console.log(`${greeting}, ${this.username}`);<br />
        }<br />
        const mango = {<br />
        username: 'Mango',<br />
        };<br /><br />

        const poly = {<br />
        username: 'Poly',<br />
        };<br /><br />

        greetGuest.call(mango, 'Добро пожаловать ');//Добро пожаловать ,
        Mango<br />
        greetGuest.call(poly, 'Добро пожаловать ');//Добро пожаловать , Poly
      </p>
      <p>
        <b>Метод apply()</b><br />
        Это аналог метода call(), за исключением того что синтаксис передачи
        аргументов требует не перечисление, а массив, даже если аргумент всего
        один.
      </p>
      <p class="bg">
        foo.call(obj, arg1, arg2, ...) <br />
        foo.apply(obj, [arg1, arg2, ...]) <br />
      </p>
      <p>
        Метод apply() вызывает функцию foo таким образом что this будет ссылка
        на объект obj, а так же передасть элементы массива как отдельные
        аргументы arg1 и arg2.
      </p>
      <p class="bg">
        function greetGuest(greeting) { <br />
        console.log(`${greeting}, ${this.username}`);<br />
        }<br />
        const mango = {<br />
        username: 'Mango',<br />
        };<br /><br />

        const poly = {<br />
        username: 'Poly',<br />
        };<br /><br />

        greetGuest.apply(mango, ['Добро пожаловать ']); // Добро пожаловать ,
        Mango<br />
        greetGuest.apply(poly, ['Добро пожаловать ']); // Добро пожаловать ,
        Poly<br />
      </p>
      <p>
        <b>Метод bind()</b><br />
        Методы call() и apply() вызывают функцию на месте, т.е сразу, но в
        случае callback функции, когда нужно не сходу вызвать функцию, а
        передать ссылку на нее, при этом с привязанным контекстом, применяется
        способ bind()
      </p>
      <p class="bg">foo.bind(obj, arg1, arg2, ...)</p>
      <p>
        Метод bind() создает и возвращает копию функции foo() с привязанным
        контекстом obj и аргументами arg1 и arg2. Образуется копия функции,
        которую можно передать куда угодно и вызвать когда угодно
      </p>
      <p class="bg">
        function greet(clientName) { <br />
        return console.log(`${clientName}, добро пожаловать в
        ${this.service}`);<br />
        }<br /><br />

        const steam = {<br />
        service: 'Steam',<br />
        };<br />
        const staemGreater = greet.bind(steam);<br />
        staemGreater('Mango'); // Mango, добро пожаловать в Steam<br /><br />

        const gmail = {<br />
        service: 'Gmail',<br />
        };<br />
        const gmailGreater = greet.bind(gmail);<br />
        gmailGreater('Poly');// Poly, добро пожаловать в Gmail<br />
      </p>
      <p>
        <b>bind() и метод объекта</b><br />
        В случае передачи метода объекта в качестве callback фенкции контекст не
        сохраняется. Callback это ссылка, а не метод, который присваивается как
        значение вызываемого параметра без объекта
      </p>
      <p class="bg">
        const customer = { <br />
        firstName: 'Petya',<br />
        lastName: 'Polin',<br />
        getFullName() {<br />
        return `${this.firstName} ${this.lastName}`;<br />
        },<br />
        };<br />
        function makeMessage(callback) {<br />
        console.log(`Обрабатываем заявку от ${callback()}.`);<br />
        }<br />
        makeMessage(customer.getFullName.bind(customer)); //Обрабатываем заявку
        от Petya Polin.<br />
        // В строгом режиме значение this в методе getFullName вызывая в
        качестве callback функции callback() будет undefind. Обращая к свойствам
        firstName и lastName будет ошибка, т.к undefind это не объект <br />
        // Метод bind() используется для привязывания контекста передавая методы
        объекта в качестве callback функции
      </p>
      <h3 class="title">Объектно-ориентированое программирование</h3>
      <p>
        <b>Процедурное программирование</b><br />
        Набор несвязаных явно функций и переменных для хранения и обработки
        информации. Этот подход простой и прямолинейный и может использоваться
        для задач в которых нет тесно связаных сущностей (данных и функций для
        их обработки)
      </p>
      <img src="./images/procedural.jpg" alt="" class="img" />
      <p>
        Расммотрим пример процедурного кода, в котором есть переменная и функция
        для передачи результата
      </p>
      <p class="bg">
        const baseSalary = 30000; <br />
        const overTime = 10;<br />
        const rate = 20;<br />
        const getWage = (baseSalary, overTime, rate) => baseSalary + overTime *
        rate;<br /><br />

        console.log(getWage(baseSalary, overTime, rate));//30200<br />
      </p>
      <p>
        <b>Объектно ориентированое программирование (ООП)</b> - методология,
        описывающая программу как совокупность объекта, каждый из которых
        содержит данные (свойства) и методы для взаимодействия с ним
      </p>
      <img src="./images/oop.jpg" alt="" class="img" />
      <p>Используем ООП собрав данные в объекте employee</p>
      <p class="bg">
        const employee = { <br />
        baseSalary: 30000,<br />
        overtime: 10,<br />
        rate: 20,<br />
        getWage() {<br />
        return this.baseSalary + this.overtime * this.rate;<br />
        },<br />
        };<br /><br />

        console.log(employee.getWage()); //30200<br />
      </p>
      <p>
        При таком подходе в методе отсутствуют параметры. Используется свойство
        объекта, которые задаются на момент создания объекта и могут так же
        изменяться другими методами. На выходе получаем сущность простым
        интерфейсом что уменьшает сложность программы <br />
        С идеологической точки зрения ООП это подход к программированию как к
        моделированию решающий основную задачу структуирования информации с
        точки зрения управляемости, что сущесвенно улучшает контроль процесса
        моделирования <br />
        <b>Сущности ООП</b><br />
        Представьте что мы проэктируем автомобиль. У него будет двигатель, 4
        колеса, бензобак и т.д. Автомобиль должен иметь возможность заводится,
        увеличивать и сбавлять скорость. Мы знаем как взаимодействует двигатель
        и колеса, т.е по каким законам взаимодействуют разные части машины
        <br />
        <b>Класс</b> <br />
        Мы описываем все запчасти из которых состоит автомобиль, тогда как эти
        запчасти взаимодействуют между собой и что должен сделать водитель чтобы
        автомобиль затормозил, включились фары и т.д. Результатом работы будет
        определенный эскиз (шаблон, схема). Мы только что разобрали то, что в
        ООП называется классом <br />
        Класс - способ описания сущности, определяющий состояние и поведение,
        зависищая от этого состояния а так же правила взаимодействия с этой
        сущностью (контракт) <br />
        В нашем случае класс определяет сущность - автомобиль. Свойствами класса
        будут двигатель, колеса, фары и т.д Методами класса будут действия -
        открыть дверь, запустить двигатель, увеличить скорость и т.д <br />
        <b>Экземпляр</b><br />
        Мы спроэктировали чертеж и автомобили разработанные на их основе сходят
        в конвеер. Каждый из них точно повторяет чертеж, все системы
        взамодействуют именно так как мы спроэктировали, но каждый автомобиль
        уникален. Они все имеют номер кузова и двигателя, но все номера разные,
        авто различаются по цвету. Эти автомобили - это экземпляр класса <br />
        <b>Экземпляр (объект)</b> - это отдельный представитель класса имеющий
        конкретное состояние и поведение, полностью определяемое классом. Это то
        что создано по чертежу, т.е на основании описания из класса. Проще
        говоря объект имеет конкретное значение параметров и способы работающие
        с этими качествами на базе правил, заданых в классе. В этом примере есть
        класс - это некий абстрактный автомобиль на чертеже, то объект - это
        конкретный автомобиль. <br />
        <b>Интерфейс</b><br />
        Когда мы подходим к авто и садимся за руль существует определенный набор
        элементов управления с которыми мы можем взаимодействовать. <br />
        <b>Интерфейс</b> - это набор свойств и методов класса, доступных для
        использования в работе с экземпляром <br />
        В сущности интерфейс описывает класс, четко определяя все возможные
        действия над ним. Хороший пример интерфейса - приборная панель авто,
        которая позволяет вызвать методы такие как увеличить скорость,
        тормажение и т.д <br />
        Описывая интерфейс класса очень важно выдержать баланс между гибкостью и
        простотой. Класс с простым интерфейсом будет легко использовать, но
        будут существовать задачи, которые с помощью него будет сложно решать.
        Если интерфейс будет гибким вероятней всего он будет содержать довольно
        сложные методы с большим кол-вом параметров, которые будут позволять
        делать очень много, но его использование будут связаны с большим трудом
        и риском ошибиться, перепутав что-то.
      </p>
      <h3 class="title">Прототипное наследование</h3>
      <p>
        ООП в JS построен на прототипном наследовании. Объекты можно
        организовать в цепочке таким образом чтобы производился автоматический
        поиск свойства в другом объекте, не найденом в одном объекте. Связующем
        звеном выступает спец скрытое свойство [[Prototype]], которое в консоли
        браузера отображается как __proto__. <br />
        <b>Прототип объекта</b> <br />
        Метод Object.create(obj) задает и возвращает новый объект, связывая его
        с объектом obj
      </p>
      <p class="bg">
        const animal = { <br />
        legs: 4,<br />
        };<br /><br />

        const dog = Object.create(animal);<br />
        dog.name = 'Sharik';<br />
        console.log(dog); //{ name: 'Sharik' }<br />
        console.log(animal.isPrototypeOf(dog));//true<br />
      </p>
      <p>
        Объект на который указывает ссылка в proto называется прототипом. В
        нашем примере объект animal это прототип для объекта dog.метод
        isPrototypeOf(), проверяет является ли объект animal прототипом для dog
        и возвращает true или false
      </p>
      <p class="bg">
        console.log(dog.hasOwnProperty('name'));//true<br />
        console.log(dog.name);//Sharik<br />
        console.log(dog.hasOwnProperty('legs'));//false<br />
        console.log(dog.legs);//4<br />
      </p>
      <p>
        Обращение dog.name работает очевидным образом, возвращает собственное
        свойство name объекта dog. Обращаясь к dog.legs инторпритатор ищет
        свойство legs в объекте dog, не находит и продолжает поиск в объекте по
        ссылке с dog.__proto__, т.е в этом случае в объекте animal - его
        прототипе. <br />
        Т.е прототип это резервное хранилище свойств и методов объекта,
        автоматически используемое при их поиске. Объект выстапующий прототипом
        может так же иметь свой прототип, следующий - свой и т.д. <br />
        Поиск свойства выполняется до первого совпадения. Интерпритатор ищет
        свойство по имени в объекте, если не находит то обращается к свойству
        __proto__, т.е переходит по ссылке к объекту прототипу, а затем к
        прототипу прототипа. Если интерпритатор дойдет до конца цепочки и не
        найдет свойства с таким именем - вернет undefind. <br />
        В спецификации свойства __proto__ обозначен как [[Prototype]]. В этом
        случае важны двойные квадратные скобки, они указывают на то что это
        внутренние служебные свойства. <br />
        <b>Метод hasOwnProperty()</b><br />
        После того как мы узнали о способе поиска объекта должно быть понятно
        почему цикл for..in не различает свойство объекта и его прототипа
      </p>
      <p class="bg">
        const animal = { <br />
        eats: true,<br />
        };<br />
        const dog = Object.create(animal);<br />
        dog.bargs = true;<br />
        for (const key in dog) {<br />
        console.log(key); //bargs;eats<br />
        }
      </p>
      <p>
        Именно по этому мы используем метод obj.hasOwnProperty(prop)
        возвращающий true если свойство prop принадлежит объекту obj а не его
        прототипу, иначе false.
      </p>
      <p class="bg">
        const animal = { <br />
        eats: true,<br />
        };<br />
        const dog = Object.create(animal);<br />
        dog.bargs = true;<br />
        for (const key in dog) {<br />
        if (!dog.hasOwnProperty(key)) continue;<br />
        console.log(key);//bargs<br />
        }<br />
      </p>
      <p>
        Метод Object.keys(obj) вернет массив только собственных ключей объекта
        obj, поэтому на практике используют именно его, а не for..in
      </p>
      <p class="bg">
        const animal = { <br />
        eats: true,<br />
        };<br />
        const dog = Object.create(animal);<br />
        dog.bargs = true;<br />
        const dogKeys = Object.keys(dog);<br />
        console.log(dogKeys);//[ 'bargs' ]
      </p>
      <h3 class="title">Классы</h3>
      <p>
        Синтексис литерала объекта позволяет создать один объект. Однако часто
        нужно создать много однотипных объектов с одинаковым набором свойств, но
        рызными значениями и методами для взаимодействия с ними. Все это нужно
        делать динамически во время выполнения программы. С этой целью
        используют классы - специальный синтаксис объявления функции для
        создания объекта <br />
        <b>Объявление класса</b><br />
        Объявление класса начинается с ключевого слова class, после которого
        стоит имя класса и фигурные скобки - его тело. Классы принято называть
        заглавной буквой а в названии отоброжать тип создаваемого объекта
        (существительное)
      </p>
      <p class="bg">
        class User { <br />
        // Тело класса<br />
        }<br />
        const mango = new User();<br />
        console.log(mango);//User {}<br />
      </p>
      <p>
        Результат вызова new User() который называется экземпляром класса, т.к
        содержит данные и поведение описываемые классом <br />
        Метод построения класса зависит от того, что нам нужно, в нашем случае
        класс - это пользователь, поэтому мы добавим в него поля для имени и
        почты. <br />
        <b>Конструктор класса </b><br />
        Для инициализации экземпляра в классе есть метод constructor(). Если не
        объявлен - создается конструктор по умолчанию - пустая функция, не
        изменяющая экземпляр.
      </p>
      <p class="bg">
        class User { <br />
        // Синтаксис объявления метода класса<br />
        constructor(name, email) {<br />
        // Инициализация свойства экземпляра<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        }<br />
        const mango = new User('Mango', 'mango123@gmail.com');<br />
        console.log(mango); //User { name: 'Mango', email: 'mango123@gmail.com'
        }<br />
        const apple = new User('Aplpe', 'mapple23@gmail.com');<br />
        console.log(apple);//User { name: 'Aplpe', email: 'mapple23@gmail.com'
        }<br />
      </p>
      <p>
        Вызов класса с оператором new приводит к созданию нового объекта и
        вызову конструктора в контексте этого объекта. Т.е this внутри
        контруктора будет ссылаться на вновь созданный объект. Это позволяет
        добавлять каждому объекту свойства с одинаковыми именами но разными
        значениями. <br />
        Свойство name и email называются публичными свойствами, потому что они
        будут собственными свойствами объекта экземпляра и к ним можно юудет
        получить доступ обративщись через точку. <br />
        <b>Объект параметров</b><br />
        Класс может воспринимать огромное колличество входных данных для
        параметров грядущего объекта. Поэтому к ним можно применить паттерн
        "объект параметров", передавая один объект с логически именуемыми
        свойствами в место несвязаного набора аргументов
      </p>
      <p class="bg">
        class User { <br />
        // Диструктуризация объекта<br />
        constructor({ name, email }) {<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        }<br />
        const mango = new User({ name: 'Mango', email: 'mango123@gmail.com'
        });<br />
        console.log(mango);//User { name: 'Mango', email: 'mango123@gmail.com'
        }<br />
      </p>
      <p>
        <b>Методы класса</b><br />
        Для работы с свойствами будущего экземпляра используется методы класса
        функций, которые будут доступны экземпляру в его прототипе
      </p>
      <p class="bg">
        class User { <br />
        constructor({ name, email }) {<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        // Метод getEmail()<br />
        getEmail() {<br />
        return this.email;<br />
        }<br />
        // Метод changeEmail()<br />
        changeEmail(newEmail) {<br />
        this.email = newEmail;<br />
        }<br />
        }<br />
      </p>
      <p>
        <b>Личные свойства </b><br />
        Инкапсуляция - это концепция, которая позволяет скрыть внутренние детали
        класса. Ползователь класса должен получать доступ только к публичному
        интерфейсу - набору публичных свойств и методов класса. <br />
        В классах инкапсуляция реализуется приватными способами, доступ к
        которым можно получить только в середине класса. <br />
        Допустип что почта пользователя не должна быть доступна к прямому
        изменению извне - т.е приватная. Добавляя к имени свойству символ #, мы
        делаем его приватным, а объявление приватного свойства к инициализации
        конструктора обязательна
      </p>
      <p class="bg">
        class User { <br />
        // Необязательное объявление публичных свойств<br />
        name;<br />
        // Обязательное объявление приватных свойств<br />
        #email;<br /><br />

        constructor({ name, email }) {<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        getEmail() {<br />
        return this.#email;<br />
        }<br />
        changeEmail(newEmail) {<br />
        this.#email = newEmail;<br />
        }<br />
        }<br />
        const mango = new User({<br />
        name: 'Mango',<br />
        email: 'mango123@gmail.com',<br />
        });<br />
        mango.changeEmail('mango123@outlook.com');<br />
        console.log(mango.getEmail());//mango123@outlook.com<br />
        console.log(mango.#email); // Ошибка, т.к это приватное свойство<br />
      </p>
      <p>
        Методы класса тоже могут быть приватными, т.е доступные только в теле
        класса, для этого перед именем необходимо поставить символ # <br />
        <b>Геттеры и сеттеры</b><br />
        Геттеры и сеттеры это кротчайший синтаксис объявления метода для
        взаимодействия с свойствами. Геттер и сеттер имеют обычное публичное
        свойство класса, но позволяют изменить другие свойства удобными
        способами <br />
        Геттер выполняется при попытке получить значение свойства, а сеттер при
        способе его изменения <br />
        Геттеры и сеттеры уместно использовать для простых операций чтения и
        изменения значения свойств особенно приватных, как и публичных
        интерфейсов. Для работы с свойствами которые сохраняют массив или объект
        они не подойдут.
      </p>
      <p class="bg">
        class User { <br />
        #email;<br />
        constructor({ name, email }) {<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        // Геттер email <br />
        get email() {<br />
        return this.#email;<br />
        }<br />
        // Сеттер email<br />
        set email(newEmail) {<br />
        this.#email = newEmail;<br />
        }<br />
        }<br />
      </p>
      <p>
        Мы объявили геттер и сетте email поставив перед именем ключевое свойство
        get и set. Внутри этих методов мы либо возвращаем значение частного
        свойства #email либо изменяем его значение. Геттер и сеттер используется
        в паре и обязаны именоваться идентично
      </p>
      <p class="bg">
        class User { <br />
        #email;<br />
        constructor({ name, email }) {<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        // Геттер email<br />
        get email() {<br />
        return this.#email;<br />
        }<br />
        // Сеттер email<br />
        set email(newEmail) {<br />
        this.#email = newEmail;<br />
        }<br />
        }<br /><br />

        const mango = new User({<br />
        name: 'Mango',<br />
        email: 'mango@gmail.com',<br />
        });<br />
        console.log(mango.email); //mango@gmail.com<br />
        mango.email = 'mango.outlook.com';<br />
        console.log(mango.email);//mango.outlook.com<br />
      </p>
      <p>
        Обращаясь к mango.email вызывается геттер get email(){...} и выполняется
        его код. При попытке записи mango.email = 'mango.outlook.com';
        вызывается сеттер set email(newEmail){...} и строка "mango.outlook.com"
        будет являться значением параметра newEmail <br />
        Приимущество в том что это методы, а значит во время записи можно
        выполнить дополнительный код, например с любыми проверками, в отличии от
        выполнения этой операции непосредственно со свойствами.
      </p>
      <p class="bg">
        class User { <br />
        #email;<br />
        constructor({ name, email }) {<br />
        this.name = name;<br />
        this.email = email;<br />
        }<br />
        get email() {<br />
        return this.#email;<br />
        }<br />
        set email(newEmail) {<br />
        if (newEmail === '') {<br />
        console.error('Ошибка, почта не может быть пустой');<br />
        return;<br />
        }<br />
        this.#email = newEmail;<br />
        }<br />
        }<br />
        const mango = new User({<br />
        name: 'Mango',<br />
        email: '',<br />
        });<br />
        console.log(mango.email);<br />
      </p>
      <p>
        <b>Статические свйоства</b><br />
        Помимо публичных и частных свойств будущего экземпляра в классе можно
        объявить его собственные свойства доступные только классу, но не
        экъемпляру - cтатические свойства (static). Они полезны для хранения
        информации, относящихся к классу <br />
        Добавим пользователькому классу частное свойство role определяющее набор
        прав, например админ, редактор, обычный пользователь и т.д. Возможные
        роли пользователей будем сохранять как статические свйоства roles -
        объекты со свойствами. <br />
        Статические хар-ки объявляются в теле класса, перед именованием свойства
        добаляется ключевое слово static
      </p>
      <p class="bg">
        class User{ <br />
        // Объявление и инициализация статического свойства<br />
        static Roles = {<br />
        ADMIN: 'Admin',<br />
        EDITOR: "Editor",<br />
        }<br />
        #email;<br />
        #role;<br />
        constructor({email, role}){<br />
        this.#email = email;<br />
        this.#role = role;<br />
        }<br />
        get role(){<br />
        return this.#role;<br />
        }<br />
        set role(newRole){<br />
        this.#role = newRole;<br />
        }<br />
        }<br /><br />

        const mango = new User({<br />
        email: "mango@gmail.com",<br />
        role: User.Roles.ADMIN,<br />
        });<br />
        console.log(mango.Roles);//undefined<br />
        console.log(User.Roles);//{ ADMIN: 'Admin', EDITOR: 'Editor' }<br /><br />

        console.log(mango.role);//Admin<br />
        mango.role = User.Roles.EDITOR;<br />
        console.log(mango.role);//Editor<br />
      </p>
    </section>
  </body>
</html>

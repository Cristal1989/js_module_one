<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="./CSS/style.css" />
    <title>Module 5</title>
  </head>
  <body>
    <section class="container">
      <h3 class="title">Ключевое слово this. Прототипы и классы</h3>
      <p>
        <b>Контекст выполнения функции</b><br />
        Можно с уверенностью сказать что ключевое свойство this одно из самых
        запутанных концепций в JS. Новички часто подставляют this методом
        научного тыка до тех пор пока скрипт не сработает. Контекст в JS похож
        на Контекст в предложении
      </p>
      <ul>
        <li>Петя бежит быстро, потому что Петя пытается поймать поезд</li>
        <li>Петя бежит быстро, потому что он пытается поймать поезд</li>
      </ul>
      <p>
        Второе предложение звечит более локанично. Мы можем сказать что контекст
        предложения это Петя, потому что он в центре внимания в это конкретное
        время в предложении, даже местоимение кто касается Пети. <br />
        И точно так же объект может являться текущем контекстом выполнения
        функции
      </p>
      <p class="bg">
        //Петя бежит быстро, потому что Петя пытается поймать поезд <br />
        const petya = {<br />
        username: "Petya",<br />
        showName() {<br />
        console.log(petya.username);<br />
        }<br />
        };<br /><br />

        console.log(petya.showName());//"Petya"
      </p>
      <p>
        Обращение к свойствам объекта внутри метода используется имя самого
        объекта аналогично использованию Петя вместо "он". <br />
        Внутри функции можно использовать зарезервированое ключевое слово this.
        При выполнение функции в this записывается ссылка на объект, в контексте
        которого она была вызвана. Таким образом в теле функции мы может
        получить доступ к свойствам и методам объекта.
      </p>
      <p class="bg">
        // Петя бежит быстро, потому что он (this) пытается поймать поезд<br /><br />

        const petya = {<br />
        username: 'Petya',<br />
        showName() {<br />
        console.log(this.username);<br />
        },<br />
        };<br />
        console.log(petya.showName()); //"Petya"<br />
      </p>
      <p>Рассмотрим пример с коллекцией книг</p>
      <p class="bg">
        const bookShelf = { <br />
        author: ['Stiven King', 'Boris Akunin'],<br />
        getAuthor() {<br />
        return this.author;<br />
        },<br />
        addAuthor(newAuthor) {<br />
        this.author.push(newAuthor);<br />
        },<br />
        };<br /><br />

        console.log(bookShelf.getAuthor()); //[ 'Stiven King', 'Boris Akunin'
        ]<br />
        bookShelf.addAuthor('Doncova');<br />
        console.log(bookShelf.getAuthor()); //[ 'Stiven King', 'Boris Akunin',
        'Doncova' ]<br />
      </p>
      <p>
        Методы getAuthor() и addAuthor() это функции(методы объекта), вызываемые
        в контексте объекта bookShelf. Во время их выполнения в this
        записываемой ссылке на объект bookShelf и мы можем обратиться к его
        свойствам и методам
      </p>
      <p>
        <b>Правила определения this</b><br />
        Необходимо усвоить только одно правило определения для this - значение
        контекста внутри функции (не стрелочной), определяется не на момент ее
        создания, а на момент вызова. Т.е значение this определяется тем, как
        вызывается функция, а не где она была объявлена <br />
        <b>this в глобальной области видимости</b><br />
        В глобальной области видимости, если скрипт выполнется не в "use stict",
        this ссылается на объект window. В "use strict" значение this, в
        глобальной области видимости, будет undefind
      </p>
      <p class="bg">
        function foo(){ <br />
        console.log(this) <br />
        }; <br />
        foo();// undefind. Окно c use strict
      </p>
      <p>
        <b>this в методе объекта</b><br />
        Если функция была вызвана как метод объекта, контекст будет ссылаться на
        объект, частью которого является метод
      </p>
      <p class="bg">
        const petya = { <br />
        username: 'Petya',<br />
        showThis() {<br />
        console.log(this);<br />
        },<br />
        showName() {<br />
        console.log(this.username);<br />
        },<br />
        };<br />
        petya.showThis();//username: 'Petya', showThis: [F: showThis], showName:
        [F: showName]<br />
        petya.showName();//Petya<br />
      </p>
      <p>
        Рассмотрим более сложный пример для лучшего понимания. <br />Сначала
        создим функция в глобальной области видимости и вызовем ее <br />
        После чего присвоим ее свойство объекта и вызовем ее как метод этого
        объекта
      </p>
      <p class="bg">
        function showThis() { <br />
        // Это showThis<br />
        console.log(this);<br />
        }<br />
        // Вызываем в глобальном контексте showThis<br />
        const user = {<br />
        username: 'Mango',<br />
        };<br />
        // Записываем ссылку на функцию в свойстве объекта<br />
        // Обратите внимание что это не вызов - нет ()<br />
        user.showContext = showThis;<br /><br />

        // Вызываем функцию в контексте объекта<br />
        // Это будет указывать на текущий объект в контексте которого
        осуществляется вызов, а не глобальный объект<br /><br />

        console.log(user.showContext());<br />
        //{ username: 'Mango', showContext: [Function: showThis] }<br />
        //undefined<br />
      </p>
      <p>
        <b>this в callback функциях</b> <br />
        Передавая методы объекта в качестве callback функции контекста не
        сохраняется. Callback это ссылка, не метод, который присваивается как
        зрначения вызываемого параметра без объекта.
      </p>
      <p class="bg">
        const customer = {<br />
        firstname: 'Petya',<br />
        lastname: 'Vasechkin',<br />
        getFullName() {<br />
        return `${this.firstname} ${this.lastname}`;<br />
        },<br />
        };<br /><br />

        function makeMessage(callback) {<br />
        // Вызов метода getFullName без объекта<br />
        console.log(`Обрабатываем заявку от ${callback}`);<br />
        }<br /><br />

        makeMessage(customer.getFullName); // Ошибка при вызове<br />
        makeMessage(customer.getFullName()); //Обрабатываем заявку от Petya
        Vasechkin<br />
      </p>
      <p>
        <b>this в стрелочных функциях </b><br />
        Стрелочные функции не имеют своего this. В отличии от обычных функций
        изменить значение this внутри стрелки после ее объявления невозможно
      </p>
      <p class="information">
        Контекст внутри стрелки определяется местом ее объявления, а не вызовом,
        и ссылается на контекст родительской функции <br />
        Стрелочные функции так же игнорируют наличие "use strict". Если стрелка
        заполнила глобальный контест, то this в ней будет содержать ссылку
        window, независимо от того выполняется ли скрипт в строгом режиме.
      </p>
      <p class="bg">
        const showThis = () => { <br />
        console.log(`Это showThis: ${this}`); <br />
        }; <br />
        showThis(); // Объект window <br /><br />

        const user = {<br />
        username: 'Mango',<br />
        };<br />
        user.showContext = showThis;<br />
        user.showContext(); //Объект window<br />
      </p>
      <p>
        Ограничиваем стрелочные функции постоянным контекстом JS движки могут их
        оптимизировать, в отличии от обычных функций значение this, которое
        может быть изменено <br />
        Пример непрактичный, но прекрасно показывает как работает контекст для
        стрелок. Значение контекста берется из родительской области видимости
      </p>
      <p class="bg">
        const hotel = { <br />
        username: 'Peris Hilton',<br />
        showThis() {<br />
        const foo = () => {<br />
        // Стрелки запоминают контекст во время объявления из родительской
        области видимости<br />
        console.log('This in foo', this);<br />
        };<br />
        foo();<br />
        console.log('This в showThis', this);<br />
        },<br />
        };<br /><br />

        hotel.showThis();<br />
        //This in foo { username: 'Peris Hilton', showThis: [Function: showThis]
        }<br />
        //This в showThis { username: 'Peris Hilton', showThis: [Function:
        showThis] }<br />
      </p>
      <p>
        <b>Метод функции</b><br />
        Случается ситуации когда функцию необходимо вызвать в контексте объекта,
        при этом функция не является его способом. Для этого у функции есть
        методы и call, apply и bind.
      </p>
      <p><b>Метод call()</b></p>
      <p class="bg">foo.call(object, arg1, arg2, ...);</p>
      <p>
        Метод call() вызывает функцию таким образом что у this будет ссылка на
        объект object, а так же передаст аргументы arg1 и arg2 и т.д.
      </p>
      <p class="bg">
        function greetGuest(greeting) { <br />
        console.log(`${greeting}, ${this.username}`);<br />
        }<br />
        const mango = {<br />
        username: 'Mango',<br />
        };<br /><br />

        const poly = {<br />
        username: 'Poly',<br />
        };<br /><br />

        greetGuest.call(mango, 'Добро пожаловать ');//Добро пожаловать ,
        Mango<br />
        greetGuest.call(poly, 'Добро пожаловать ');//Добро пожаловать , Poly
      </p>
      <p>
        <b>Метод apply()</b><br />
        Это аналог метода call(), за исключением того что синтаксис передачи
        аргументов требует не перечисление, а массив, даже если аргумент всего
        один.
      </p>
      <p class="bg">
        foo.call(obj, arg1, arg2, ...) <br />
        foo.apply(obj, [arg1, arg2, ...]) <br />
      </p>
      <p>
        Метод apply() вызывает функцию foo таким образом что this будет ссылка
        на объект obj, а так же передасть элементы массива как отдельные
        аргументы arg1 и arg2.
      </p>
      <p class="bg">
        function greetGuest(greeting) { <br />
        console.log(`${greeting}, ${this.username}`);<br />
        }<br />
        const mango = {<br />
        username: 'Mango',<br />
        };<br /><br />

        const poly = {<br />
        username: 'Poly',<br />
        };<br /><br />

        greetGuest.apply(mango, ['Добро пожаловать ']); // Добро пожаловать ,
        Mango<br />
        greetGuest.apply(poly, ['Добро пожаловать ']); // Добро пожаловать ,
        Poly<br />
      </p>
      <p>
        <b>Метод bind()</b><br />
        Методы call() и apply() вызывают функцию на месте, т.е сразу, но в
        случае callback функции, когда нужно не сходу вызвать функцию, а
        передать ссылку на нее, при этом с привязанным контекстом, применяется
        способ bind()
      </p>
      <p class="bg">foo.bind(obj, arg1, arg2, ...)</p>
      <p>
        Метод bind() создает и возвращает копию функции foo() с привязанным
        контекстом obj и аргументами arg1 и arg2. Образуется копия функции,
        которую можно передать куда угодно и вызвать когда угодно
      </p>
      <p class="bg">
        function greet(clientName) { <br />
        return console.log(`${clientName}, добро пожаловать в
        ${this.service}`);<br />
        }<br /><br />

        const steam = {<br />
        service: 'Steam',<br />
        };<br />
        const staemGreater = greet.bind(steam);<br />
        staemGreater('Mango'); // Mango, добро пожаловать в Steam<br /><br />

        const gmail = {<br />
        service: 'Gmail',<br />
        };<br />
        const gmailGreater = greet.bind(gmail);<br />
        gmailGreater('Poly');// Poly, добро пожаловать в Gmail<br />
      </p>
      <p>
        <b>bind() и метод объекта</b><br />
        В случае передачи метода объекта в качестве callback фенкции контекст не
        сохраняется. Callback это ссылка, а не метод, который присваивается как
        значение вызываемого параметра без объекта
      </p>
      <p class="bg">
        const customer = { <br />
        firstName: 'Petya',<br />
        lastName: 'Polin',<br />
        getFullName() {<br />
        return `${this.firstName} ${this.lastName}`;<br />
        },<br />
        };<br />
        function makeMessage(callback) {<br />
        console.log(`Обрабатываем заявку от ${callback()}.`);<br />
        }<br />
        makeMessage(customer.getFullName.bind(customer)); //Обрабатываем заявку
        от Petya Polin.<br />
        // В строгом режиме значение this в методе getFullName вызывая в
        качестве callback функции callback() будет undefind. Обращая к свойствам
        firstName и lastName будет ошибка, т.к undefind это не объект <br />
        // Метод bind() используется для привязывания контекста передавая методы
        объекта в качестве callback функции
      </p>
      <h3 class="title">Объектно-ориентированое программирование</h3>
      <p>
        <b>Процедурное программирование</b><br />
        Набор несвязаных явно функций и переменных для хранения и обработки
        информации. Этот подход простой и прямолинейный и может использоваться
        для задач в которых нет тесно связаных сущностей (данных и функций для
        их обработки)
      </p>
      <img src="./images/procedural.jpg" alt="" class="img" />
      <p>
        Расммотрим пример процедурного кода, в котором есть переменная и функция
        для передачи результата
      </p>
      <p class="bg">
        const baseSalary = 30000; <br />
        const overTime = 10;<br />
        const rate = 20;<br />
        const getWage = (baseSalary, overTime, rate) => baseSalary + overTime *
        rate;<br /><br />

        console.log(getWage(baseSalary, overTime, rate));//30200<br />
      </p>
      <p>
        <b>Объектно ориентированое программирование (ООП)</b> - методология,
        описывающая программу как совокупность объекта, каждый из которых
        содержит данные (свойства) и методы для взаимодействия с ним
      </p>
      <img src="./images/oop.jpg" alt="" class="img" />
      <p>Используем ООП собрав данные в объекте employee</p>
      <p class="bg">
        const employee = { <br />
        baseSalary: 30000,<br />
        overtime: 10,<br />
        rate: 20,<br />
        getWage() {<br />
        return this.baseSalary + this.overtime * this.rate;<br />
        },<br />
        };<br /><br />

        console.log(employee.getWage()); //30200<br />
      </p>
      <p>
        При таком подходе в методе отсутствуют параметры. Используется свойство
        объекта, которые задаются на момент создания объекта и могут так же
        изменяться другими методами. На выходе получаем сущность простым
        интерфейсом что уменьшает сложность программы <br />
        С идеологической точки зрения ООП это подход к программированию как к
        моделированию решающий основную задачу структуирования информации с
        точки зрения управляемости, что сущесвенно улучшает контроль процесса
        моделирования <br />
        <b>Сущности ООП</b><br />
        Представьте что мы проэктируем автомобиль. У него будет двигатель, 4
        колеса, бензобак и т.д. Автомобиль должен иметь возможность заводится,
        увеличивать и сбавлять скорость. Мы знаем как взаимодействует двигатель
        и колеса, т.е по каким законам взаимодействуют разные части машины
        <br />
        <b>Класс</b> <br />
        Мы описываем все запчасти из которых состоит автомобиль, тогда как эти
        запчасти взаимодействуют между собой и что должен сделать водитель чтобы
        автомобиль затормозил, включились фары и т.д. Результатом работы будет
        определенный эскиз (шаблон, схема). Мы только что разобрали то, что в
        ООП называется классом <br />
        Класс - способ описания сущности, определяющий состояние и поведение,
        зависищая от этого состояния а так же правила взаимодействия с этой
        сущностью (контракт) <br />
        В нашем случае класс определяет сущность - автомобиль. Свойствами класса
        будут двигатель, колеса, фары и т.д Методами класса будут действия -
        открыть дверь, запустить двигатель, увеличить скорость и т.д <br />
        <b>Экземпляр</b><br />
        Мы спроэктировали чертеж и автомобили разработанные на их основе сходят
        в конвеер. Каждый из них точно повторяет чертеж, все системы
        взамодействуют именно так как мы спроэктировали, но каждый автомобиль
        уникален. Они все имеют номер кузова и двигателя, но все номера разные,
        авто различаются по цвету. Эти автомобили - это экземпляр класса <br />
        <b>Экземпляр (объект)</b> - это отдельный представитель класса имеющий
        конкретное состояние и поведение, полностью определяемое классом. Это то
        что создано по чертежу, т.е на основании описания из класса. Проще
        говоря объект имеет конкретное значение параметров и способы работающие
        с этими качествами на базе правил, заданых в классе. В этом примере есть
        класс - это некий абстрактный автомобиль на чертеже, то объект - это
        конкретный автомобиль. <br />
        <b>Интерфейс</b><br />
        Когда мы подходим к авто и садимся за руль существует определенный набор
        элементов управления с которыми мы можем взаимодействовать. <br />
        <b>Интерфейс</b> - это набор свойств и методов класса, доступных для
        использования в работе с экземпляром <br />
        В сущности интерфейс описывает класс, четко определяя все возможные
        действия над ним. Хороший пример интерфейса - приборная панель авто,
        которая позволяет вызвать методы такие как увеличить скорость,
        тормажение и т.д <br />
        Описывая интерфейс класса очень важно выдержать баланс между гибкостью и
        простотой. Класс с простым интерфейсом будет легко использовать, но
        будут существовать задачи, которые с помощью него будет сложно решать.
        Если интерфейс будет гибким вероятней всего он будет содержать довольно
        сложные методы с большим кол-вом параметров, которые будут позволять
        делать очень много, но его использование будут связаны с большим трудом
        и риском ошибиться, перепутав что-то.
      </p>
    </section>
  </body>
</html>
